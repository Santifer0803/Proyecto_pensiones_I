---
title: "Resultados"
author: "Alejandro Brenes, Santiago Fernández, Eyeri Méndez y Erick Venegas"
date: "`r Sys.Date()`"
output: html_document
---

# Preparación inicial

## Librerías

Inicialmente, cargamos las librerías necesarias para el desarrollo del modelo.

```{r librerias, message = FALSE, warning = FALSE}
pacman::p_load(data.table,
               janitor,
               knitr,
               purrr,
               readxl,
               tidyverse,
               zoo)
```

## Datos del régimen

Se leen las bases de cotizantes, pensionados y de estados financieros.

```{r carga_cotpen, message = FALSE, warning = FALSE}
cotizantes <- read_excel("data/BD_Cotizantes.xlsx")
pensionados <- read_excel("data/BD_Pensionados.xlsx")
financiero <- read_excel("data/BD_Financiero.xlsx", sheet = "EEFF")
```

Se realizan algunas correcciones de formato en los pensionados y en los cotizantes.

```{r correcciones_cotpen}
# Se cambian los nombres de las columnas no numéricas de los cotizantes
cotizantes <- cotizantes %>% clean_names()

# Se corrigen los nombres de las columnas de la base de cotizantes
colnames(cotizantes)[4:363] <- format(seq(
  from = ymd("1995-01-01"),
  to = ymd("2024-12-01"),
  by = "1 month"
), "%m-%Y")

# Se corrigen los nombres de la base de pensionados
pensionados <- pensionados %>% clean_names() %>% select(-c("x9"))
```

## Probabilidades de muerte

Se cargan los datos de mortalidad dinámicos de la SUPEN.

```{r carga_mort}
mortalidad <- read_excel("data/mortalidad.xls")
```

Las probabilidades aparecen como caracteres, por lo que se realiza el cambio correspondiente.

```{r correcciones_mort}
# Se cambia el formato necesario
mortalidad$qx <- as.numeric(mortalidad$qx)

# Se guarda como DataTable
mortalidad <- setDT(mortalidad)
```

## Probabilidades de invalidez

Se procede a cargar las probabilidades de invalidez.

```{r carga_inv}
invalidez <- read_excel("data/invalidez.xlsx")
```

Todas las columnas salen como caracteres, por lo que se cambian.

```{r correcciones_inv}
# Se ponen las edades como números enteros
invalidez$Edad <- as.integer(invalidez$Edad)

# Se corrigen las probabilidades
invalidez$Hombres <- as.numeric(invalidez$Hombres)
invalidez$Mujeres <- as.numeric(invalidez$Mujeres)

# Se corrigen los nombres a un formato más simple
invalidez <- invalidez %>% clean_names()

# Se guarda como DataTable
invalidez <- setDT(invalidez)
```

## Inflación

```{r carga_inflacion, message = FALSE, warning = FALSE}
inflacion <- read_excel("data/inflacion_mundial.xls")
```

Se corrigen ciertos aspectos.

```{r correcciones_inflacion}
# Se filtran para tener solo los datos de Costa Rica
inflacion.cr <- inflacion %>%
  filter(`Data Source` %in% c("Costa Rica", "Country Name"))

inflacion.cr <- inflacion.cr[, -c(2, 3, 4)]

inflacion.cr[1, 1] <- "Año"

inflacion.cr <- as.data.frame(t(inflacion.cr))

colnames(inflacion.cr) <- as.character(inflacion.cr[1, ])

inflacion.cr <- inflacion.cr[-1, ]

# Se agrega el valor de 2024
inflacion.2024 <- data.frame("Año" = 2024, "Costa Rica" = 0.84)

colnames(inflacion.2024) <- colnames(inflacion.cr)

inflacion.cr <- rbind(inflacion.cr, inflacion.2024)

# Se reasignan las filas con numeración normal (1, 2, 3, ...)
row.names(inflacion.cr) <- NULL

# Se pasan las columnas a tipo numérico
inflacion.cr <- inflacion.cr %>%
  mutate(across(c(1, 2), as.numeric))

rm(inflacion)
rm(inflacion.2024)
```

# Modelo básico

## Parte determinista

En esta sección se concentran las variables invariantes. Es decir, aquellas que no cambiarán durante las iteraciones del modelo.

### Variables necesarias

```{r deterministica_base}
# Se guarda el valor de las reservas en formación (reserva inicial)
reserva.ini <- as.numeric(financiero[1, 2]) + as.numeric(financiero[31, 2])

### Beneficios de los cotizantes sin contar estado ###

# Se inicia creando la matriz de edades de los cotizantes, iniciando en la edad del 2025
edades <-
  matrix((2025 - year(cotizantes$fec_nac)),
         nrow = nrow(cotizantes),
         ncol = 95,
         byrow = FALSE
  )

# Se pone el año en cada columna
colnames(edades) <- format(seq(
  from = ymd("2025-01-01"),
  to = ymd("2119-01-01"),
  by = "1 year"
), "%Y")

# Se cambia la edad en cada columna
for (i in 2:ncol(edades)) {
  edades[, i] <- edades[, (i - 1)] + 1
}

# Se corrije la edad máxima a 115
edades <- ifelse(edades > 115, 115, edades)

# Se separan las edades por sexo
edades.h <- edades[which(cotizantes$sexo == 1), ]
edades.m <- edades[which(cotizantes$sexo == 2), ]

# Se determina el estado de actividad/inactividad de las personas en el 2023
estados23 <- rowSums(cotizantes[, 340:351] > 10000) > 0

# Se agrega el estado, separado por sexo, 1 es activo y 0 es inactivo
actividad.h <-
  matrix(
    estados23[which(cotizantes$sexo == 1)],
    nrow = nrow(edades.h),
    ncol = ncol(edades.h),
    byrow = FALSE
  )

actividad.m <-
  matrix(
    estados23[which(cotizantes$sexo == 2)],
    nrow = nrow(edades.m),
    ncol = ncol(edades.m),
    byrow = FALSE
  )

# Se eliminan las variables innecesarias
rm(estados23)

### Distintos estados a considerar ###

# Probabilidades de invalidez por sexo
inv.h <-
  matrix(
    invalidez[match(edades.h, edad), hombres],
    ncol = ncol(edades.h),
    nrow = nrow(edades.h),
    byrow = FALSE
  )

inv.m <-
  matrix(
    invalidez[match(edades.m, edad), mujeres],
    ncol = ncol(edades.m),
    nrow = nrow(edades.m),
    byrow = FALSE
  )

# Se cambia el nombre de las columnas de la matriz de invalidez
colnames(inv.h) <- colnames(edades.h)
colnames(inv.m) <- colnames(edades.m)

# Para las probabilidades de muerte, se inicia creando las matrices vacías
mort.h <- matrix(0, nrow = nrow(edades.h), ncol = ncol(edades.h))
mort.m <- matrix(0, nrow = nrow(edades.m), ncol = ncol(edades.m))

# Se corrigen los nombres de sus columnas
colnames(mort.h) <- colnames(edades.h)
colnames(mort.m) <- colnames(edades.m)

# Se agregan las probabilidades por cada año (columna), para ambos sexos
for (i in 1:ncol(mort.h)) {
  mort.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.h)[i])][.(edad = edades.h[, i]), 
                                                         on = .(edad), qx]
  mort.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.m)[i])][.(edad = edades.m[, i]), 
                                                         on = .(edad), qx]
}

# Se crea una lista para guardar los estados de invalidez y muerte de los cotizantes
lista.estados.h <- list()
lista.estados.m <- list()
```

### Proyección salarial

Se crea la función que permite anualizar los salarios en otro DataFrame.

```{r funcion_anualizar}
meses.to.annos <-
  function(df, columnas.excluir, anno.inicio = 1995) {
    # Se extrae el nombre de las columnas mensuales
    columnas.mensuales <- setdiff(names(df), columnas.excluir)
    
    # Se ordenan los nombres cronológicamente
    columnas.mensuales <- sort(columnas.mensuales)
    
    # Se calcula la cantidad de años completos
    n.meses <- length(columnas.mensuales)
    n.annos <- floor(n.meses / 12)
    
    nombres.annos <-
      as.character(seq(anno.inicio, by = 1, length.out = n.annos))
    
    # Se calculan los promedios anuales
    annos <- lapply(1:n.annos, function(i) {
      cols <- columnas.mensuales[((i - 1) * 12 + 1):(i * 12)]
      rowMeans(df[, cols], na.rm = TRUE)
    })
    
    # Se crea el DF de promedios
    df.anual <- as.data.frame(annos)
    names(df.anual) <- nombres.annos
    
    # Se combinan las columnas fijas y los promedios anuales
    df.final <- cbind(df[, columnas.excluir], df.anual)
    
    return(df.final)
  }

# Se crea el DF con salarios anualizados.
cotizantes.anualizado <-
  meses.to.annos(cotizantes, c("id", "fec_nac", "sexo"))

rm(meses.to.annos)
```

Se crea un nuevo DataFrame donde está la información con los salarios anualizados. Además, se cambia el formato de las columnas.

```{r formato_fecha}
# Se establece el tipo de variable fecha de la columna
cotizantes.anualizado$fec_nac <-
  as.Date(cotizantes.anualizado$fec_nac,
          format = "%Y/%m/%d")

# Se agrega una nueva variable edad al df
cotizantes.anualizado$edad <-
  2024 - as.numeric(format(cotizantes.anualizado$fec_nac, "%Y"))

# Se establece el tipo de variable fecha de la columna
cotizantes$fec_nac <- as.Date(cotizantes$fec_nac,
                              format = "%Y/%m/%d")

# Se agrega una nueva variable edad al df
cotizantes$edad <-
  2024 - as.numeric(format(cotizantes$fec_nac, "%Y"))
```

Se calcula una nueva columna para la matriz, la cual contiene la información del factor acumulativo por cada año, esto con el objetivo de que se multiplique el factor multiplicativo por el salario del respecto año para que éste se acumule hasta el año 2024.

```{r factor_acumulado}
# Se actualiza la tasa, para utilizar en cálculos de forma porcentual
inflacion.cr$`Costa Rica` <- inflacion.cr$`Costa Rica` / 100

inflacion.cr$factor_acumulado <-
  sapply(inflacion.cr$Año, function(anno) {
    
    if (anno == 2024) {
      
      return(1)
      
    } else {
      
      años.a.usar <- inflacion.cr$Año >= anno & inflacion.cr$Año <= 2024
      
      return(prod(1 + inflacion.cr$`Costa Rica`[años.a.usar]))
    }
    
  })
```

Se procede con el cálculo del valor presente de todos los salarios de la base, donde se toma como tasa de acumulación la inflación observada en el respectivo año.

```{r valor_presente}
# Se introducen los años contabilizados históricamente
columnas.años <- as.character(1995:2024)

# Copia del DataFrame para obtener el valor presente
cotizantes.anualizado.VP <- cotizantes.anualizado

# Se agrega iterativamente la inflación
for (año in columnas.años) {
  año.num <- as.numeric(año)
  
  factor <-
    inflacion.cr$factor_acumulado[inflacion.cr$Año == año.num]
  
  if (length(factor) == 1 && !is.na(factor)) {
    
    cotizantes.anualizado.VP[[año]] <-
      as.numeric(cotizantes.anualizado[[año]]) / factor
    
  }
}
```

Para graficar lo anterior, se debe pasar la base de datos a formato largo para su visualización.

```{r formato_largo}
# Convertir columnas de años a largo
cotizantes.anualizado.VP.largo <- cotizantes.anualizado.VP %>%
  pivot_longer(
    cols = all_of(columnas.años),
    names_to = "año",
    values_to = "salario.ajustado"
  ) %>%
  mutate(año = as.numeric(año))

rm(factor)
rm(año.num)
rm(año)
rm(columnas.años)
```

Se procede con la proyección de los salarios de manera brusca, es decir, se utilizan los datos sin suavizar.

```{r salarios_por_edad, message = FALSE, warning = FALSE}
salarios.por.edad <- cotizantes.anualizado %>%
  group_by(edad) %>%
  summarise(promedio.salario.2024 = mean(`2024`, na.rm = TRUE)) %>%
  arrange(edad) %>%
  mutate(tasa.incremento = promedio.salario.2024 / lag(promedio.salario.2024))

# Se obtienen las tasas de incremento
salarios.por.edad$tasa.incremento[1] = salarios.por.edad$tasa.incremento[2]
tasas.ext <- salarios.por.edad$tasa.incremento

# Se cambian los nombres de las tasas
names(tasas.ext) <- salarios.por.edad$edad

# Se procede a hacer la proyección
proyeccion.salarios <- cotizantes.anualizado.VP %>%
  select(id, edad, salario.2024 = `2024`) %>%
  rowwise() %>%
  mutate(proyeccion = list({
    
    edad.i <- edad
    salario.i <- salario.2024
    
    resultados <- tibble(edad = edad.i,
                         salario = salario.i)
    
    # 95 años hacia adelante
    for (anio in 1:95) {
      edad.i <- edad.i + 1
      
      if (edad.i < 65) {
        
        tasa.i <- tasas.ext[as.character(edad.i - 1)]
        
        if (is.na(tasa.i))
          
          break
        
        salario.i <- salario.i * tasa.i
        
      } else {
        
        # A partir de 65 años tasa = 1 (salario constante)
        salario.i <- salario.i
        
      }
      
      resultados <-
        add_row(resultados, edad = edad.i, salario = salario.i)
      
    }
    resultados
  })) %>%
  unnest(proyeccion, names_sep = ".")

# Se limpia el ambiente de las variables que fueron auxiliares
rm(tasas.ext)
```

Se crea la curva de salarios general, sin ser suavizada.

```{r}
curva.general <- proyeccion.salarios %>%
  group_by(proyeccion.edad) %>%
  summarise(salario.promedio = mean(proyeccion.salario, na.rm = TRUE))
```

El siguiente código tiene la finalidad de suavizar las tasas de incremento, lo que provocará que la curva salarial tenga un comportamiento menos errático. Además, el cálculo de estos valores es de utilidad a la hora de proyectar los salarios de cada individuo.

```{r obtencion_datos_suavizados}
modelo.loess <- loess(salario.promedio ~ proyeccion.edad, data = curva.general)

curva.suavizada <- curva.general %>%
  mutate(salario.suavizado = predict(modelo.loess, 
                                     newdata = data.frame(proyeccion.edad = 
                                                          proyeccion.edad)))

curva.suavizada <- curva.suavizada %>%
  arrange(proyeccion.edad) %>%  
  mutate(
    tasa.incremento = salario.suavizado / lag(salario.suavizado)
  )

curva.suavizada$tasa.incremento[1] <- curva.suavizada$tasa.incremento[2]
```

Se crea la función para proyectar en un gráfico a un individuo en particular. Esto utilizando los datos crudos de las tasas de incremento, con la finalidad de que se observe el comportamiento de la proyección.

```{r funcion_proyectar_persona}
graficar.proyeccion.id <- function(persona.id) {
  
  datos.iniciales <- cotizantes.anualizado.VP.largo %>%
    filter(id == persona.id, año == 2024) %>%
    select(id, edad, salario.2024 = salario.ajustado) %>%
    distinct()
  
  if (nrow(datos.iniciales) == 0) {
    stop("ID no encontrado en la base.")
  }
  
  edad.inicial <- datos.iniciales$edad
  salario.actual <- datos.iniciales$salario.2024
  
  proyeccion <- tibble(edad = edad.inicial,
                       salario = salario.actual)
  
  salario.i <- salario.actual
  edad.i <- edad.inicial
  
  for (i in 1:95) {
    
    edad.i <- edad.i + 1
    
    tasa.i <- curva.suavizada %>%
      filter(proyeccion.edad == edad.i) %>%
      pull(tasa.incremento)
    
    if (length(tasa.i) == 0 || is.na(tasa.i)) {
      tasa.i <- 1
    }
    
    salario.i <- salario.i * tasa.i
    
    proyeccion <-
      add_row(proyeccion, edad = edad.i, salario = salario.i)
  }
  
  ggplot(proyeccion, aes(x = edad, y = salario)) +
    geom_line(color = "purple", linewidth = 1.2) +
    labs(
      title = paste("Curva salarial proyectada para ID:", persona.id),
      x = "Edad proyectada",
      y = "Salario proyectado"
    ) +
    theme_minimal()
}
```

Se debe crear un nuevo DataFrame en el cual se tenga en valor presente las cotizaciones realizadas.

```{r Valor_presente_cotizantes}
# Extraemos todos los nombres de las columnas que tengan formato "MM-YYYY"
columnas.mensuales <-
  grep("^\\d{2}-\\d{4}$", colnames(cotizantes), value = TRUE)

cotizantes.VP <- cotizantes

for (col in columnas.mensuales) {
  # Extraemos el año del nombre de la columna, asumiendo formato "MM-YYYY"
  año <- as.numeric(sub(".*-(\\d{4})$", "\\1", col))
  
  # Buscamos el factor acumulado para ese año
  factor <- inflacion.cr$factor_acumulado[inflacion.cr$Año == año]
  
  if (length(factor) == 1 && !is.na(factor)) {
    
    # Dividimos la columna mensual por el factor para traer a valor presente
    cotizantes.VP[[col]] <- cotizantes[[col]] / factor
    
  } else {}
}

rm(año)
rm(col)
rm(columnas.mensuales)
rm(factor)
```

Se calcula el total de cotizaciones por persona.

```{r total_cotizaciones}
cotizantes.VP <- cotizantes.VP %>%
  rowwise() %>%
  mutate(cotizaciones = sum(c_across(`01-1995`:`12-2024`) >= 10000, 
                            na.rm = TRUE)) %>%
  ungroup()
```

Luego, se obtiene la cantidad de cotizaciones en 2023.

```{r numero_cotizaciones_2023}
meses.2023 <- paste0(sprintf("%02d", 1:12), "-2023")

cotizantes.VP <- cotizantes.VP %>%
  rowwise() %>%
  mutate(cotizaciones.2023 = sum(c_across(all_of(meses.2023)) >= 10000, 
                                 na.rm = TRUE)) %>%
  ungroup()

cotizantes.VP <- cotizantes.VP %>%
  mutate(edad = floor(interval(start = fec_nac, end = Sys.Date()) / years(1)))

rm(meses.2023)
```

Ahora, se obtienen las cotizaciones promedio, separando por edad, del año 2023.

```{r cotizaciones_promedio_edad}
cotizaciones.promedio.edad <- cotizantes.VP %>%
  group_by(edad) %>%
  summarise(promedio.cotizaciones = round(mean(cotizaciones.2023, 
                                               na.rm = TRUE))) %>%
  ungroup()
```

Se consigue el DataFrame con la información de las personas activas según el mes.

```{r data_inactivos}
columnas.excluir <- c("id", "fec_nac", "sexo", "edad", "cotizaciones", 
                      "cotizaciones.2023")

datos.variables <- cotizantes.VP[, !names(cotizantes.VP) %in% columnas.excluir]
datos.transformados <- as.data.frame(ifelse(datos.variables > 0, 1, 0))
datos.excluidos <- cotizantes.VP[, columnas.excluir, drop = FALSE]

cotizantes.VP.activos <- cbind(datos.excluidos, datos.transformados)
```

```{r frecuencia_inactivos}
data.anual <- cotizantes.VP.activos %>%
  pivot_longer(
    cols = -all_of(columnas.excluir),
    names_to = "mes_anio",
    values_to = "cotizacion"
  ) %>%
  mutate(anio = str_sub(mes_anio, start = 4)) 

resumen.anual <- data.anual %>%
  group_by(id, anio) %>%
  summarise(cotizaciones = sum(cotizacion, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = anio, values_from = cotizaciones)

columnas.info.extra <- cotizantes.VP.activos %>%
  select(all_of(columnas.excluir)) %>%
  distinct(id, .keep_all = TRUE)

cotizantes.activos <- columnas.info.extra %>%
  left_join(resumen.anual, by = "id")

rm(columnas.info.extra)
rm(resumen.anual)
rm(data.anual)
rm(columnas.excluir)
```

Se obtienen las probabilidades deterministas de postergación, para ambos sexos.

```{r probabilidad_postergacion_hombres}
df.probabilidad.postergacion.h <- ifelse(edades.h >= 65, 0.1, 0)
df.probabilidad.postergacion.m <- ifelse(edades.m >= 63, 0.1, 0)
```

Ahora, se construyen diversas variables auxiliares que servirán como apoyo para la parte estocástica.

```{r determinista_auxiliar}
# Se quitan las edades mayores a 66
cotizaciones.promedio.edad <- cotizaciones.promedio.edad %>% 
  filter(edad <= 66)

# Se agregan las edades restantes, que tienen densidad constante
cotizaciones.promedio.edad <- rbind(
  cotizaciones.promedio.edad,
  data.frame(
    edad = 67:115,
    promedio.cotizaciones = cotizaciones.promedio.edad[nrow(cotizaciones.promedio.edad), 2]
  )
)

# Se transforma en DT
cotizaciones.edad.dt <- setDT(cotizaciones.promedio.edad)

# Se obtiene una matriz con la cantidad de cuotas por edad, a partir de 2025, separado por sexo
matriz.cot.h <- matrix(
  cotizaciones.edad.dt[match(edades.h, edad), promedio.cotizaciones],
  ncol = ncol(edades.h),
  nrow = nrow(edades.h),
  byrow = FALSE
)

matriz.cot.m <- matrix(
  cotizaciones.edad.dt[match(edades.m, edad), promedio.cotizaciones],
  ncol = ncol(edades.m),
  nrow = nrow(edades.m),
  byrow = FALSE
)

# Matriz de 0s, del tamaño de la predicción mensualizada
matriz.salarios.h <- matrix(0, nrow = nrow(matriz.cot.h), 
                            ncol = (ncol(matriz.cot.h) * 12))
matriz.salarios.m <- matrix(0, nrow = nrow(matriz.cot.m), 
                            ncol = (ncol(matriz.cot.m) * 12))

# Se obtiene la inflación acumulada desde 1995
inflacion.95 <- (inflacion.cr %>% filter(Año >= 1995))[, 3]

# Se repite la inflación 12 veces (1 vez por mes)
inflacion.95 <- rep(inflacion.95, times = rep(12, length(inflacion.95)))

# Cotizaciones mensuales traídas a valor presente
cotizaciones.vp <-
  as.matrix(cotizantes[, (4:(ncol(cotizantes) - 1))]) * matrix(
    inflacion.95,
    nrow = nrow(cotizantes),
    ncol = ncol(cotizantes[(4:(ncol(cotizantes) - 1))]),
    byrow = TRUE
  )

# Cotizantes separados por sexo
cotizantes.h <- cotizaciones.vp[which(cotizantes$sexo == 1), ]
cotizantes.m <- cotizaciones.vp[which(cotizantes$sexo == 2), ]

# DataFrame de requisitos para invalidez
requisitos.inv <- data.table(edad = 21:115,
                             cotizaciones_min = c(rep(12, 3), 
                                                  seq(12, 84, 4), 
                                                  seq(90, 120, 6), 
                                                  rep(120, 67)))

# Matriz de edades modificada por los requisitos de invalidez, por sexo
requisitos.inv.h <- matrix(
  requisitos.inv[match(edades.h, edad), cotizaciones_min],
  ncol = ncol(edades.h),
  nrow = nrow(edades.h),
  byrow = FALSE
)

requisitos.inv.m <- matrix(
  requisitos.inv[match(edades.m, edad), cotizaciones_min],
  ncol = ncol(edades.m),
  nrow = nrow(edades.m),
  byrow = FALSE
)

# Se hace una corrección en los salarios. Primero, se agrega el año
proyeccion.salarios <- proyeccion.salarios %>% 
  mutate(anio = rep(c(2024:2119), nrow(cotizantes)))

# Se filtra la proyección para dejar los salarios futuros
proyeccion.salarios <- proyeccion.salarios %>% 
  filter(anio > 2024) %>% 
  mutate(proyeccion.salario = ifelse(edad > 115, 0, proyeccion.salario))

# Se hace una matriz con los salarios
matriz.salarios <-
  matrix(
    proyeccion.salarios$proyeccion.salario,
    nrow = nrow(cotizantes),
    ncol = ncol(edades),
    byrow = TRUE
  )

# Se filtra por sexo
salarios.h <- matriz.salarios[which(cotizantes$sexo == 1), ]
salarios.m <- matriz.salarios[which(cotizantes$sexo == 2), ]

# Ahora, se hará una matriz con las cotizaciones acumuladas de cada persona
cotizaciones.acum.h <- matriz.cot.h
cotizaciones.acum.m <- matriz.cot.m

# Se le suman las cotizaciones iniciales a la primer fila
cotizaciones.acum.h[, 1] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + 
  cotizaciones.acum.h[, 1]

cotizaciones.acum.m[, 1] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + 
  cotizaciones.acum.m[, 1]

# Se acumula la suma por fila
cotizaciones.acum.h <- t(apply(cotizaciones.acum.h, 1, cumsum))
cotizaciones.acum.m <- t(apply(cotizaciones.acum.m, 1, cumsum))

# Se corrige según si el trabajador está activo o inactivo
cotizaciones.acum.h <- cotizaciones.acum.h * actividad.h
cotizaciones.acum.m <- cotizaciones.acum.m * actividad.m

# Se agregan las cotizaciones acumuladas para los inactivos
cotizaciones.acum.h[which(cotizaciones.acum.h[, 1] == 0),] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][which(cotizaciones.acum.h[, 1] == 0)]

cotizaciones.acum.m[which(cotizaciones.acum.m[, 1] == 0),] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][which(cotizaciones.acum.m[, 1] == 0)]

# Se define la tasa de interés
interes.real <- ((0.1376-0.04) / 1.04) - 0.02

tasa.mensual <- (1 + interes.real)^(1/12) - 1

# Se crea el vector con las tasas de descuento
s <- 1 / ((1 + interes.real)^(0:(ncol(matriz.salarios) - 1)))

# Se obtienen las potencias de los valores presentes, incluyendo el aguinaldo
potencia.mensual <-
  rep(seq(1:(ncol(edades) * 12)), 
      times = ifelse((seq(1:(ncol(edades) * 12)) %% 12) == 0, 2, 1))

# Se obtiene el valor presente de cada periodo proyectado
matriz.vp <-
  matrix(((1 + tasa.mensual) ^ -((potencia.mensual - 1) / 12)), nrow(cotizantes), 
         length(potencia.mensual), byrow = TRUE)
```

### Probabilidades de muerte para cada edad

Seguidamente se crea una matriz con las probabilidades de muerte para cada edad desde 0 hasta 115 y desde el 2025 hasta el 2119.

```{r prob_muertes}
ages <- 0:115

edades.completas <- matrix(rep(ages, ncol(edades)), length(ages), ncol(edades))
colnames(edades.completas) <- colnames(edades)

mort.completa.h <- matrix(0, length(ages), ncol(edades))
mort.completa.m <- matrix(0, length(ages), ncol(edades))

colnames(mort.completa.h) <- colnames(edades)
colnames(mort.completa.m) <- colnames(edades)

for (i in 1:ncol(mort.completa.h)) {
  
  mort.completa.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.completa.h)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
  mort.completa.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.completa.m)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
}

mort.completa.h[is.na(mort.completa.h)] <- 1
mort.completa.m[is.na(mort.completa.m)] <- 1

mort.hijos <- 0.5 * (mort.completa.h + mort.completa.m)
```

### Variables pensiones

Se definen algunos parámetros para el cálculo de las pensiones.

```{r parametros_pensiones}
# Que excedan las 300 cotizaciones
bono.cotizaciones <- 0.000833

# Por mes de postergación
bono.postergacion <- 0.001333

# Tasa límite
tasa.maxima <- 1.25

# Tomando como supuesto 4 fines de semana al mes, y meses de 30 dias, se multiplica el salario por jornada diaria ordinaria por los días laborales del mes
salario.minimo <- 12236.95 * 22

# Función que calcula la cuantía básica con base en el art. 24
cuantia.basica <- function(salario.referencia) {
  cuantia <- numeric(length(salario.referencia))

  cuantia[salario.referencia < 2 * salario.minimo] <- 0.525
  cuantia[salario.referencia >= 2 * salario.minimo & salario.referencia < 3 * salario.minimo] <- 0.51
  cuantia[salario.referencia >= 3 * salario.minimo & salario.referencia < 4 * salario.minimo] <- 0.494
  cuantia[salario.referencia >= 4 * salario.minimo & salario.referencia < 5 * salario.minimo] <- 0.478
  cuantia[salario.referencia >= 5 * salario.minimo & salario.referencia < 6 * salario.minimo] <- 0.462
  cuantia[salario.referencia >= 6 * salario.minimo & salario.referencia < 8 * salario.minimo] <- 0.446
  cuantia[salario.referencia >= 8 * salario.minimo] <- 0.43

  return(cuantia)
}
```

Además, se crean las matrices con los montos de los pensionados actuales y se extraen las edades de cada uno de ellos.

```{r pensionados_iniciales}
# Filtramos la base de pensionados por sexo
pensionados.h <- pensionados[pensionados$sexo == "M", ]
pensionados.m <- pensionados[pensionados$sexo == "F", ]

# Filtramos los pensionados hombres con pensión por vejez
pensini.vej.h <- pensionados.h[pensionados.h$cod_tipo_pension == "Vejez", ]

# Determinamos el año en el que empezó a regir cada pensión
annos <- year(pensini.vej.h$rige_de_la_pension) - 1959

# Edad de cada pensionado
edadini.vej.h <- 2025 - year(pensini.vej.h$fec_nac)

# Acumulamos el monto de pensión por la inflación histórica correspondiente
pensini.vej.h <- pensini.vej.h$monto * inflacion.cr$factor_acumulado[annos]
pensini.vej.h <- matrix(pensini.vej.h, length(pensini.vej.h), ncol(edades))

# Se repite el proceso para las mujeres
pensini.vej.m <- pensionados.m[pensionados.m$cod_tipo_pension == "Vejez", ]
annos <- year(pensini.vej.m$rige_de_la_pension) - 1959
edadini.vej.m <- 2025 - year(pensini.vej.m$fec_nac)
pensini.vej.m <- pensini.vej.m$monto * inflacion.cr$factor_acumulado[annos]
pensini.vej.m <- matrix(pensini.vej.m, length(pensini.vej.m), ncol(edades))

# Filtramos los pensionados hombres con pensión por invalidez y repetimos el proceso
pensini.inv.h <- pensionados.h[pensionados.h$cod_tipo_pension == "Invalidez", ]
annos <- year(pensini.inv.h$rige_de_la_pension) - 1959
edadini.inv.h <- 2025 - year(pensini.inv.h$fec_nac)
pensini.inv.h <- pensini.inv.h$monto * inflacion.cr$factor_acumulado[annos]
pensini.inv.h <- matrix(pensini.inv.h, length(pensini.inv.h), ncol(edades))

# Igual para las mujeres
pensini.inv.m <- pensionados.m[pensionados.m$cod_tipo_pension == "Invalidez", ]
annos <- year(pensini.inv.m$rige_de_la_pension) - 1959
edadini.inv.m <- 2025 - year(pensini.inv.m$fec_nac)
pensini.inv.m <- pensini.inv.m$monto * inflacion.cr$factor_acumulado[annos]
pensini.inv.m <- matrix(pensini.inv.m, length(pensini.inv.m), ncol(edades))

# Filtramos los pensionados hombres cónyuges con pensión por sucesión y repetimos el proceso
pension.suc.ch <- pensionados.h[pensionados.h$cod_tipo_pension == "Sucesión", ]
pension.suc.ch <- pension.suc.ch[pension.suc.ch$cod_parentesco == "C", ]

# Repetimos el proceso anterior
annos <- year(pension.suc.ch$rige_de_la_pension) - 1959
edad.suc.ch <- 2025 - year(pension.suc.ch$fec_nac)
pension.suc.ch <- pension.suc.ch$monto * inflacion.cr$factor_acumulado[annos]
pension.suc.ch <- matrix(pension.suc.ch, length(pension.suc.ch), ncol(edades))

# Filtramos ahora por hombres hijos con pensión por sucesión
pension.suc.hh <- pensionados.h[pensionados.h$cod_tipo_pension == "Sucesión", ]
pension.suc.hh <- pension.suc.hh[pension.suc.hh$cod_parentesco == "H", ]

# Repetimos el proceso anterior
annos <- year(pension.suc.hh$rige_de_la_pension) - 1959
edad.suc.hh <- 2025 - year(pension.suc.hh$fec_nac)
pension.suc.hh <- pension.suc.hh$monto * inflacion.cr$factor_acumulado[annos]
pension.suc.hh <- matrix(pension.suc.hh, length(pension.suc.hh), ncol(edades))

# Lo mismo para mujeres
pension.suc.cm <- pensionados.m[pensionados.m$cod_tipo_pension == "Sucesión", ]
pension.suc.cm <- pension.suc.cm[pension.suc.cm$cod_parentesco == "C", ]

annos <- year(pension.suc.cm$rige_de_la_pension) - 1959
edad.suc.cm <- 2025 - year(pension.suc.cm$fec_nac)
pension.suc.cm <- pension.suc.cm$monto * inflacion.cr$factor_acumulado[annos]
pension.suc.cm <- matrix(pension.suc.cm, length(pension.suc.cm), ncol(edades))

pension.suc.hm <- pensionados.m[pensionados.m$cod_tipo_pension == "Sucesión", ]
pension.suc.hm <- pension.suc.hm[pension.suc.hm$cod_parentesco == "H", ]

annos <- year(pension.suc.hm$rige_de_la_pension) - 1959
edad.suc.hm <- 2025 - year(pension.suc.hm$fec_nac)
pension.suc.hm <- pension.suc.hm$monto * inflacion.cr$factor_acumulado[annos]
pension.suc.hm <- matrix(pension.suc.hm, length(pension.suc.hm), ncol(edades))

rm(pensionados.h, pensionados.m, annos)
```

## Parte estocástica

En esta sección se encuentra todo objeto que sea, o dependa, de algún elemento estocástico. Son los factores que varían en cada una de las iteraciones del modelo en alguna forma.

Primero, se crean las listas para guardar las razones de solvencia, los balances (activo, pasivo), las primas medias niveladas, los años críticos, los beneficios devengados y las pensiones en cada iteración.

```{r listas_iniciales}
razon.solvencia <- list()
annos.crit <- list()
balance <- list()
prima.media <- list()
beneficio.devengado.vejez <- list()
beneficio.devengado.invalidez <- list()
beneficio.devengado.sucesion <- list()
pensiones <- list()

# Inicializamos los promedios para asegurarnos de que se harán mínimo 2 iteraciones
prom.antes <- 0
prom.despues <- 1
```

Con esto, se procede con el modelo en sí.

```{r estocastico_base, echo = FALSE}
start.time <- Sys.time()

while(abs(prom.despues - prom.antes) >= 0.00001){
  
# Se crean dos matrices aleatorias usando distribución Uniforme(0, 1)
matriz.aleatoria.h <- matrix(runif(nrow(cotizantes.h) * ncol(mort.h)), 
                             nrow(cotizantes.h), ncol(mort.h))

matriz.aleatoria.m <- matrix(runif(nrow(cotizantes.m) * ncol(mort.m)), 
                             nrow(cotizantes.m), ncol(mort.m))

# Se continúa con las matrices de probabilidades de postergación
postergacion.simulada.h <- matriz.aleatoria.h < df.probabilidad.postergacion.h
postergacion.simulada.m <- matriz.aleatoria.m < df.probabilidad.postergacion.m

# Se corrigen las postergaciones incorrectas
postergacion.simulada.h <-
  t(apply(postergacion.simulada.h, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))
postergacion.simulada.m <-
  t(apply(postergacion.simulada.m, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))

# Matrices de números uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <-
  inv.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.h[[2]] <-
  mort.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.m[[1]] <-
  inv.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

lista.estados.m[[2]] <-
  mort.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Se hacen las correcciones, para que si entra en un estado se mantenga en él durante el tiempo
lista.estados.h[[1]] <-
  t(apply(lista.estados.h[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.h[[2]] <-
  t(apply(lista.estados.h[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[1]] <-
  t(apply(lista.estados.m[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[2]] <-
  t(apply(lista.estados.m[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))

# Se hace la matriz con los estados de cada persona, separando por sexo
estados.h <-
  ifelse(lista.estados.h[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.h[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.h == 1) * (cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 1,
           "Posterga",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 1)) == 1,
           "Activo",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 0)) == 1, "Inactivo", ifelse(
             edades.h > 64,
             "Retirado",
             ifelse(actividad.h == 1, "Activo", "Inactivo")
           ))
           ))
         ))
estados.m <-
  ifelse(lista.estados.m[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.m[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 404) * (edades.m == 63)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 356) * (edades.m == 64)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 179) * (edades.m > 64)
           ) == 1,
           "Posterga",
           ifelse(
             ((edades.m == 63) * (cotizaciones.acum.m > 404)) == 1,
             "Retirado",
             ifelse(((edades.m == 64) * (cotizaciones.acum.m > 356)
             ) == 1, "Retirado", ifelse(((edades.m > 64) * (cotizaciones.acum.m > 179)) == 1,
                                        "Retirado",
                                        ifelse(actividad.m == 1, "Activo", "Inactivo")
             ))
           ))
           ))
         ))

# Existe el caso en donde una persona retirada puede quedar inválida posteriormente, por lo que se corrije dicho escenario
estados.h <- t(apply(estados.h, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))

# Ahora, existe el caso en donde una persona retirada puede postergar, por lo que se corrije ese caso
estados.h <- t(apply(estados.h, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))

# Se obtiene el salario, separado por sexo
salario.estoc.h <-
  salarios.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
salario.estoc.m <-
  salarios.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Obtenemos las razones de salida, separado por sexo
salida.h <- apply(estados.h, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})
salida.m <- apply(estados.m, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})

# Cotizaciones reales
cotizaciones.h <- matriz.cot.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
cotizaciones.m <- matriz.cot.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Consideramos la cantidad final de cuotas, separada por sexo
cuotas.finales.h <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + rowSums(cotizaciones.h)
cuotas.finales.m <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + rowSums(cotizaciones.m)

# Vamos a obtener los salarios de cada persona, separado por sexo, de la parte estocástica
salarios.aux.h <- do.call(rbind, lapply(1:nrow(salario.estoc.h), function(i) {
  unlist(lapply(1:ncol(salario.estoc.h), function(j) {
    c(rep(salario.estoc.h[i, j], times = cotizaciones.h[i, j]),
      rep(0, 12 - cotizaciones.h[i, j]))
  }))
}))
salarios.aux.m <- do.call(rbind, lapply(1:nrow(salario.estoc.m), function(i) {
  unlist(lapply(1:ncol(salario.estoc.m), function(j) {
    c(rep(salario.estoc.m[i, j], times = cotizaciones.m[i, j]),
      rep(0, 12 - cotizaciones.m[i, j]))
  }))
}))

# Se juntan las matrices de salarios
matriz.salarios.h <- cbind(cotizantes.h, salarios.aux.h)
matriz.salarios.m <- cbind(cotizantes.m, salarios.aux.m)

# Obtenemos los mejores salarios ordenados (pueden incluir 0), separados por sexo
salarios.top.h <- t(apply(matriz.salarios.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))
salarios.top.m <- t(apply(matriz.salarios.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))

# Identificamos las diferencias entre los salarios
diferencias.h <- t(apply(salarios.top.h, 1, function(fila) {
  abs(diff(fila))
}))
diferencias.m <- t(apply(salarios.top.m, 1, function(fila) {
  abs(diff(fila))
}))

# Cantidad de columnas en las diferencias
columnas.diff <- ncol(diferencias.h) - 1

# Un salario será atípico si es mayor a 5 millones y tiene menos de 12 salarios en un rango de 500 000 colones con ese monto o tiene un salario con una diferencia de más de 500 000 colones al siguiente 
# Iniciamos viendo las diferencias
atipicos.h <- t(apply(diferencias.h, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))
atipicos.m <- t(apply(diferencias.m, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))

# Ahora consideramos los atípicos en la matriz de salarios, considerando aquellos que son de más de 5 millones
salarios.top.h <-
  salarios.top.h[, -ncol(salarios.top.h)] * !(atipicos.h * (salarios.top.h[, -ncol(salarios.top.h)] > 5000000))
salarios.top.m <-
  salarios.top.m[, -ncol(salarios.top.m)] * !(atipicos.m * (salarios.top.m[, -ncol(salarios.top.m)] > 5000000))

# Se sacan los 300 mejores salarios, ahora sin los salarios atípicos
salarios.top.h <- t(apply(salarios.top.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))
salarios.top.m <- t(apply(salarios.top.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))

# Beneficio por vejez, separado por sexo
beneficio.vejez.h <-
  (pmin(300, cuotas.finales.h[which(salida.h == "Retirado")]) / 300) * (rowSums(salarios.top.h[which(salida.h == "Retirado"),]) / rowSums(salarios.top.h[which(salida.h == "Retirado"),] > 9999))
# Hacer la corrección a estados M, en donde las mujeres pueden retirarse a partir de los 63 si cumplen los requisitos
beneficio.vejez.m <-
  (pmin(300, cuotas.finales.m[which(salida.m == "Retirado")]) / 300) * (rowSums(salarios.top.m[which(salida.m == "Retirado"),]) / rowSums(salarios.top.m[which(salida.m == "Retirado"),] > 9999))

# Filas de invalidez
filas.inv.h <- which(salida.h == "Invalido")
filas.inv.m <- which(salida.m == "Invalido")

# Para el beneficio por invalidez, separado por sexo, iniciamos obteniendo la casilla en donde quedaron inválidos
restantes.inv.h <-
  apply(estados.h[filas.inv.h, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })
restantes.inv.m <-
  apply(estados.m[filas.inv.m, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })

# Se compara si se han tenido las cuotas necesarias
cuotas.binario.h <- mapply(function(i, j) {
  requisitos.inv.h[i, j] <= cuotas.finales.h[i]
}, i = filas.inv.h, j = restantes.inv.h)
cuotas.binario.m <- mapply(function(i, j) {
  requisitos.inv.m[i, j] <= cuotas.finales.m[i]
}, i = filas.inv.m, j = restantes.inv.m)

# Se obtienen las edades para las cuales se invalidó la persona (se pone acá y se borra la anterior que estaba)
edad.final.h <- restantes.inv.h + edades.h[filas.inv.h, 1] - 1
edad.final.m <- restantes.inv.m + edades.m[filas.inv.m, 1] - 1

# En este punto, se ve si las personas pensionadas por invalidez tienen las cuotas necesarias según el inciso b del artículo 6
requisito.cuotas.h <-
  (ifelse(
    ((restantes.inv.h == 1) * (edad.final.h < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.h == 2) * (edad.final.h < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
      ifelse((edad.final.h < 48), rowSums(cotizaciones.h[filas.inv.h, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.h == 1) * (edad.final.h > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.h == 2) * (edad.final.h > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 325:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
                           ifelse(((restantes.inv.h == 3) * (edad.final.h > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:2]),
                                  ifelse(((restantes.inv.h == 4) * (edad.final.h > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:3]),
                                         ifelse((edad.final.h > 47) == 1, rowSums(cotizaciones.h[filas.inv.h, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23
requisito.cuotas.m <-
  (ifelse(
    ((restantes.inv.m == 1) * (edad.final.m < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.m == 2) * (edad.final.m < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
      ifelse((edad.final.m < 48), rowSums(cotizaciones.m[filas.inv.m, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.m == 1) * (edad.final.m > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.m == 2) * (edad.final.m > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 325:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
                           ifelse(((restantes.inv.m == 3) * (edad.final.m > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:2]),
                                  ifelse(((restantes.inv.m == 4) * (edad.final.m > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:3]),
                                         ifelse((edad.final.m > 47) == 1, rowSums(cotizaciones.m[filas.inv.m, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23

# Si una persona inválida tiene las cuotas necesarias para su edad y cotizó 12 veces en los últimos 24 meses, tiene derecho a recibir pensión
resultado.binario.h <- cuotas.binario.h * requisito.cuotas.h
resultado.binario.m <- cuotas.binario.m * requisito.cuotas.m

# Beneficios por invalidez
beneficio.invalidez.h <-
  ifelse(cuotas.finales.h[filas.inv.h] > 299,
         (rowSums(salarios.top.h[filas.inv.h, ]) / 300),
         ifelse(cuotas.finales.h[filas.inv.h] > 179, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), ifelse(((cuotas.finales.h[filas.inv.h] < 180) * (resultado.binario.h == 1)
         ) == 1, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), 0)))
beneficio.invalidez.m <-
  ifelse(cuotas.finales.m[filas.inv.m] > 299,
         (rowSums(salarios.top.m[filas.inv.m, ]) / 300),
         ifelse(cuotas.finales.m[filas.inv.m] > 179, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), ifelse(((cuotas.finales.m[filas.inv.m] < 180) * (resultado.binario.m == 1)
         ) == 1, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), 0)))

# Primero, los índices de las personas que mueren
filas.muerte.h <- which(salida.h == "Fallecido")
filas.muerte.m <- which(salida.m == "Fallecido")

# Se identifican las columnas en la que ocurre la muerte (el año)
col.fallecido.h <-
  apply(estados.h[filas.muerte.h,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

col.fallecido.m <-
  apply(estados.m[filas.muerte.m,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

# Edad de la persona al morir para cada sexo
edad.fallecido.h <-
  mapply(function(i, j)
    edades.h[i, j], i = filas.muerte.h, j = col.fallecido.h)

edad.fallecido.m <-
  mapply(function(i, j)
    edades.m[i, j], i = filas.muerte.m, j = col.fallecido.m)

# Se crean dos vectores donde se identifica si al momento de la muerte el afiliado tenía un hijo
hijos.h <- edad.fallecido.h >= 25 & (edad.fallecido.h - 25) < 25
hijos.m <- edad.fallecido.m >= 25 & (edad.fallecido.m - 25) < 25

# Se calcula la pensión sucesoria con base en la pensión por vejez que hubiera recibido (art. 27)
salarios.sucesion.h <- salarios.top.h[filas.muerte.h,]
salarios.sucesion.m <- salarios.top.m[filas.muerte.m,]

beneficio.base.h <- rowSums(salarios.sucesion.h) / rowSums(salarios.top.h[which(salida.h == "Fallecido"),] > 9999)
beneficio.base.m <- rowSums(salarios.sucesion.m) / rowSums(salarios.top.m[which(salida.m == "Fallecido"),] > 9999)

# Se calcula el porcentaje para pensión por viudez según edad del cónyuge por art. 27: 70% si cónyuge ≥ 60, 60% si 50–59, 50% si < 50
porcentaje.viudez.h <- ifelse(edad.fallecido.h >= 60,
                              0.70,
                              ifelse(edad.fallecido.h >= 50, 0.60, 0.50))

porcentaje.viudez.m <- ifelse(edad.fallecido.m >= 60,
                              0.70,
                              ifelse(edad.fallecido.m >= 50, 0.60, 0.50))

# Así como el porcentaje para pensión por orfandad (30% si el hijo califica) art. 27: 30% para hijos menores de 25 años
porcentaje.hijo.h <- ifelse(hijos.h, 0.30, 0)
porcentaje.hijo.m <- ifelse(hijos.m, 0.30, 0)

# Se calcula el beneficio por sucesión (sin validar aún si tiene derecho)
beneficio.conyuge.h <- beneficio.base.h * porcentaje.viudez.h
beneficio.conyuge.m <- beneficio.base.m * porcentaje.viudez.m

beneficio.hijo.h <- beneficio.base.h * porcentaje.hijo.h
beneficio.hijo.m <- beneficio.base.m * porcentaje.hijo.m

# Se verifica si tiene derecho al beneficio por sucesion (art. 18)

# Condición 1: tener al menos 180 cotizaciones totales
requisito.180.h <- cuotas.finales.h[filas.muerte.h] >= 180
requisito.180.m <- cuotas.finales.m[filas.muerte.m] >= 180

# Condición 2: haber cotizado al menos 12 veces en los últimos 24 meses antes de morir, si murió antes de los 24 meses simulados se usan los datos anteriores que están en la base

requisito.24meses.h <-
  ifelse(
    col.fallecido.h == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 337:360] > 10000),
    ifelse(
      col.fallecido.h == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 349:360] > 10000) + cotizaciones.h[filas.muerte.h, 1],
      rowSums(cotizaciones.h[filas.muerte.h, 1:2])
    )
  ) > 11

requisito.24meses.m <-
  ifelse(
    col.fallecido.m == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 337:360] > 10000),
    ifelse(
      col.fallecido.m == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 349:360] > 10000) + cotizaciones.m[filas.muerte.m, 1],
      rowSums(cotizaciones.m[filas.muerte.m, 1:2])
    )
  ) > 11

# Debe de cumplir ambos requisitos
tiene.derecho.sucesion.h <- requisito.180.h & requisito.24meses.h
tiene.derecho.sucesion.m <- requisito.180.m & requisito.24meses.m

# Se verifica si califica para el derecho o no. En caso de que no se asigna un beneficio = 0
beneficio.conyuge.h <-
  ifelse(tiene.derecho.sucesion.h, beneficio.conyuge.h, 0)
beneficio.hijo.h    <-
  ifelse(tiene.derecho.sucesion.h, beneficio.hijo.h, 0)

beneficio.conyuge.m <-
  ifelse(tiene.derecho.sucesion.m, beneficio.conyuge.m, 0)
beneficio.hijo.m    <-
  ifelse(tiene.derecho.sucesion.m, beneficio.hijo.m, 0)

# Las filas de personas que se retiraron
filas.vejez.h <- which(salida.h == "Retirado")
filas.vejez.m <- which(salida.m == "Retirado")

# Los salario promedio base (prom. de 300 mejores salarios)
salario.referencia.h <- beneficio.vejez.h
salario.referencia.m <- beneficio.vejez.m

# La cuantía básica según salario
cuantia.vejez.h <- cuantia.basica(salario.referencia.h)
cuantia.vejez.m <- cuantia.basica(salario.referencia.m)

# La bonificación por cotizaciones adicionales (exceso sobre 300)
meses.extra.h <- pmax(0, cuotas.finales.h[filas.vejez.h] - 300)
meses.extra.m <- pmax(0, cuotas.finales.m[filas.vejez.m] - 300)
bono.cuotas.h <- meses.extra.h * bono.cotizaciones
bono.cuotas.m <- meses.extra.m * bono.cotizaciones

# La bonificación por postergación (meses en estado "Posterga")
meses.post.h <- 12 * rowSums(postergacion.simulada.h[filas.vejez.h, ])
meses.post.m <- 12 * rowSums(postergacion.simulada.m[filas.vejez.m, ])
bono.post.h <- meses.post.h * bono.postergacion
bono.post.m <- meses.post.m * bono.postergacion

# La tasa de reemplazo final
tasa.vejez.h <- cuantia.vejez.h + bono.cuotas.h + bono.post.h
tasa.vejez.m <- cuantia.vejez.m + bono.cuotas.m + bono.post.m

# Pensión final por vejez
pension.vejez.h <- salario.referencia.h * pmin(tasa.vejez.h, tasa.maxima)
pension.vejez.m <- salario.referencia.m * pmin(tasa.vejez.m, tasa.maxima)

# El salario base
salario.referencia.inv.h <- beneficio.invalidez.h
salario.referencia.inv.m <- beneficio.invalidez.m

# La cuantía básica
cuantia.invalidez.h <- cuantia.basica(salario.referencia.inv.h)
cuantia.invalidez.m <- cuantia.basica(salario.referencia.inv.m)

# La bonificación por cuotas (más de 300)
meses.extra.inv.h <- pmax(0, cuotas.finales.h[filas.inv.h] - 300)
meses.extra.inv.m <- pmax(0, cuotas.finales.m[filas.inv.m] - 300)
bono.cuotas.inv.h <- meses.extra.inv.h * bono.cotizaciones
bono.cuotas.inv.m <- meses.extra.inv.m * bono.cotizaciones

# La tasa de reemplazo
tasa.invalidez.h <- cuantia.invalidez.h + bono.cuotas.inv.h
tasa.invalidez.m <- cuantia.invalidez.m + bono.cuotas.inv.m

# La pensión por invalidez
pension.invalidez.h <- salario.referencia.inv.h * pmin(tasa.invalidez.h, tasa.maxima)
pension.invalidez.m <- salario.referencia.inv.m * pmin(tasa.invalidez.m, tasa.maxima)

# La pensión por sucesión
pension.sucesion.h <- beneficio.conyuge.h + beneficio.hijo.h
pension.sucesion.m <- beneficio.conyuge.m + beneficio.hijo.m

### Pensiones por vejez

# Filtramos la matriz de estados a partir de las personas con beneficio por vejez
matriz.vejez.h <- estados.h[filas.vejez.h, ]
matriz.vejez.m <- estados.m[filas.vejez.m, ]

# Filtramos la matriz de edades a partir de las personas con beneficio por vejez
edades.vejez.h <- edades.h[filas.vejez.h, ]
edades.vejez.m <- edades.m[filas.vejez.m, ]

# Calculamos en qué año ocurre el retiro por vejez para cada individuo
restantes.ret.h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Retirado")[1]
})

restantes.ret.m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Retirado")[1]
})

# Calculamos en qué año ocurre el fallecimiento para cada individuo
indices.2h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices de beneficio con ceros
matriz.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))
matriz.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Construimos la matriz de beneficios para hombres
for (i in 1:nrow(matriz.vejez.h)) {
  
  indice <- indices.2h[i]  # Año en que fallece la i-ésima persona
  
  # Se asigna 1 desde el retiro hasta justo antes del fallecimiento
  matriz.vejez.h[i, restantes.ret.h[i]:(indice - 1)] <- 1 

  edad <- edades.vejez.h[i, indice]  # Edad al fallecer

  # Se calcula la cantidad de años para simular la sobrevivencia del cónyuge
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Se extraen las probabilidades de muerte del cónyuge (mujer) por edad y año
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]

  # Se simula la vida del cónyuge comparando las probabilidades con números aleatorios
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio  # TRUE si muere

  # Se determina cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Se asigna 0.7 al beneficio durante los años en que el cónyuge está vivo
  matriz.vejez.h[i, indice:(indice + indice.3)] <- 0.7
}

# Lo mismo para mujeres
for (i in 1:nrow(matriz.vejez.m)) {
  
  indice <- indices.2m[i]
  matriz.vejez.m[i, restantes.ret.m[i]:(indice - 1)] <- 1
  
  edad <- edades.vejez.m[i, indice]
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejez.m[i, indice:(indice + indice.3)] <- 0.7
}

# Se construyen las matrices con los montos de pensión
monto.vejez.h <- matrix(pension.vejez.h, nrow(matriz.vejez.h), ncol(matriz.vejez.h))
monto.vejez.m <- matrix(pension.vejez.m, nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Multiplicamos las matrices de beneficios (0, 1, 0.7) por el monto de pensión
matriz.vejez.h <- matriz.vejez.h * monto.vejez.h
matriz.vejez.m <- matriz.vejez.m * monto.vejez.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejez.h <- pmin(matriz.vejez.h, 3500000)
matriz.vejez.m <- pmin(matriz.vejez.m, 3500000)

rm(edades.vejez.h, edades.vejez.m, monto.vejez.h, monto.vejez.m)

### Pensiones por invalidez

# Extraemos las filas correspondientes a inválidos
matriz.inv.h <- estados.h[filas.inv.h, ]
matriz.inv.m <- estados.m[filas.inv.m, ]

# Extraemos las edades correspondientes a inválidos
edades.inv.h <- edades.h[filas.inv.h, ]
edades.inv.m <- edades.m[filas.inv.m, ]

# Obtenemos el primer periodo donde se observa el estado "Fallecido"
indices.2h <- apply(matriz.inv.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.inv.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices con ceros para hombres y mujeres inválidos
matriz.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
matriz.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))

# Llenamos la matriz de hombres
for (i in 1:nrow(matriz.inv.h)) {
  
  indice <- indices.2h[i]  # Primer año de fallecimiento
  matriz.inv.h[i, restantes.inv.h[i]:(indice - 1)] <- 1  # Periodo de invalidez antes de fallecer
  
  edad <- edades.inv.h[i, indice]  # Edad al fallecer
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Obtenemos el qx del cónyuge (mujer)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  # Simulamos la vida del cónyuge con aleatoriedad
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1  # Tiempo que sobrevive el cónyuge

  # Asignamos el porcentaje de pensión según la edad
  if(edad >= 60){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)  # Máximo hasta que el hijo cumpla 25

    matriz.inv.h[i, indice:(indice + indice.4)] <- 
      matriz.inv.h[i, indice:(indice + indice.4)] + 0.3  # Agregamos el beneficio por hijo

  } else {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para las mujeres
for (i in 1:nrow(matriz.inv.m)) {
  
  indice <- indices.2m[i]
  matriz.inv.m[i, restantes.inv.m[i]:(indice - 1)] <- 1
  
  edad <- edades.inv.m[i, indice]
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)

  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Beneficio por hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.inv.m[i, indice:(indice + indice.4)] <- 
      matriz.inv.m[i, indice:(indice + indice.4)] + 0.3
    
  } else {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indices.2m[i] + 50 - edad):(indices.2m[i] + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Creamos las matrices de montos
monto.inv.h <- matrix(pension.invalidez.h, nrow(matriz.inv.h), ncol(matriz.inv.h))
monto.inv.m <- matrix(pension.invalidez.m, nrow(matriz.inv.m), ncol(matriz.inv.m))

# Aplicamos el monto a cada proporción de pensión
matriz.inv.h <- matriz.inv.h * monto.inv.h
matriz.inv.m <- matriz.inv.m * monto.inv.m

# Aplicamos el tope de pensión máximo de 3.5 millones
matriz.inv.h <- pmin(matriz.inv.h, 3500000)
matriz.inv.m <- pmin(matriz.inv.m, 3500000)

rm(edades.inv.h, edades.inv.m, monto.inv.h, monto.inv.m)

### Pensiones por sucesión

# Se inicializan matrices de ceros para guardar la sucesión de los hombres y mujeres
matriz.suc.h <- matrix(as.numeric(0), nrow(estados.h[filas.muerte.h, ]),
                       ncol(estados.h[filas.muerte.h, ]))

matriz.suc.m <- matrix(as.numeric(0), nrow(estados.m[filas.muerte.m, ]),
                       ncol(estados.m[filas.muerte.m, ]))

# Se calcula la matriz de sucesión de los hombres fallecidos
for(i in 1:nrow(matriz.suc.h)){
  
  edad <- edad.fallecido.h[i]  # Edad del hombre fallecido
  col <- col.fallecido.h[i]    # Columna donde inicia la sucesión

  # Se determina la cantidad de años a simular
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - col + 1)

  # Se obtienen las probabilidades de fallecimiento del cónyuge
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), col:(col + n - 1))]

  # Se simulan eventos aleatorios de fallecimiento del cónyuge
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio

  # Se identifica cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Asignación de porcentaje según edad al fallecer y condiciones
  if(edad >= 60){
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.h[i]){  # Si hay hijos
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.h[i, col:(col + indice.4)] <- 
      matriz.suc.h[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para mujeres
for(i in 1:nrow(matriz.suc.m)){
  
  edad <- edad.fallecido.m[i]
  col <- col.fallecido.m[i]

  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - col + 1)
  
  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), col:(col + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.m[i]){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  
    # Mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.m[i, col:(col + indice.4)] <- 
      matriz.suc.m[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se asigna el monto del beneficio base solo a los que tienen derecho a sucesión
sucesion.aux.h <- ifelse(tiene.derecho.sucesion.h, beneficio.base.h, 0)
sucesion.aux.m <- ifelse(tiene.derecho.sucesion.m, beneficio.base.m, 0)

# Se crean matrices con los montos por sucesión
monto.suc.h <- matrix(sucesion.aux.h, nrow(matriz.suc.h), ncol(matriz.suc.h))
monto.suc.m <- matrix(sucesion.aux.m, nrow(matriz.suc.m), ncol(matriz.suc.m))

# Se multiplica la proporción asignada por el monto base
matriz.suc.h <- matriz.suc.h * monto.suc.h
matriz.suc.m <- matriz.suc.m * monto.suc.m

# Se limita el monto máximo de la pensión por sucesión a 3.5 millones
matriz.suc.h <- pmin(matriz.suc.h, 3500000)
matriz.suc.m <- pmin(matriz.suc.m, 3500000)

rm(monto.suc.h, monto.suc.m, sucesion.aux.h, sucesion.aux.m)

### Pensionados iniciales

## Vejez

# Inicializamos las matrices de beneficio con ceros
matriz.vejini.h <- matrix(as.numeric(0), nrow(pensini.vej.h), ncol(edades))
matriz.vejini.m <- matrix(as.numeric(0), nrow(pensini.vej.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.vejini.h)) {
  
  edad <- edadini.vej.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.h[i, indice:(indice + indice.3)] <- 0.7
}

# Caso para mujeres
for (i in 1:nrow(matriz.vejini.m)) {
  
  edad <- edadini.vej.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.m[i, indice:(indice + indice.3)] <- 0.7
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.vejini.h <- matriz.vejini.h * pensini.vej.h
matriz.vejini.m <- matriz.vejini.m * pensini.vej.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejini.h <- pmin(matriz.vejini.h, 3500000)
matriz.vejini.m <- pmin(matriz.vejini.m, 3500000)

## Invalidez

# Inicializamos las matrices de beneficio con ceros
matriz.invini.h <- matrix(as.numeric(0), nrow(pensini.inv.h), ncol(edades))
matriz.invini.m <- matrix(as.numeric(0), nrow(pensini.inv.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.invini.h)) {
  
  edad <- edadini.inv.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.h[i, indice:(indice + indice.4)] <- 
      matriz.invini.h[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Caso para mujeres
for (i in 1:nrow(matriz.invini.m)) {
  
  edad <- edadini.inv.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.m[i, indice:(indice + indice.4)] <- 
      matriz.invini.m[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.invini.h <- matriz.invini.h * pensini.inv.h
matriz.invini.m <- matriz.invini.m * pensini.inv.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.invini.h <- pmin(matriz.invini.h, 3500000)
matriz.invini.m <- pmin(matriz.invini.m, 3500000)

## Sucesión cónyuge

# Inicializamos las matrices de beneficio con ceros
matriz.suc.ch <- matrix(as.numeric(0), nrow(pension.suc.ch), ncol(edades))
matriz.suc.cm <- matrix(as.numeric(0), nrow(pension.suc.cm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.ch)) {
  
  edad <- edad.suc.ch[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.ch[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.ch[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Caso para las mujeres
for (i in 1:nrow(matriz.suc.cm)) {
  
  edad <- edad.suc.cm[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.cm[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.cm[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.ch <- matriz.suc.ch * pension.suc.ch
matriz.suc.cm <- matriz.suc.cm * pension.suc.cm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.ch <- pmin(matriz.suc.ch, 3500000)
matriz.suc.cm <- pmin(matriz.suc.cm, 3500000)

## Sucesión hijo

# Inicializamos las matrices de beneficio con ceros
matriz.suc.hh <- matrix(as.numeric(0), nrow(pension.suc.hh), ncol(edades))
matriz.suc.hm <- matrix(as.numeric(0), nrow(pension.suc.hm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.hh)) {
  
  edad <- edad.suc.hh[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hh[i, 1:indice] <- 1  
    
  }
  
}

# Caso para mujeres
for (i in 1:nrow(matriz.suc.hm)) {
  
  edad <- edad.suc.hm[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hm[i, 1:indice] <- 1  
    
  }
  
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.hh <- matriz.suc.hh * pension.suc.hh
matriz.suc.hm <- matriz.suc.hm * pension.suc.hm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.hh <- pmin(matriz.suc.hh, 3500000)
matriz.suc.hm <- pmin(matriz.suc.hm, 3500000)

# Se juntan las matrices de sucesión por cónyuge e hijo en una sola
matriz.sucini.h <- rbind(matriz.suc.ch, matriz.suc.hh)
matriz.sucini.m <- rbind(matriz.suc.cm, matriz.suc.hm)

# Limpieza de variables temporales
rm(qx.conyuge, vect.aleatorio, estados.conyuge, indice.3, qx.hijo, estados.hijo,
   indice.4, edad, col, n, indice, qx.pensionado, estados.pensionado)

### Activo actuarial

# Se crea una lista con las matrices calculadas
matrices.pension <- list(matriz.vejez.h, matriz.vejez.m, matriz.inv.h, 
                         matriz.inv.m, matriz.suc.h, matriz.suc.m, 
                         matriz.vejini.h, matriz.vejini.m, matriz.invini.h, 
                         matriz.invini.m, matriz.sucini.h, matriz.sucini.m)

# Lista para matrices con los montos valor presente
matrices.vp <- list()

# Vector que tendrá el monto de las cotizaciones de los pensionados
cotizacion.pensiones <- rep(0, length(matrices.pension))

# Se itera sobre las matrices
for (i in 1:length(matrices.pension)) {
  
  # Se extienden las matrices de forma mensual, considerando el aguinaldo
  matrices.pension[[i]] <- t(apply(matrices.pension[[i]], 1, 
                                   function(fila) rep(fila, each = 13)))
  
  # Se obtiene el valor presente de cada matriz
  matrices.vp[[i]] <- matrices.pension[[i]] * matriz.vp[1:nrow(matrices.pension[[i]]), ]
  
  # Se determina la contribución de los pensionados
  mayores.2mill <- matrices.vp[[i]][matrices.pension[[i]] > 2000000]
  cotizacion.pensiones[i] <- sum(0.05 * mayores.2mill)
  
  # Se actualiza el monto de las pensiones correspondientes
  matrices.vp[[i]] <- matrices.vp[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
  matrices.pension[[i]] <- matrices.pension[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
}

# Se suman las cotizaciones de los pensionados de cada matriz
cotizacion.pensiones <- sum(cotizacion.pensiones)

# Se construye la matriz con los salarios totales para determinar la masa salarial
salarios.finales <- rbind(salario.estoc.h * cotizaciones.h, 
                          salario.estoc.m * cotizaciones.m)

# Se crea la matriz con los factores de descuento para determinar las cotizaciones de los trabajadores
matriz.descuento <- matrix(rep(s, times = nrow(salarios.finales)), 
                           nrow(salarios.finales), byrow = TRUE)

# Se calcula la masa salarial
masa.salarial <- sum(salarios.finales * matriz.descuento)

# Se calcula la contribución de los trabajadores
cotizacion.trab <- masa.salarial * 0.15

# Se calcula el activo actuarial
total.activo <- cotizacion.pensiones + cotizacion.trab + reserva.ini

rm(mayores.2mill)

### Flujos de balance

# Inicializamos los vectores para determinar los años críticos
reserva <- c(reserva.ini)
total.egresos <- c()
cotizaciones <- c()
rends <- c()

# Inicializamos el vector de años críticos
annos <- c(0, 0, 0)

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Cotizaciones de los trabajadores
  cotizaciones <- c(cotizaciones, (sum(salarios.finales[, i]) * 0.15))
  
  # Costo de las pensiones
  costo.pens <- Reduce("+", sapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto administrativo del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Total de egresos
  total.egresos <- c(total.egresos, costo.pens + sem)
  
  # Rendimientos
  rends <- c(rends, ifelse((reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real > 0, 
                           (reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real, 0))
  
  # Total de ingresos
  total.ingresos <- cotizaciones[i] + rends[i]
  
  # Guardamos la reserva final (reserva inicial del siguiente año)
  reserva <- c(reserva, (reserva[i] + total.ingresos - total.egresos[i] + sem))
}

# Eliminamos la última reserva final
reserva <- reserva[-length(reserva)]

# Determinamos los años críticos
idx <- which(total.egresos > cotizaciones)[1]
annos[1] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends))[1]
annos[2] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends + reserva))[1]
annos[3] <- idx + 2024

### Pasivo actuarial

# Se calcula el total de las pensiones
total.pensiones <- sum(sapply(matrices.vp, sum))

# Se calcula el monto del SEM
sem <- total.pensiones * (12/13) * 0.085

# Por último se calcula el pasivo actuarial
total.pasivo <- total.pensiones + sem

### Indicadores de solvencia

# Agregamos los indicadores a sus respectivas listas
razon.solvencia <- append(razon.solvencia, (total.activo / total.pasivo))
annos.crit <- append(annos.crit, list(annos))
balance <- append(balance, list(c(total.activo, total.pasivo)))
prima.media <- append(prima.media, ((total.pasivo - reserva.ini) / masa.salarial))

# Actualizamos los promedios para el ciclo while
prom.antes <- prom.despues
prom.despues <- mean(unlist(razon.solvencia))

### Beneficios devengados

# Beneficio devengado por vejez
ben.dev.vejez.h <-
  rowSums(matrices.vp[[1]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][filas.vejez.h] / cuotas.finales.h[filas.vejez.h])
ben.dev.vejez.m <-
  rowSums(matrices.vp[[2]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][filas.vejez.m] / cuotas.finales.m[filas.vejez.m])

# Beneficio devengado por invalidez
ben.dev.inv.h <-
  rowSums(matrices.vp[[3]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][filas.inv.h] / cuotas.finales.h[filas.inv.h])
ben.dev.inv.m <-
  rowSums(matrices.vp[[4]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][filas.inv.m] / cuotas.finales.m[filas.inv.m])

# Beneficio devengado por sucesión
ben.dev.suc.h <-
  rowSums(matrices.vp[[5]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][filas.muerte.h] / cuotas.finales.h[filas.muerte.h])
ben.dev.suc.m <-
  rowSums(matrices.vp[[6]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][filas.muerte.m] / cuotas.finales.m[filas.muerte.m])

# Se guardan los beneficios devengados en listas
beneficio.devengado.vejez <- append(beneficio.devengado.vejez, (sum(ben.dev.vejez.h) + sum(ben.dev.vejez.m)))
beneficio.devengado.invalidez <- append(beneficio.devengado.invalidez, (sum(ben.dev.inv.h) + sum(ben.dev.inv.m)))
beneficio.devengado.sucesion <- append(beneficio.devengado.sucesion, (sum(ben.dev.suc.h) + sum(ben.dev.suc.m)))

# Se guardan las matrices de pensión
pensiones <- append(pensiones, matrices.vp)
}

end.time <- Sys.time()

end.time - start.time
```

### Flujo escenario final

Una vez el modelo haya terminado de hacer las iteraciones, se procede a determinar la tasa de ingresos, la prima de reparto y la razón de fondo de contingencias, usando las variables de la última iteración.

```{r metricas_base}
# Inicializamos la reserva inicial en el 2025 y los vectores para las métricas
reserva <- reserva.ini
tasa.ingresos <- c()
prima.reparto <- c()
razon.fondo.cont <- c()

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Masa salarial
  ms <- sum(salarios.finales[, i])
  
  # Cotizaciones de los trabajadores
  cotizaciones <- ms * 0.15
  
  # Costo de las pensiones en cada año
  costo.pens <- Reduce("+", lapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Egresos totales
  total.egresos <- costo.pens + sem
  
  # Rendimientos
  rends <- ifelse((reserva + (cotizaciones - total.egresos) / 2) * interes.real > 0, 
                  (reserva + (cotizaciones - total.egresos) / 2) * interes.real, 0)
  
  # Ingresos totales
  total.ingresos <- cotizaciones + rends
  
  # Guardamos las métricas
  tasa.ingresos <- c(tasa.ingresos, ifelse(ms > 0, (total.ingresos / ms), NA))
  prima.reparto <- c(prima.reparto, ifelse(ms > 0, (total.egresos / ms), NA))
  razon.fondo.cont <- c(razon.fondo.cont, total.egresos / reserva)
  
  # Actualizamos la reserva inicial para el siguiente año
  reserva <- reserva + total.ingresos - total.egresos + sem
  
}
```

# Resultados base

## Salarios base

Se grafican los salarios ajustados por inflación.

```{r grafico_cotizantes}
ggplot(cotizantes.anualizado.VP.largo, aes(x = año, y = salario.ajustado)) +
  geom_line(stat = "summary", fun = mean, color = "steelblue", linewidth = 1) +
  labs(title = "Comportamiento de salarios ajustados por inflación (1995-2024)",
       x = "Año",
       y = "Salario ajustado (Valor presente)") +
  theme_minimal()
```

Se grafica la curva salarial sin ningún método de suavizado.

```{r grafico_curva_sin_suavizar}
ggplot(curva.general, aes(x = proyeccion.edad, y = salario.promedio)) +
  geom_line(color = "darkgreen", linewidth = 1.2) +
  labs(title = "Curva salarial general promedio",
       x = "Edad proyectada",
       y = "Salario promedio") +
  theme_minimal()
```

Se procede con el cálculo de la curva, pero de manera suavizada.

```{r curva_suavizada}
ggplot(curva.general, aes(x = proyeccion.edad, y = salario.promedio)) +
  geom_line(color = "darkgreen", alpha = 0.4) +  # línea original, más clara
  geom_smooth(method = "loess", color = "blue", linewidth = 1.2, se = FALSE) +
  labs(title = "Curva salarial general suavizada",
       x = "Edad proyectada",
       y = "Salario promedio") +
  theme_minimal()
```

Seguidamente se realiza un ejemplo donde se recibe el ID y la función imprime su curva salarial para su análisis.

```{r grafico_funcion_proyectar_persona}
graficar.proyeccion.id("097434")
```

## Razón de solvencia

Ahora se procede con las razones de solvencia. Inicialmente, se tiene el promedio de las razones de solvencia para este caso:

```{r rs_base}
(prom.rs <- mean(unlist(razon.solvencia)))
```

Se puede observar en un gráfico de densidad las distintas razones de solvencia.

```{r densidad_rs_base}
# Se crea un dataframe con los datos
data.rs <- data.frame(rs = unlist(razon.solvencia))

# Gráfico de las razones de solvencia
ggplot(data.rs, aes(x = rs)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.rs,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.rs,
    y = 50,
    label = "Media de las RS",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón de solvencia",
       y = "Densidad") +
  theme_minimal()
```

## Años críticos

En primer lugar, se obtendrá un promedio de los años críticos.

```{r annos_criticos_base}
# Se guarda como matriz
annos.crit.mat <- do.call(cbind, annos.crit)

# Se redondean los promedios
round(rowMeans(annos.crit.mat, na.rm = TRUE), 0)
```

Los anteriores están ordenados en primer, segundo y tercer año crítico respectivamente. Si los resultados son **NaN** significa que en ningún caso se llega a ese año crítico.

Para el caso en estudio, usualmente solo se llega al primer año crítico entre las iteraciones, por lo que se grafica ese caso.

```{r grafico_annos_criticos_base}
# Se guardan los primeros años críticos en un DataFrame
df.annos.crit <- data.frame(primer_momento = annos.crit.mat[1, ])

# Se grafican los primeros momentos correspondientes
ggplot(df.annos.crit, aes(x = primer_momento)) +
  geom_histogram(
    aes(y = after_stat(count / sum(count))),
    bins = 2,
    fill = "#A34022",
    color = "black"
  ) +
  labs(x = "Año",
       y = "Densidad")
theme_minimal()
```

## Prima media

Como se menciona en el reglamento, se procede con la prima media. Inicialmente se obtiene el promedio de estas:

```{r prima_media_base}
(prom.pm <- mean(unlist(prima.media)))
```

Un análisis más detallado se observa en el siguiente gráfico:

```{r grafico_prima_media_base}
# Se crea un dataframe con los datos
data.pm <- data.frame(pm = unlist(prima.media))

# Gráfico de las primas medias niveladas
ggplot(data.pm, aes(x = pm)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pm,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pm,
    y = 20,
    label = "Promedio de la prima media",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima media nivelada",
       y = "Densidad") +
  theme_minimal()
```

## Razón del fondo de contingencia

Se muestra la razón del fondo de contingencia de la última simulación, visualizada en un gráfico.

```{r grafico_rc_base}
# Se crea un dataframe con los datos
data.rc <- data.frame(rc = razon.fondo.cont)

# Gráfico de las razones del fondo de contingencia
ggplot(data.rc, aes(x = rc)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = mean(razon.fondo.cont),
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = mean(razon.fondo.cont),
    y = 80,
    label = "Media de la RC",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón del fondo de contingencia",
       y = "Densidad") +
  theme_minimal()
```

Una vez más, se aprecia que la reserva es muy grande en comparación con los egresos, lo cual produce resultados muy cercanos a 0 para esta métrica.

## Tasa de ingresos

La tasa de ingresos se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_base}
(prom.ti <- mean(tasa.ingresos, na.rm = TRUE))
```

Se observan los resultados en un gráfico.

```{r grafico_ti_base}
# Se crea un dataframe con los datos
data.ti <- data.frame(ti = tasa.ingresos)

# Gráfico de las razones del fondo de contingencia
ggplot(data.ti, aes(x = ti)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.ti,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.ti,
    y = 0.0025,
    label = "Media de la TI",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Tasa de ingresos",
       y = "Densidad") +
  theme_minimal()
```

Los primeros valores están entre 10 y 20, lo cual condiciona mucho el gráfico.

## Prima de reparto

La prima de reparto se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_base}
(prom.pr <- mean(prima.reparto, na.rm = TRUE))
```

Se observa el comportamiento en un gráfico.

```{r grafico_pr_base}
# Se crea un dataframe con los datos
data.pr <- data.frame(pr = prima.reparto)

# Gráfico de las razones del fondo de contingencia
ggplot(data.pr, aes(x = pr)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pr,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pr,
    y = 0.04,
    label = "Media de la prima de reparto",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima de reparto",
       y = "Densidad") +
  theme_minimal()
```

Se observa que muchos de los valores son menores a 1. Incluso, más del $75\%$ tienen menos de 2 dígitos.

## Balance

El promedio del activo y del pasivo a lo largo de las iteraciones se muestra a continuación.

```{r prom_balance_base}
# Se obtienen los valores en una matriz
matriz.balance <- do.call(cbind, balance)

# Promedio del activo y del pasivo respectivamente
rowMeans(matriz.balance)
```

Seguidamente, como pide el reglamento, se muestran las pensiones separadas por generaciones y por razón de salida.

```{r pasivo_separado_base}
# Se defina una matriz para obtener los montos
matriz.pasivo <- matrix(0, nrow = 6, ncol = (length(pensiones) / 12))

# Se obtienen los montos con un ciclo
for (i in 1:ncol(matriz.pasivo)) {
  # Se hace la suma de la iteración correspondiente
  suma.iter <- sapply(pensiones[(1+(i*12 - 12)):(12*i)], sum)
  
  # Se actualiza la matriz
  matriz.pasivo[, i] <-
    c((suma.iter[1] + suma.iter[2]),
      (suma.iter[3] + suma.iter[4]),
      (suma.iter[5] + suma.iter[6]),
      (suma.iter[7] + suma.iter[8]),
      (suma.iter[9] + suma.iter[10]),
      (suma.iter[11] + suma.iter[12]))
}

# Se pone la información en un dataframe
(
  df.pasivo <-
    data.frame(
      "Generación actual" = c(rowMeans(matriz.pasivo)[1:3], sum(rowMeans(matriz.pasivo)[1:3])),
      "Generación pensionada" = c(rowMeans(matriz.pasivo)[4:6], sum(rowMeans(matriz.pasivo)[4:6])),
      row.names = c("Vejez", "Invalidez", "Sucesion", "Total")
    )
)
```


Lo anterior se muestra en el siguiente gráfico.

```{r grafico_balance_base}
# Se pone la información en un dataframe
df.balance <- data.frame(valor = rowMeans(matriz.balance),
                         categoria = c("Activo", "Pasivo"))

# Gráfico del balance
ggplot(df.balance, aes(x = categoria, y = (valor / 1000000000))) +
  geom_bar(stat = "identity", fill = "#A34022") +
  labs(x = "Categoría del balance", y = "Valor (Miles de millones de colones)") +
  theme_minimal()
```


estos se muestran por separado, tal y como menciona el reglamento. Esto representa el promedio del valor presente de todos los activos y pasivos, respectivamente, de los 95 años proyectados.

## Beneficio devengado

En este caso, se observa el promedio del beneficio devengado en el siguiente gráfico

```{r promedio_beneficio_devengado}
# Se obtienen los valores en un dataframe
beneficio.devengado.final <-
  data.frame(
    ben.dev = c(mean(unlist(
      beneficio.devengado.vejez
    )), mean(unlist(
      beneficio.devengado.invalidez
    )), mean(unlist(
      beneficio.devengado.sucesion
    ))),
    categoria = c("Vejez", "Invalidez", "Sucesión")
  )

# Gráfico de beneficios devengados
ggplot(beneficio.devengado.final, aes(x = categoria, y = (ben.dev / 1000000000))) +
  geom_bar(stat = "identity", fill = "#A34022") +
    labs(x = "Categoría del devengo", y = "Valor (Miles de millones de colones)") +
  theme_minimal()
```

# Caso pesimista

Se continúa con el escenario pesimista, en este caso la inflación pasa a ser $5\%$ y la tasa de interés nominal baja un punto porcentual, quedando en $12.76\%$. Además, se aplica la misma reducción de $2\%$ para ser consistentes con la tasa de interés. Entonces, la tasa de interés real también cambiará:

```{r correcciones_pesimista}
# Tasa de interés real
interes.real <- ((0.1276-0.05) / 1.05) - 0.02
tasa.mensual <- (1 + interes.real)^(1/12) - 1

# Se crea el vector con las tasas de descuento
s <- 1 / ((1 + interes.real)^(0:(ncol(matriz.salarios) - 1)))

# Se obtienen las potencias de los valores presentes, incluyendo el aguinaldo
potencia.mensual <-
  rep(seq(1:(ncol(edades) * 12)), 
      times = ifelse((seq(1:(ncol(edades) * 12)) %% 12) == 0, 2, 1))

# Se obtiene el valor presente de cada periodo proyectado
matriz.vp <-
  matrix(((1 + tasa.mensual) ^ -((potencia.mensual - 1) / 12)), nrow(cotizantes), 
         length(potencia.mensual), byrow = TRUE)
```

Posteriormente, se tiene un modelo idéntico. Iniciamos con las listas.

```{r listas_iniciales_pesimista}
razon.solvencia <- list()
annos.crit <- list()
balance <- list()
prima.media <- list()
beneficio.devengado.vejez <- list()
beneficio.devengado.invalidez <- list()
beneficio.devengado.sucesion <- list()
pensiones <- list()

# Inicializamos los promedios para asegurarnos de que se harán mínimo 2 iteraciones
prom.antes <- 0
prom.despues <- 1
```

Con esto, se procede con el modelo en sí.

```{r estocastico_pesimista, echo = FALSE}
start.time <- Sys.time()

while(abs(prom.despues - prom.antes) >= 0.00001){
  
# Se crean dos matrices aleatorias usando distribución Uniforme(0, 1)
matriz.aleatoria.h <- matrix(runif(nrow(cotizantes.h) * ncol(mort.h)), 
                             nrow(cotizantes.h), ncol(mort.h))

matriz.aleatoria.m <- matrix(runif(nrow(cotizantes.m) * ncol(mort.m)), 
                             nrow(cotizantes.m), ncol(mort.m))

# Se continúa con las matrices de probabilidades de postergación
postergacion.simulada.h <- matriz.aleatoria.h < df.probabilidad.postergacion.h
postergacion.simulada.m <- matriz.aleatoria.m < df.probabilidad.postergacion.m

# Se corrigen las postergaciones incorrectas
postergacion.simulada.h <-
  t(apply(postergacion.simulada.h, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))
postergacion.simulada.m <-
  t(apply(postergacion.simulada.m, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))

# Matrices de números uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <-
  inv.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.h[[2]] <-
  mort.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.m[[1]] <-
  inv.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

lista.estados.m[[2]] <-
  mort.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Se hacen las correcciones, para que si entra en un estado se mantenga en él durante el tiempo
lista.estados.h[[1]] <-
  t(apply(lista.estados.h[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.h[[2]] <-
  t(apply(lista.estados.h[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[1]] <-
  t(apply(lista.estados.m[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[2]] <-
  t(apply(lista.estados.m[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))

# Se hace la matriz con los estados de cada persona, separando por sexo
estados.h <-
  ifelse(lista.estados.h[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.h[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.h == 1) * (cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 1,
           "Posterga",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 1)) == 1,
           "Activo",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 0)) == 1, "Inactivo", ifelse(
             edades.h > 64,
             "Retirado",
             ifelse(actividad.h == 1, "Activo", "Inactivo")
           ))
           ))
         ))
estados.m <-
  ifelse(lista.estados.m[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.m[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 404) * (edades.m == 63)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 356) * (edades.m == 64)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 179) * (edades.m > 64)
           ) == 1,
           "Posterga",
           ifelse(
             ((edades.m == 63) * (cotizaciones.acum.m > 404)) == 1,
             "Retirado",
             ifelse(((edades.m == 64) * (cotizaciones.acum.m > 356)
             ) == 1, "Retirado", ifelse(((edades.m > 64) * (cotizaciones.acum.m > 179)) == 1,
                                        "Retirado",
                                        ifelse(actividad.m == 1, "Activo", "Inactivo")
             ))
           ))
           ))
         ))

# Existe el caso en donde una persona retirada puede quedar inválida posteriormente, por lo que se corrije dicho escenario
estados.h <- t(apply(estados.h, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))

# Ahora, existe el caso en donde una persona retirada puede postergar, por lo que se corrije ese caso
estados.h <- t(apply(estados.h, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))

# Se obtiene el salario, separado por sexo
salario.estoc.h <-
  salarios.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
salario.estoc.m <-
  salarios.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Obtenemos las razones de salida, separado por sexo
salida.h <- apply(estados.h, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})
salida.m <- apply(estados.m, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})

# Cotizaciones reales
cotizaciones.h <- matriz.cot.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
cotizaciones.m <- matriz.cot.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Consideramos la cantidad final de cuotas, separada por sexo
cuotas.finales.h <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + rowSums(cotizaciones.h)
cuotas.finales.m <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + rowSums(cotizaciones.m)

# Vamos a obtener los salarios de cada persona, separado por sexo, de la parte estocástica
salarios.aux.h <- do.call(rbind, lapply(1:nrow(salario.estoc.h), function(i) {
  unlist(lapply(1:ncol(salario.estoc.h), function(j) {
    c(rep(salario.estoc.h[i, j], times = cotizaciones.h[i, j]),
      rep(0, 12 - cotizaciones.h[i, j]))
  }))
}))
salarios.aux.m <- do.call(rbind, lapply(1:nrow(salario.estoc.m), function(i) {
  unlist(lapply(1:ncol(salario.estoc.m), function(j) {
    c(rep(salario.estoc.m[i, j], times = cotizaciones.m[i, j]),
      rep(0, 12 - cotizaciones.m[i, j]))
  }))
}))

# Se juntan las matrices de salarios
matriz.salarios.h <- cbind(cotizantes.h, salarios.aux.h)
matriz.salarios.m <- cbind(cotizantes.m, salarios.aux.m)

# Obtenemos los mejores salarios ordenados (pueden incluir 0), separados por sexo
salarios.top.h <- t(apply(matriz.salarios.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))
salarios.top.m <- t(apply(matriz.salarios.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))

# Identificamos las diferencias entre los salarios
diferencias.h <- t(apply(salarios.top.h, 1, function(fila) {
  abs(diff(fila))
}))
diferencias.m <- t(apply(salarios.top.m, 1, function(fila) {
  abs(diff(fila))
}))

# Cantidad de columnas en las diferencias
columnas.diff <- ncol(diferencias.h) - 1

# Un salario será atípico si es mayor a 5 millones y tiene menos de 12 salarios en un rango de 500 000 colones con ese monto o tiene un salario con una diferencia de más de 500 000 colones al siguiente 
# Iniciamos viendo las diferencias
atipicos.h <- t(apply(diferencias.h, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))
atipicos.m <- t(apply(diferencias.m, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))

# Ahora consideramos los atípicos en la matriz de salarios, considerando aquellos que son de más de 5 millones
salarios.top.h <-
  salarios.top.h[, -ncol(salarios.top.h)] * !(atipicos.h * (salarios.top.h[, -ncol(salarios.top.h)] > 5000000))
salarios.top.m <-
  salarios.top.m[, -ncol(salarios.top.m)] * !(atipicos.m * (salarios.top.m[, -ncol(salarios.top.m)] > 5000000))

# Se sacan los 300 mejores salarios, ahora sin los salarios atípicos
salarios.top.h <- t(apply(salarios.top.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))
salarios.top.m <- t(apply(salarios.top.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))

# Beneficio por vejez, separado por sexo
beneficio.vejez.h <-
  (pmin(300, cuotas.finales.h[which(salida.h == "Retirado")]) / 300) * (rowSums(salarios.top.h[which(salida.h == "Retirado"),]) / rowSums(salarios.top.h[which(salida.h == "Retirado"),] > 9999))
# Hacer la corrección a estados M, en donde las mujeres pueden retirarse a partir de los 63 si cumplen los requisitos
beneficio.vejez.m <-
  (pmin(300, cuotas.finales.m[which(salida.m == "Retirado")]) / 300) * (rowSums(salarios.top.m[which(salida.m == "Retirado"),]) / rowSums(salarios.top.m[which(salida.m == "Retirado"),] > 9999))

# Filas de invalidez
filas.inv.h <- which(salida.h == "Invalido")
filas.inv.m <- which(salida.m == "Invalido")

# Para el beneficio por invalidez, separado por sexo, iniciamos obteniendo la casilla en donde quedaron inválidos
restantes.inv.h <-
  apply(estados.h[filas.inv.h, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })
restantes.inv.m <-
  apply(estados.m[filas.inv.m, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })

# Se compara si se han tenido las cuotas necesarias
cuotas.binario.h <- mapply(function(i, j) {
  requisitos.inv.h[i, j] <= cuotas.finales.h[i]
}, i = filas.inv.h, j = restantes.inv.h)
cuotas.binario.m <- mapply(function(i, j) {
  requisitos.inv.m[i, j] <= cuotas.finales.m[i]
}, i = filas.inv.m, j = restantes.inv.m)

# Se obtienen las edades para las cuales se invalidó la persona (se pone acá y se borra la anterior que estaba)
edad.final.h <- restantes.inv.h + edades.h[filas.inv.h, 1] - 1
edad.final.m <- restantes.inv.m + edades.m[filas.inv.m, 1] - 1

# En este punto, se ve si las personas pensionadas por invalidez tienen las cuotas necesarias según el inciso b del artículo 6
requisito.cuotas.h <-
  (ifelse(
    ((restantes.inv.h == 1) * (edad.final.h < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.h == 2) * (edad.final.h < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
      ifelse((edad.final.h < 48), rowSums(cotizaciones.h[filas.inv.h, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.h == 1) * (edad.final.h > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.h == 2) * (edad.final.h > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 325:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
                           ifelse(((restantes.inv.h == 3) * (edad.final.h > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:2]),
                                  ifelse(((restantes.inv.h == 4) * (edad.final.h > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:3]),
                                         ifelse((edad.final.h > 47) == 1, rowSums(cotizaciones.h[filas.inv.h, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23
requisito.cuotas.m <-
  (ifelse(
    ((restantes.inv.m == 1) * (edad.final.m < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.m == 2) * (edad.final.m < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
      ifelse((edad.final.m < 48), rowSums(cotizaciones.m[filas.inv.m, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.m == 1) * (edad.final.m > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.m == 2) * (edad.final.m > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 325:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
                           ifelse(((restantes.inv.m == 3) * (edad.final.m > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:2]),
                                  ifelse(((restantes.inv.m == 4) * (edad.final.m > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:3]),
                                         ifelse((edad.final.m > 47) == 1, rowSums(cotizaciones.m[filas.inv.m, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23

# Si una persona inválida tiene las cuotas necesarias para su edad y cotizó 12 veces en los últimos 24 meses, tiene derecho a recibir pensión
resultado.binario.h <- cuotas.binario.h * requisito.cuotas.h
resultado.binario.m <- cuotas.binario.m * requisito.cuotas.m

# Beneficios por invalidez
beneficio.invalidez.h <-
  ifelse(cuotas.finales.h[filas.inv.h] > 299,
         (rowSums(salarios.top.h[filas.inv.h, ]) / 300),
         ifelse(cuotas.finales.h[filas.inv.h] > 179, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), ifelse(((cuotas.finales.h[filas.inv.h] < 180) * (resultado.binario.h == 1)
         ) == 1, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), 0)))
beneficio.invalidez.m <-
  ifelse(cuotas.finales.m[filas.inv.m] > 299,
         (rowSums(salarios.top.m[filas.inv.m, ]) / 300),
         ifelse(cuotas.finales.m[filas.inv.m] > 179, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), ifelse(((cuotas.finales.m[filas.inv.m] < 180) * (resultado.binario.m == 1)
         ) == 1, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), 0)))

# Primero, los índices de las personas que mueren
filas.muerte.h <- which(salida.h == "Fallecido")
filas.muerte.m <- which(salida.m == "Fallecido")

# Se identifican las columnas en la que ocurre la muerte (el año)
col.fallecido.h <-
  apply(estados.h[filas.muerte.h,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

col.fallecido.m <-
  apply(estados.m[filas.muerte.m,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

# Edad de la persona al morir para cada sexo
edad.fallecido.h <-
  mapply(function(i, j)
    edades.h[i, j], i = filas.muerte.h, j = col.fallecido.h)

edad.fallecido.m <-
  mapply(function(i, j)
    edades.m[i, j], i = filas.muerte.m, j = col.fallecido.m)

# Se crean dos vectores donde se identifica si al momento de la muerte el afiliado tenía un hijo
hijos.h <- edad.fallecido.h >= 25 & (edad.fallecido.h - 25) < 25
hijos.m <- edad.fallecido.m >= 25 & (edad.fallecido.m - 25) < 25

# Se calcula la pensión sucesoria con base en la pensión por vejez que hubiera recibido (art. 27)
salarios.sucesion.h <- salarios.top.h[filas.muerte.h,]
salarios.sucesion.m <- salarios.top.m[filas.muerte.m,]

beneficio.base.h <- rowSums(salarios.sucesion.h) / rowSums(salarios.top.h[which(salida.h == "Fallecido"),] > 9999)
beneficio.base.m <- rowSums(salarios.sucesion.m) / rowSums(salarios.top.m[which(salida.m == "Fallecido"),] > 9999)

# Se calcula el porcentaje para pensión por viudez según edad del cónyuge por art. 27: 70% si cónyuge ≥ 60, 60% si 50–59, 50% si < 50
porcentaje.viudez.h <- ifelse(edad.fallecido.h >= 60,
                              0.70,
                              ifelse(edad.fallecido.h >= 50, 0.60, 0.50))

porcentaje.viudez.m <- ifelse(edad.fallecido.m >= 60,
                              0.70,
                              ifelse(edad.fallecido.m >= 50, 0.60, 0.50))

# Así como el porcentaje para pensión por orfandad (30% si el hijo califica) art. 27: 30% para hijos menores de 25 años
porcentaje.hijo.h <- ifelse(hijos.h, 0.30, 0)
porcentaje.hijo.m <- ifelse(hijos.m, 0.30, 0)

# Se calcula el beneficio por sucesión (sin validar aún si tiene derecho)
beneficio.conyuge.h <- beneficio.base.h * porcentaje.viudez.h
beneficio.conyuge.m <- beneficio.base.m * porcentaje.viudez.m

beneficio.hijo.h <- beneficio.base.h * porcentaje.hijo.h
beneficio.hijo.m <- beneficio.base.m * porcentaje.hijo.m

# Se verifica si tiene derecho al beneficio por sucesion (art. 18)

# Condición 1: tener al menos 180 cotizaciones totales
requisito.180.h <- cuotas.finales.h[filas.muerte.h] >= 180
requisito.180.m <- cuotas.finales.m[filas.muerte.m] >= 180

# Condición 2: haber cotizado al menos 12 veces en los últimos 24 meses antes de morir, si murió antes de los 24 meses simulados se usan los datos anteriores que están en la base

requisito.24meses.h <-
  ifelse(
    col.fallecido.h == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 337:360] > 10000),
    ifelse(
      col.fallecido.h == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 349:360] > 10000) + cotizaciones.h[filas.muerte.h, 1],
      rowSums(cotizaciones.h[filas.muerte.h, 1:2])
    )
  ) > 11

requisito.24meses.m <-
  ifelse(
    col.fallecido.m == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 337:360] > 10000),
    ifelse(
      col.fallecido.m == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 349:360] > 10000) + cotizaciones.m[filas.muerte.m, 1],
      rowSums(cotizaciones.m[filas.muerte.m, 1:2])
    )
  ) > 11

# Debe de cumplir ambos requisitos
tiene.derecho.sucesion.h <- requisito.180.h & requisito.24meses.h
tiene.derecho.sucesion.m <- requisito.180.m & requisito.24meses.m

# Se verifica si califica para el derecho o no. En caso de que no se asigna un beneficio = 0
beneficio.conyuge.h <-
  ifelse(tiene.derecho.sucesion.h, beneficio.conyuge.h, 0)
beneficio.hijo.h    <-
  ifelse(tiene.derecho.sucesion.h, beneficio.hijo.h, 0)

beneficio.conyuge.m <-
  ifelse(tiene.derecho.sucesion.m, beneficio.conyuge.m, 0)
beneficio.hijo.m    <-
  ifelse(tiene.derecho.sucesion.m, beneficio.hijo.m, 0)

# Las filas de personas que se retiraron
filas.vejez.h <- which(salida.h == "Retirado")
filas.vejez.m <- which(salida.m == "Retirado")

# Los salario promedio base (prom. de 300 mejores salarios)
salario.referencia.h <- beneficio.vejez.h
salario.referencia.m <- beneficio.vejez.m

# La cuantía básica según salario
cuantia.vejez.h <- cuantia.basica(salario.referencia.h)
cuantia.vejez.m <- cuantia.basica(salario.referencia.m)

# La bonificación por cotizaciones adicionales (exceso sobre 300)
meses.extra.h <- pmax(0, cuotas.finales.h[filas.vejez.h] - 300)
meses.extra.m <- pmax(0, cuotas.finales.m[filas.vejez.m] - 300)
bono.cuotas.h <- meses.extra.h * bono.cotizaciones
bono.cuotas.m <- meses.extra.m * bono.cotizaciones

# La bonificación por postergación (meses en estado "Posterga")
meses.post.h <- 12 * rowSums(postergacion.simulada.h[filas.vejez.h, ])
meses.post.m <- 12 * rowSums(postergacion.simulada.m[filas.vejez.m, ])
bono.post.h <- meses.post.h * bono.postergacion
bono.post.m <- meses.post.m * bono.postergacion

# La tasa de reemplazo final
tasa.vejez.h <- cuantia.vejez.h + bono.cuotas.h + bono.post.h
tasa.vejez.m <- cuantia.vejez.m + bono.cuotas.m + bono.post.m

# Pensión final por vejez
pension.vejez.h <- salario.referencia.h * pmin(tasa.vejez.h, tasa.maxima)
pension.vejez.m <- salario.referencia.m * pmin(tasa.vejez.m, tasa.maxima)

# El salario base
salario.referencia.inv.h <- beneficio.invalidez.h
salario.referencia.inv.m <- beneficio.invalidez.m

# La cuantía básica
cuantia.invalidez.h <- cuantia.basica(salario.referencia.inv.h)
cuantia.invalidez.m <- cuantia.basica(salario.referencia.inv.m)

# La bonificación por cuotas (más de 300)
meses.extra.inv.h <- pmax(0, cuotas.finales.h[filas.inv.h] - 300)
meses.extra.inv.m <- pmax(0, cuotas.finales.m[filas.inv.m] - 300)
bono.cuotas.inv.h <- meses.extra.inv.h * bono.cotizaciones
bono.cuotas.inv.m <- meses.extra.inv.m * bono.cotizaciones

# La tasa de reemplazo
tasa.invalidez.h <- cuantia.invalidez.h + bono.cuotas.inv.h
tasa.invalidez.m <- cuantia.invalidez.m + bono.cuotas.inv.m

# La pensión por invalidez
pension.invalidez.h <- salario.referencia.inv.h * pmin(tasa.invalidez.h, tasa.maxima)
pension.invalidez.m <- salario.referencia.inv.m * pmin(tasa.invalidez.m, tasa.maxima)

# La pensión por sucesión
pension.sucesion.h <- beneficio.conyuge.h + beneficio.hijo.h
pension.sucesion.m <- beneficio.conyuge.m + beneficio.hijo.m

### Pensiones por vejez

# Filtramos la matriz de estados a partir de las personas con beneficio por vejez
matriz.vejez.h <- estados.h[filas.vejez.h, ]
matriz.vejez.m <- estados.m[filas.vejez.m, ]

# Filtramos la matriz de edades a partir de las personas con beneficio por vejez
edades.vejez.h <- edades.h[filas.vejez.h, ]
edades.vejez.m <- edades.m[filas.vejez.m, ]

# Calculamos en qué año ocurre el retiro por vejez para cada individuo
restantes.ret.h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Retirado")[1]
})

restantes.ret.m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Retirado")[1]
})

# Calculamos en qué año ocurre el fallecimiento para cada individuo
indices.2h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices de beneficio con ceros
matriz.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))
matriz.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Construimos la matriz de beneficios para hombres
for (i in 1:nrow(matriz.vejez.h)) {
  
  indice <- indices.2h[i]  # Año en que fallece la i-ésima persona
  
  # Se asigna 1 desde el retiro hasta justo antes del fallecimiento
  matriz.vejez.h[i, restantes.ret.h[i]:(indice - 1)] <- 1 

  edad <- edades.vejez.h[i, indice]  # Edad al fallecer

  # Se calcula la cantidad de años para simular la sobrevivencia del cónyuge
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Se extraen las probabilidades de muerte del cónyuge (mujer) por edad y año
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]

  # Se simula la vida del cónyuge comparando las probabilidades con números aleatorios
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio  # TRUE si muere

  # Se determina cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Se asigna 0.7 al beneficio durante los años en que el cónyuge está vivo
  matriz.vejez.h[i, indice:(indice + indice.3)] <- 0.7
}

# Lo mismo para mujeres
for (i in 1:nrow(matriz.vejez.m)) {
  
  indice <- indices.2m[i]
  matriz.vejez.m[i, restantes.ret.m[i]:(indice - 1)] <- 1
  
  edad <- edades.vejez.m[i, indice]
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejez.m[i, indice:(indice + indice.3)] <- 0.7
}

# Se construyen las matrices con los montos de pensión
monto.vejez.h <- matrix(pension.vejez.h, nrow(matriz.vejez.h), ncol(matriz.vejez.h))
monto.vejez.m <- matrix(pension.vejez.m, nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Multiplicamos las matrices de beneficios (0, 1, 0.7) por el monto de pensión
matriz.vejez.h <- matriz.vejez.h * monto.vejez.h
matriz.vejez.m <- matriz.vejez.m * monto.vejez.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejez.h <- pmin(matriz.vejez.h, 3500000)
matriz.vejez.m <- pmin(matriz.vejez.m, 3500000)

rm(edades.vejez.h, edades.vejez.m, monto.vejez.h, monto.vejez.m)

### Pensiones por invalidez

# Extraemos las filas correspondientes a inválidos
matriz.inv.h <- estados.h[filas.inv.h, ]
matriz.inv.m <- estados.m[filas.inv.m, ]

# Extraemos las edades correspondientes a inválidos
edades.inv.h <- edades.h[filas.inv.h, ]
edades.inv.m <- edades.m[filas.inv.m, ]

# Obtenemos el primer periodo donde se observa el estado "Fallecido"
indices.2h <- apply(matriz.inv.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.inv.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices con ceros para hombres y mujeres inválidos
matriz.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
matriz.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))

# Llenamos la matriz de hombres
for (i in 1:nrow(matriz.inv.h)) {
  
  indice <- indices.2h[i]  # Primer año de fallecimiento
  matriz.inv.h[i, restantes.inv.h[i]:(indice - 1)] <- 1  # Periodo de invalidez antes de fallecer
  
  edad <- edades.inv.h[i, indice]  # Edad al fallecer
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Obtenemos el qx del cónyuge (mujer)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  # Simulamos la vida del cónyuge con aleatoriedad
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1  # Tiempo que sobrevive el cónyuge

  # Asignamos el porcentaje de pensión según la edad
  if(edad >= 60){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)  # Máximo hasta que el hijo cumpla 25

    matriz.inv.h[i, indice:(indice + indice.4)] <- 
      matriz.inv.h[i, indice:(indice + indice.4)] + 0.3  # Agregamos el beneficio por hijo

  } else {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para las mujeres
for (i in 1:nrow(matriz.inv.m)) {
  
  indice <- indices.2m[i]
  matriz.inv.m[i, restantes.inv.m[i]:(indice - 1)] <- 1
  
  edad <- edades.inv.m[i, indice]
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)

  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Beneficio por hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.inv.m[i, indice:(indice + indice.4)] <- 
      matriz.inv.m[i, indice:(indice + indice.4)] + 0.3
    
  } else {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indices.2m[i] + 50 - edad):(indices.2m[i] + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Creamos las matrices de montos
monto.inv.h <- matrix(pension.invalidez.h, nrow(matriz.inv.h), ncol(matriz.inv.h))
monto.inv.m <- matrix(pension.invalidez.m, nrow(matriz.inv.m), ncol(matriz.inv.m))

# Aplicamos el monto a cada proporción de pensión
matriz.inv.h <- matriz.inv.h * monto.inv.h
matriz.inv.m <- matriz.inv.m * monto.inv.m

# Aplicamos el tope de pensión máximo de 3.5 millones
matriz.inv.h <- pmin(matriz.inv.h, 3500000)
matriz.inv.m <- pmin(matriz.inv.m, 3500000)

rm(edades.inv.h, edades.inv.m, monto.inv.h, monto.inv.m)

### Pensiones por sucesión

# Se inicializan matrices de ceros para guardar la sucesión de los hombres y mujeres
matriz.suc.h <- matrix(as.numeric(0), nrow(estados.h[filas.muerte.h, ]),
                       ncol(estados.h[filas.muerte.h, ]))

matriz.suc.m <- matrix(as.numeric(0), nrow(estados.m[filas.muerte.m, ]),
                       ncol(estados.m[filas.muerte.m, ]))

# Se calcula la matriz de sucesión de los hombres fallecidos
for(i in 1:nrow(matriz.suc.h)){
  
  edad <- edad.fallecido.h[i]  # Edad del hombre fallecido
  col <- col.fallecido.h[i]    # Columna donde inicia la sucesión

  # Se determina la cantidad de años a simular
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - col + 1)

  # Se obtienen las probabilidades de fallecimiento del cónyuge
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), col:(col + n - 1))]

  # Se simulan eventos aleatorios de fallecimiento del cónyuge
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio

  # Se identifica cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Asignación de porcentaje según edad al fallecer y condiciones
  if(edad >= 60){
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.h[i]){  # Si hay hijos
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.h[i, col:(col + indice.4)] <- 
      matriz.suc.h[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para mujeres
for(i in 1:nrow(matriz.suc.m)){
  
  edad <- edad.fallecido.m[i]
  col <- col.fallecido.m[i]

  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - col + 1)
  
  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), col:(col + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.m[i]){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  
    # Mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.m[i, col:(col + indice.4)] <- 
      matriz.suc.m[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se asigna el monto del beneficio base solo a los que tienen derecho a sucesión
sucesion.aux.h <- ifelse(tiene.derecho.sucesion.h, beneficio.base.h, 0)
sucesion.aux.m <- ifelse(tiene.derecho.sucesion.m, beneficio.base.m, 0)

# Se crean matrices con los montos por sucesión
monto.suc.h <- matrix(sucesion.aux.h, nrow(matriz.suc.h), ncol(matriz.suc.h))
monto.suc.m <- matrix(sucesion.aux.m, nrow(matriz.suc.m), ncol(matriz.suc.m))

# Se multiplica la proporción asignada por el monto base
matriz.suc.h <- matriz.suc.h * monto.suc.h
matriz.suc.m <- matriz.suc.m * monto.suc.m

# Se limita el monto máximo de la pensión por sucesión a 3.5 millones
matriz.suc.h <- pmin(matriz.suc.h, 3500000)
matriz.suc.m <- pmin(matriz.suc.m, 3500000)

rm(monto.suc.h, monto.suc.m, sucesion.aux.h, sucesion.aux.m)

### Pensionados iniciales

## Vejez

# Inicializamos las matrices de beneficio con ceros
matriz.vejini.h <- matrix(as.numeric(0), nrow(pensini.vej.h), ncol(edades))
matriz.vejini.m <- matrix(as.numeric(0), nrow(pensini.vej.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.vejini.h)) {
  
  edad <- edadini.vej.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.h[i, indice:(indice + indice.3)] <- 0.7
}

# Caso para mujeres
for (i in 1:nrow(matriz.vejini.m)) {
  
  edad <- edadini.vej.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.m[i, indice:(indice + indice.3)] <- 0.7
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.vejini.h <- matriz.vejini.h * pensini.vej.h
matriz.vejini.m <- matriz.vejini.m * pensini.vej.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejini.h <- pmin(matriz.vejini.h, 3500000)
matriz.vejini.m <- pmin(matriz.vejini.m, 3500000)

## Invalidez

# Inicializamos las matrices de beneficio con ceros
matriz.invini.h <- matrix(as.numeric(0), nrow(pensini.inv.h), ncol(edades))
matriz.invini.m <- matrix(as.numeric(0), nrow(pensini.inv.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.invini.h)) {
  
  edad <- edadini.inv.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.h[i, indice:(indice + indice.4)] <- 
      matriz.invini.h[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Caso para mujeres
for (i in 1:nrow(matriz.invini.m)) {
  
  edad <- edadini.inv.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.m[i, indice:(indice + indice.4)] <- 
      matriz.invini.m[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.invini.h <- matriz.invini.h * pensini.inv.h
matriz.invini.m <- matriz.invini.m * pensini.inv.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.invini.h <- pmin(matriz.invini.h, 3500000)
matriz.invini.m <- pmin(matriz.invini.m, 3500000)

## Sucesión cónyuge

# Inicializamos las matrices de beneficio con ceros
matriz.suc.ch <- matrix(as.numeric(0), nrow(pension.suc.ch), ncol(edades))
matriz.suc.cm <- matrix(as.numeric(0), nrow(pension.suc.cm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.ch)) {
  
  edad <- edad.suc.ch[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.ch[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.ch[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Caso para las mujeres
for (i in 1:nrow(matriz.suc.cm)) {
  
  edad <- edad.suc.cm[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.cm[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.cm[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.ch <- matriz.suc.ch * pension.suc.ch
matriz.suc.cm <- matriz.suc.cm * pension.suc.cm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.ch <- pmin(matriz.suc.ch, 3500000)
matriz.suc.cm <- pmin(matriz.suc.cm, 3500000)

## Sucesión hijo

# Inicializamos las matrices de beneficio con ceros
matriz.suc.hh <- matrix(as.numeric(0), nrow(pension.suc.hh), ncol(edades))
matriz.suc.hm <- matrix(as.numeric(0), nrow(pension.suc.hm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.hh)) {
  
  edad <- edad.suc.hh[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hh[i, 1:indice] <- 1  
    
  }
  
}

# Caso para mujeres
for (i in 1:nrow(matriz.suc.hm)) {
  
  edad <- edad.suc.hm[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hm[i, 1:indice] <- 1  
    
  }
  
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.hh <- matriz.suc.hh * pension.suc.hh
matriz.suc.hm <- matriz.suc.hm * pension.suc.hm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.hh <- pmin(matriz.suc.hh, 3500000)
matriz.suc.hm <- pmin(matriz.suc.hm, 3500000)

# Se juntan las matrices de sucesión por cónyuge e hijo en una sola
matriz.sucini.h <- rbind(matriz.suc.ch, matriz.suc.hh)
matriz.sucini.m <- rbind(matriz.suc.cm, matriz.suc.hm)

# Limpieza de variables temporales
rm(qx.conyuge, vect.aleatorio, estados.conyuge, indice.3, qx.hijo, estados.hijo,
   indice.4, edad, col, n, indice, qx.pensionado, estados.pensionado)

### Activo actuarial

# Se crea una lista con las matrices calculadas
matrices.pension <- list(matriz.vejez.h, matriz.vejez.m, matriz.inv.h, 
                         matriz.inv.m, matriz.suc.h, matriz.suc.m, 
                         matriz.vejini.h, matriz.vejini.m, matriz.invini.h, 
                         matriz.invini.m, matriz.sucini.h, matriz.sucini.m)

# Lista para matrices con los montos valor presente
matrices.vp <- list()

# Vector que tendrá el monto de las cotizaciones de los pensionados
cotizacion.pensiones <- rep(0, length(matrices.pension))

# Se itera sobre las matrices
for (i in 1:length(matrices.pension)) {
  
  # Se extienden las matrices de forma mensual, considerando el aguinaldo
  matrices.pension[[i]] <- t(apply(matrices.pension[[i]], 1, 
                                   function(fila) rep(fila, each = 13)))
  
  # Se obtiene el valor presente de cada matriz
  matrices.vp[[i]] <- matrices.pension[[i]] * matriz.vp[1:nrow(matrices.pension[[i]]), ]
  
  # Se determina la contribución de los pensionados
  mayores.2mill <- matrices.vp[[i]][matrices.pension[[i]] > 2000000]
  cotizacion.pensiones[i] <- sum(0.05 * mayores.2mill)
  
  # Se actualiza el monto de las pensiones correspondientes
  matrices.vp[[i]] <- matrices.vp[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
  matrices.pension[[i]] <- matrices.pension[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
}

# Se suman las cotizaciones de los pensionados de cada matriz
cotizacion.pensiones <- sum(cotizacion.pensiones)

# Se construye la matriz con los salarios totales para determinar la masa salarial
salarios.finales <- rbind(salario.estoc.h * cotizaciones.h, 
                          salario.estoc.m * cotizaciones.m)

# Se crea la matriz con los factores de descuento para determinar las cotizaciones de los trabajadores
matriz.descuento <- matrix(rep(s, times = nrow(salarios.finales)), 
                           nrow(salarios.finales), byrow = TRUE)

# Se calcula la masa salarial
masa.salarial <- sum(salarios.finales * matriz.descuento)

# Se calcula la contribución de los trabajadores
cotizacion.trab <- masa.salarial * 0.15

# Se calcula el activo actuarial
total.activo <- cotizacion.pensiones + cotizacion.trab + reserva.ini

rm(mayores.2mill)

### Flujos de balance

# Inicializamos los vectores para determinar los años críticos
reserva <- c(reserva.ini)
total.egresos <- c()
cotizaciones <- c()
rends <- c()

# Inicializamos el vector de años críticos
annos <- c(0, 0, 0)

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Cotizaciones de los trabajadores
  cotizaciones <- c(cotizaciones, (sum(salarios.finales[, i]) * 0.15))
  
  # Costo de las pensiones
  costo.pens <- Reduce("+", sapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto administrativo del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Total de egresos
  total.egresos <- c(total.egresos, costo.pens + sem)
  
  # Rendimientos
  rends <- c(rends, ifelse((reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real > 0, 
                           (reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real, 0))
  
  # Total de ingresos
  total.ingresos <- cotizaciones[i] + rends[i]
  
  # Guardamos la reserva final (reserva inicial del siguiente año)
  reserva <- c(reserva, (reserva[i] + total.ingresos - total.egresos[i] + sem))
}

# Eliminamos la última reserva final
reserva <- reserva[-length(reserva)]

# Determinamos los años críticos
idx <- which(total.egresos > cotizaciones)[1]
annos[1] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends))[1]
annos[2] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends + reserva))[1]
annos[3] <- idx + 2024

### Pasivo actuarial

# Se calcula el total de las pensiones
total.pensiones <- sum(sapply(matrices.vp, sum))

# Se calcula el monto del SEM
sem <- total.pensiones * (12/13) * 0.085

# Por último se calcula el pasivo actuarial
total.pasivo <- total.pensiones + sem

### Indicadores de solvencia

# Agregamos los indicadores a sus respectivas listas
razon.solvencia <- append(razon.solvencia, (total.activo / total.pasivo))
annos.crit <- append(annos.crit, list(annos))
balance <- append(balance, list(c(total.activo, total.pasivo)))
prima.media <- append(prima.media, ((total.pasivo - reserva.ini) / masa.salarial))

# Actualizamos los promedios para el ciclo while
prom.antes <- prom.despues
prom.despues <- mean(unlist(razon.solvencia))

# Se guardan las matrices de pensión
pensiones <- append(pensiones, matrices.vp)
}

end.time <- Sys.time()

end.time - start.time
```

Una vez el modelo haya terminado de hacer las iteraciones, se procede a determinar la tasa de ingresos, la prima de reparto y la razón de fondo de contingencias, usando las variables de la última iteración.

```{r metricas_pesimista}
# Inicializamos la reserva inicial en el 2025 y los vectores para las métricas
reserva <- reserva.ini
tasa.ingresos <- c()
prima.reparto <- c()
razon.fondo.cont <- c()

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Masa salarial
  ms <- sum(salarios.finales[, i])
  
  # Cotizaciones de los trabajadores
  cotizaciones <- ms * 0.15
  
  # Costo de las pensiones en cada año
  costo.pens <- Reduce("+", lapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Egresos totales
  total.egresos <- costo.pens + sem
  
  # Rendimientos
  rends <- ifelse((reserva + (cotizaciones - total.egresos) / 2) * interes.real > 0, 
                  (reserva + (cotizaciones - total.egresos) / 2) * interes.real, 0)
  
  # Ingresos totales
  total.ingresos <- cotizaciones + rends
  
  # Guardamos las métricas
  tasa.ingresos <- c(tasa.ingresos, ifelse(ms > 0, (total.ingresos / ms), NA))
  prima.reparto <- c(prima.reparto, ifelse(ms > 0, (total.egresos / ms), NA))
  razon.fondo.cont <- c(razon.fondo.cont, total.egresos / reserva)
  
  # Actualizamos la reserva inicial para el siguiente año
  reserva <- reserva + total.ingresos - total.egresos + sem
  
}
```

## Resultados caso pesimista

## Razón de solvencia

Ahora se procede con las razones de solvencia. Inicialmente, se tiene el promedio de las razones de solvencia para este caso:

```{r rs_pesimista}
(prom.rs <- mean(unlist(razon.solvencia)))
```

Se puede observar en un gráfico de densidad las distintas razones de solvencia.

```{r densidad_rs_pesimista}
# Se crea un dataframe con los datos
data.rs <- data.frame(rs = unlist(razon.solvencia))

# Gráfico de las razones de solvencia
ggplot(data.rs, aes(x = rs)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.rs,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.rs,
    y = 50,
    label = "Media de las RS",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón de solvencia",
       y = "Densidad") +
  theme_minimal()
```

## Años críticos

En primer lugar, se obtendrá un promedio de los años críticos.

```{r annos_criticos_pesimista}
# Se guarda como matriz
annos.crit.mat <- do.call(cbind, annos.crit)

# Se redondean los promedios
round(rowMeans(annos.crit.mat, na.rm = TRUE), 0)
```

Los anteriores están ordenados en primer, segundo y tercer año crítico respectivamente. Si los resultados son **NaN** significa que en ningún caso se llega a ese año crítico.

Para el caso en estudio, usualmente solo se llega al primer año crítico entre las iteraciones, por lo que se grafica ese caso.

```{r grafico_annos_criticos_pesimista}
# Se guardan los primeros años críticos en un DataFrame
df.annos.crit <- data.frame(primer_momento = annos.crit.mat[1, ])

# Se grafican los primeros momentos correspondientes
ggplot(df.annos.crit, aes(x = primer_momento)) +
  geom_histogram(
    aes(y = after_stat(count / sum(count))),
    bins = 2,
    fill = "#A34022",
    color = "black"
  ) +
  labs(x = "Año",
       y = "Densidad")
theme_minimal()
```

## Prima media

Como se menciona en el reglamento, se procede con la prima media. Inicialmente se obtiene el promedio de estas:

```{r prima_media_pesimista}
(prom.pm <- mean(unlist(prima.media)))
```

Un análisis más detallado se observa en el siguiente gráfico:

```{r grafico_prima_media_pesimista}
# Se crea un dataframe con los datos
data.pm <- data.frame(pm = unlist(prima.media))

# Gráfico de las primas medias niveladas
ggplot(data.pm, aes(x = pm)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pm,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pm,
    y = 20,
    label = "Promedio de la prima media",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima media nivelada",
       y = "Densidad") +
  theme_minimal()
```

## Razón del fondo de contingencia

Se muestra la razón del fondo de contingencia de la última simulación, visualizada en un gráfico.

```{r grafico_rc_pesimista}
# Se crea un dataframe con los datos
data.rc <- data.frame(rc = razon.fondo.cont)

# Gráfico de las razones del fondo de contingencia
ggplot(data.rc, aes(x = rc)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = mean(razon.fondo.cont),
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = mean(razon.fondo.cont),
    y = 50,
    label = "Media de la RC",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón del fondo de contingencia",
       y = "Densidad") +
  theme_minimal()
```

Una vez más, se aprecia que la reserva es muy grande en comparación con los egresos, lo cual produce resultados muy cercanos a 0 para esta métrica.

## Tasa de ingresos

La tasa de ingresos se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_pesimista}
(prom.ti <- mean(tasa.ingresos, na.rm = TRUE))
```

Se observan los resultados en un gráfico.

```{r grafico_ti_pesimista}
# Se crea un dataframe con los datos
data.ti <- data.frame(ti = tasa.ingresos)

# Gráfico de las razones del fondo de contingencia
ggplot(data.ti, aes(x = ti)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.ti,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.ti,
    y = 0.01,
    label = "Media de la TI",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Tasa de ingresos",
       y = "Densidad") +
  theme_minimal()
```

Los primeros valores están entre 10 y 20, lo cual condiciona mucho el gráfico.

## Prima de reparto

La prima de reparto se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_pesimista}
(prom.pr <- mean(prima.reparto, na.rm = TRUE))
```

Se observa el comportamiento en un gráfico.

```{r grafico_pr_pesimista}
# Se crea un dataframe con los datos
data.pr <- data.frame(pr = prima.reparto)

# Gráfico de las razones del fondo de contingencia
ggplot(data.pr, aes(x = pr)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pr,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pr,
    y = 0.04,
    label = "Media de la prima de reparto",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima de reparto",
       y = "Densidad") +
  theme_minimal()
```

Se observa que muchos de los valores son menores a 1. Incluso, más del $75\%$ tienen menos de 2 dígitos.

## Balance

El promedio del activo y del pasivo a lo largo de las iteraciones se muestra a continuación.

```{r prom_balance_pesimista}
# Se obtienen los valores en una matriz
matriz.balance <- do.call(cbind, balance)

# Promedio del activo y del pasivo respectivamente
rowMeans(matriz.balance)
```

Seguidamente, como pide el reglamento, se muestran las pensiones separadas por generaciones y por razón de salida.

```{r pasivo_separado_pesimista}
# Se defina una matriz para obtener los montos
matriz.pasivo <- matrix(0, nrow = 6, ncol = (length(pensiones) / 12))

# Se obtienen los montos con un ciclo
for (i in 1:ncol(matriz.pasivo)) {
  # Se hace la suma de la iteración correspondiente
  suma.iter <- sapply(pensiones[(1+(i*12 - 12)):(12*i)], sum)
  
  # Se actualiza la matriz
  matriz.pasivo[, i] <-
    c((suma.iter[1] + suma.iter[2]),
      (suma.iter[3] + suma.iter[4]),
      (suma.iter[5] + suma.iter[6]),
      (suma.iter[7] + suma.iter[8]),
      (suma.iter[9] + suma.iter[10]),
      (suma.iter[11] + suma.iter[12]))
}

# Se pone la información en un dataframe
(
  df.pasivo <-
    data.frame(
      "Generación actual" = c(rowMeans(matriz.pasivo)[1:3], sum(rowMeans(matriz.pasivo)[1:3])),
      "Generación pensionada" = c(rowMeans(matriz.pasivo)[4:6], sum(rowMeans(matriz.pasivo)[4:6])),
      row.names = c("Vejez", "Invalidez", "Sucesion", "Total")
    )
)
```


Lo anterior se muestra en el siguiente gráfico.

```{r grafico_balance_pesimista}
# Se pone la información en un dataframe
df.balance <- data.frame(valor = rowMeans(matriz.balance),
                         categoria = c("Activo", "Pasivo"))

# Gráfico del balance
ggplot(df.balance, aes(x = categoria, y = (valor / 1000000000))) +
  geom_bar(stat = "identity", fill = "#A34022") +
  labs(x = "Categoría del balance", y = "Valor (Miles de millones de colones)") +
  theme_minimal()
```


estos se muestran por separado, tal y como menciona el reglamento. Esto representa el promedio del valor presente de todos los activos y pasivos, respectivamente, de los 95 años proyectados.

# Caso optimista

Se continúa con el escenario pesimista, en este caso la inflación pasa a ser $3\%$ y la tasa de interés nominal sube un punto porcentual, quedando en $14.76\%$. Además, se aplica la misma reducción de $2\%$ para ser consistentes con la tasa de interés. Entonces, la tasa de interés real también cambiará:

```{r correcciones_optimista}
# Tasa de interés real
interes.real <- ((0.1476-0.03) / 1.03) - 0.02
tasa.mensual <- (1 + interes.real)^(1/12) - 1

# Se crea el vector con las tasas de descuento
s <- 1 / ((1 + interes.real)^(0:(ncol(matriz.salarios) - 1)))

# Se obtienen las potencias de los valores presentes, incluyendo el aguinaldo
potencia.mensual <-
  rep(seq(1:(ncol(edades) * 12)), 
      times = ifelse((seq(1:(ncol(edades) * 12)) %% 12) == 0, 2, 1))

# Se obtiene el valor presente de cada periodo proyectado
matriz.vp <-
  matrix(((1 + tasa.mensual) ^ -((potencia.mensual - 1) / 12)), nrow(cotizantes), 
         length(potencia.mensual), byrow = TRUE)
```

Posteriormente, se tiene un modelo idéntico. Iniciamos con las listas.

```{r listas_iniciales_optimista}
razon.solvencia <- list()
annos.crit <- list()
balance <- list()
prima.media <- list()
beneficio.devengado.vejez <- list()
beneficio.devengado.invalidez <- list()
beneficio.devengado.sucesion <- list()
pensiones <- list()

# Inicializamos los promedios para asegurarnos de que se harán mínimo 2 iteraciones
prom.antes <- 0
prom.despues <- 1
```

Con esto, se procede con el modelo en sí.

```{r estocastico_optimista, echo = FALSE}
start.time <- Sys.time()

while(abs(prom.despues - prom.antes) >= 0.00001){
  
# Se crean dos matrices aleatorias usando distribución Uniforme(0, 1)
matriz.aleatoria.h <- matrix(runif(nrow(cotizantes.h) * ncol(mort.h)), 
                             nrow(cotizantes.h), ncol(mort.h))

matriz.aleatoria.m <- matrix(runif(nrow(cotizantes.m) * ncol(mort.m)), 
                             nrow(cotizantes.m), ncol(mort.m))

# Se continúa con las matrices de probabilidades de postergación
postergacion.simulada.h <- matriz.aleatoria.h < df.probabilidad.postergacion.h
postergacion.simulada.m <- matriz.aleatoria.m < df.probabilidad.postergacion.m

# Se corrigen las postergaciones incorrectas
postergacion.simulada.h <-
  t(apply(postergacion.simulada.h, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))
postergacion.simulada.m <-
  t(apply(postergacion.simulada.m, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))

# Matrices de números uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <-
  inv.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.h[[2]] <-
  mort.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.m[[1]] <-
  inv.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

lista.estados.m[[2]] <-
  mort.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Se hacen las correcciones, para que si entra en un estado se mantenga en él durante el tiempo
lista.estados.h[[1]] <-
  t(apply(lista.estados.h[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.h[[2]] <-
  t(apply(lista.estados.h[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[1]] <-
  t(apply(lista.estados.m[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[2]] <-
  t(apply(lista.estados.m[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))

# Se hace la matriz con los estados de cada persona, separando por sexo
estados.h <-
  ifelse(lista.estados.h[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.h[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.h == 1) * (cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 1,
           "Posterga",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 1)) == 1,
           "Activo",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 0)) == 1, "Inactivo", ifelse(
             edades.h > 64,
             "Retirado",
             ifelse(actividad.h == 1, "Activo", "Inactivo")
           ))
           ))
         ))
estados.m <-
  ifelse(lista.estados.m[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.m[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 404) * (edades.m == 63)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 356) * (edades.m == 64)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 179) * (edades.m > 64)
           ) == 1,
           "Posterga",
           ifelse(
             ((edades.m == 63) * (cotizaciones.acum.m > 404)) == 1,
             "Retirado",
             ifelse(((edades.m == 64) * (cotizaciones.acum.m > 356)
             ) == 1, "Retirado", ifelse(((edades.m > 64) * (cotizaciones.acum.m > 179)) == 1,
                                        "Retirado",
                                        ifelse(actividad.m == 1, "Activo", "Inactivo")
             ))
           ))
           ))
         ))

# Existe el caso en donde una persona retirada puede quedar inválida posteriormente, por lo que se corrije dicho escenario
estados.h <- t(apply(estados.h, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))

# Ahora, existe el caso en donde una persona retirada puede postergar, por lo que se corrije ese caso
estados.h <- t(apply(estados.h, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))

# Se obtiene el salario, separado por sexo
salario.estoc.h <-
  salarios.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
salario.estoc.m <-
  salarios.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Obtenemos las razones de salida, separado por sexo
salida.h <- apply(estados.h, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})
salida.m <- apply(estados.m, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})

# Cotizaciones reales
cotizaciones.h <- matriz.cot.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
cotizaciones.m <- matriz.cot.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Consideramos la cantidad final de cuotas, separada por sexo
cuotas.finales.h <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + rowSums(cotizaciones.h)
cuotas.finales.m <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + rowSums(cotizaciones.m)

# Vamos a obtener los salarios de cada persona, separado por sexo, de la parte estocástica
salarios.aux.h <- do.call(rbind, lapply(1:nrow(salario.estoc.h), function(i) {
  unlist(lapply(1:ncol(salario.estoc.h), function(j) {
    c(rep(salario.estoc.h[i, j], times = cotizaciones.h[i, j]),
      rep(0, 12 - cotizaciones.h[i, j]))
  }))
}))
salarios.aux.m <- do.call(rbind, lapply(1:nrow(salario.estoc.m), function(i) {
  unlist(lapply(1:ncol(salario.estoc.m), function(j) {
    c(rep(salario.estoc.m[i, j], times = cotizaciones.m[i, j]),
      rep(0, 12 - cotizaciones.m[i, j]))
  }))
}))

# Se juntan las matrices de salarios
matriz.salarios.h <- cbind(cotizantes.h, salarios.aux.h)
matriz.salarios.m <- cbind(cotizantes.m, salarios.aux.m)

# Obtenemos los mejores salarios ordenados (pueden incluir 0), separados por sexo
salarios.top.h <- t(apply(matriz.salarios.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))
salarios.top.m <- t(apply(matriz.salarios.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))

# Identificamos las diferencias entre los salarios
diferencias.h <- t(apply(salarios.top.h, 1, function(fila) {
  abs(diff(fila))
}))
diferencias.m <- t(apply(salarios.top.m, 1, function(fila) {
  abs(diff(fila))
}))

# Cantidad de columnas en las diferencias
columnas.diff <- ncol(diferencias.h) - 1

# Un salario será atípico si es mayor a 5 millones y tiene menos de 12 salarios en un rango de 500 000 colones con ese monto o tiene un salario con una diferencia de más de 500 000 colones al siguiente 
# Iniciamos viendo las diferencias
atipicos.h <- t(apply(diferencias.h, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))
atipicos.m <- t(apply(diferencias.m, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))

# Ahora consideramos los atípicos en la matriz de salarios, considerando aquellos que son de más de 5 millones
salarios.top.h <-
  salarios.top.h[, -ncol(salarios.top.h)] * !(atipicos.h * (salarios.top.h[, -ncol(salarios.top.h)] > 5000000))
salarios.top.m <-
  salarios.top.m[, -ncol(salarios.top.m)] * !(atipicos.m * (salarios.top.m[, -ncol(salarios.top.m)] > 5000000))

# Se sacan los 300 mejores salarios, ahora sin los salarios atípicos
salarios.top.h <- t(apply(salarios.top.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))
salarios.top.m <- t(apply(salarios.top.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))

# Beneficio por vejez, separado por sexo
beneficio.vejez.h <-
  (pmin(300, cuotas.finales.h[which(salida.h == "Retirado")]) / 300) * (rowSums(salarios.top.h[which(salida.h == "Retirado"),]) / rowSums(salarios.top.h[which(salida.h == "Retirado"),] > 9999))
# Hacer la corrección a estados M, en donde las mujeres pueden retirarse a partir de los 63 si cumplen los requisitos
beneficio.vejez.m <-
  (pmin(300, cuotas.finales.m[which(salida.m == "Retirado")]) / 300) * (rowSums(salarios.top.m[which(salida.m == "Retirado"),]) / rowSums(salarios.top.m[which(salida.m == "Retirado"),] > 9999))

# Filas de invalidez
filas.inv.h <- which(salida.h == "Invalido")
filas.inv.m <- which(salida.m == "Invalido")

# Para el beneficio por invalidez, separado por sexo, iniciamos obteniendo la casilla en donde quedaron inválidos
restantes.inv.h <-
  apply(estados.h[filas.inv.h, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })
restantes.inv.m <-
  apply(estados.m[filas.inv.m, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })

# Se compara si se han tenido las cuotas necesarias
cuotas.binario.h <- mapply(function(i, j) {
  requisitos.inv.h[i, j] <= cuotas.finales.h[i]
}, i = filas.inv.h, j = restantes.inv.h)
cuotas.binario.m <- mapply(function(i, j) {
  requisitos.inv.m[i, j] <= cuotas.finales.m[i]
}, i = filas.inv.m, j = restantes.inv.m)

# Se obtienen las edades para las cuales se invalidó la persona (se pone acá y se borra la anterior que estaba)
edad.final.h <- restantes.inv.h + edades.h[filas.inv.h, 1] - 1
edad.final.m <- restantes.inv.m + edades.m[filas.inv.m, 1] - 1

# En este punto, se ve si las personas pensionadas por invalidez tienen las cuotas necesarias según el inciso b del artículo 6
requisito.cuotas.h <-
  (ifelse(
    ((restantes.inv.h == 1) * (edad.final.h < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.h == 2) * (edad.final.h < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
      ifelse((edad.final.h < 48), rowSums(cotizaciones.h[filas.inv.h, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.h == 1) * (edad.final.h > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.h == 2) * (edad.final.h > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 325:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
                           ifelse(((restantes.inv.h == 3) * (edad.final.h > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:2]),
                                  ifelse(((restantes.inv.h == 4) * (edad.final.h > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:3]),
                                         ifelse((edad.final.h > 47) == 1, rowSums(cotizaciones.h[filas.inv.h, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23
requisito.cuotas.m <-
  (ifelse(
    ((restantes.inv.m == 1) * (edad.final.m < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.m == 2) * (edad.final.m < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
      ifelse((edad.final.m < 48), rowSums(cotizaciones.m[filas.inv.m, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.m == 1) * (edad.final.m > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.m == 2) * (edad.final.m > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 325:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
                           ifelse(((restantes.inv.m == 3) * (edad.final.m > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:2]),
                                  ifelse(((restantes.inv.m == 4) * (edad.final.m > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:3]),
                                         ifelse((edad.final.m > 47) == 1, rowSums(cotizaciones.m[filas.inv.m, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23

# Si una persona inválida tiene las cuotas necesarias para su edad y cotizó 12 veces en los últimos 24 meses, tiene derecho a recibir pensión
resultado.binario.h <- cuotas.binario.h * requisito.cuotas.h
resultado.binario.m <- cuotas.binario.m * requisito.cuotas.m

# Beneficios por invalidez
beneficio.invalidez.h <-
  ifelse(cuotas.finales.h[filas.inv.h] > 299,
         (rowSums(salarios.top.h[filas.inv.h, ]) / 300),
         ifelse(cuotas.finales.h[filas.inv.h] > 179, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), ifelse(((cuotas.finales.h[filas.inv.h] < 180) * (resultado.binario.h == 1)
         ) == 1, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), 0)))
beneficio.invalidez.m <-
  ifelse(cuotas.finales.m[filas.inv.m] > 299,
         (rowSums(salarios.top.m[filas.inv.m, ]) / 300),
         ifelse(cuotas.finales.m[filas.inv.m] > 179, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), ifelse(((cuotas.finales.m[filas.inv.m] < 180) * (resultado.binario.m == 1)
         ) == 1, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), 0)))

# Primero, los índices de las personas que mueren
filas.muerte.h <- which(salida.h == "Fallecido")
filas.muerte.m <- which(salida.m == "Fallecido")

# Se identifican las columnas en la que ocurre la muerte (el año)
col.fallecido.h <-
  apply(estados.h[filas.muerte.h,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

col.fallecido.m <-
  apply(estados.m[filas.muerte.m,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

# Edad de la persona al morir para cada sexo
edad.fallecido.h <-
  mapply(function(i, j)
    edades.h[i, j], i = filas.muerte.h, j = col.fallecido.h)

edad.fallecido.m <-
  mapply(function(i, j)
    edades.m[i, j], i = filas.muerte.m, j = col.fallecido.m)

# Se crean dos vectores donde se identifica si al momento de la muerte el afiliado tenía un hijo
hijos.h <- edad.fallecido.h >= 25 & (edad.fallecido.h - 25) < 25
hijos.m <- edad.fallecido.m >= 25 & (edad.fallecido.m - 25) < 25

# Se calcula la pensión sucesoria con base en la pensión por vejez que hubiera recibido (art. 27)
salarios.sucesion.h <- salarios.top.h[filas.muerte.h,]
salarios.sucesion.m <- salarios.top.m[filas.muerte.m,]

beneficio.base.h <- rowSums(salarios.sucesion.h) / rowSums(salarios.top.h[which(salida.h == "Fallecido"),] > 9999)
beneficio.base.m <- rowSums(salarios.sucesion.m) / rowSums(salarios.top.m[which(salida.m == "Fallecido"),] > 9999)

# Se calcula el porcentaje para pensión por viudez según edad del cónyuge por art. 27: 70% si cónyuge ≥ 60, 60% si 50–59, 50% si < 50
porcentaje.viudez.h <- ifelse(edad.fallecido.h >= 60,
                              0.70,
                              ifelse(edad.fallecido.h >= 50, 0.60, 0.50))

porcentaje.viudez.m <- ifelse(edad.fallecido.m >= 60,
                              0.70,
                              ifelse(edad.fallecido.m >= 50, 0.60, 0.50))

# Así como el porcentaje para pensión por orfandad (30% si el hijo califica) art. 27: 30% para hijos menores de 25 años
porcentaje.hijo.h <- ifelse(hijos.h, 0.30, 0)
porcentaje.hijo.m <- ifelse(hijos.m, 0.30, 0)

# Se calcula el beneficio por sucesión (sin validar aún si tiene derecho)
beneficio.conyuge.h <- beneficio.base.h * porcentaje.viudez.h
beneficio.conyuge.m <- beneficio.base.m * porcentaje.viudez.m

beneficio.hijo.h <- beneficio.base.h * porcentaje.hijo.h
beneficio.hijo.m <- beneficio.base.m * porcentaje.hijo.m

# Se verifica si tiene derecho al beneficio por sucesion (art. 18)

# Condición 1: tener al menos 180 cotizaciones totales
requisito.180.h <- cuotas.finales.h[filas.muerte.h] >= 180
requisito.180.m <- cuotas.finales.m[filas.muerte.m] >= 180

# Condición 2: haber cotizado al menos 12 veces en los últimos 24 meses antes de morir, si murió antes de los 24 meses simulados se usan los datos anteriores que están en la base

requisito.24meses.h <-
  ifelse(
    col.fallecido.h == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 337:360] > 10000),
    ifelse(
      col.fallecido.h == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 349:360] > 10000) + cotizaciones.h[filas.muerte.h, 1],
      rowSums(cotizaciones.h[filas.muerte.h, 1:2])
    )
  ) > 11

requisito.24meses.m <-
  ifelse(
    col.fallecido.m == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 337:360] > 10000),
    ifelse(
      col.fallecido.m == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 349:360] > 10000) + cotizaciones.m[filas.muerte.m, 1],
      rowSums(cotizaciones.m[filas.muerte.m, 1:2])
    )
  ) > 11

# Debe de cumplir ambos requisitos
tiene.derecho.sucesion.h <- requisito.180.h & requisito.24meses.h
tiene.derecho.sucesion.m <- requisito.180.m & requisito.24meses.m

# Se verifica si califica para el derecho o no. En caso de que no se asigna un beneficio = 0
beneficio.conyuge.h <-
  ifelse(tiene.derecho.sucesion.h, beneficio.conyuge.h, 0)
beneficio.hijo.h    <-
  ifelse(tiene.derecho.sucesion.h, beneficio.hijo.h, 0)

beneficio.conyuge.m <-
  ifelse(tiene.derecho.sucesion.m, beneficio.conyuge.m, 0)
beneficio.hijo.m    <-
  ifelse(tiene.derecho.sucesion.m, beneficio.hijo.m, 0)

# Las filas de personas que se retiraron
filas.vejez.h <- which(salida.h == "Retirado")
filas.vejez.m <- which(salida.m == "Retirado")

# Los salario promedio base (prom. de 300 mejores salarios)
salario.referencia.h <- beneficio.vejez.h
salario.referencia.m <- beneficio.vejez.m

# La cuantía básica según salario
cuantia.vejez.h <- cuantia.basica(salario.referencia.h)
cuantia.vejez.m <- cuantia.basica(salario.referencia.m)

# La bonificación por cotizaciones adicionales (exceso sobre 300)
meses.extra.h <- pmax(0, cuotas.finales.h[filas.vejez.h] - 300)
meses.extra.m <- pmax(0, cuotas.finales.m[filas.vejez.m] - 300)
bono.cuotas.h <- meses.extra.h * bono.cotizaciones
bono.cuotas.m <- meses.extra.m * bono.cotizaciones

# La bonificación por postergación (meses en estado "Posterga")
meses.post.h <- 12 * rowSums(postergacion.simulada.h[filas.vejez.h, ])
meses.post.m <- 12 * rowSums(postergacion.simulada.m[filas.vejez.m, ])
bono.post.h <- meses.post.h * bono.postergacion
bono.post.m <- meses.post.m * bono.postergacion

# La tasa de reemplazo final
tasa.vejez.h <- cuantia.vejez.h + bono.cuotas.h + bono.post.h
tasa.vejez.m <- cuantia.vejez.m + bono.cuotas.m + bono.post.m

# Pensión final por vejez
pension.vejez.h <- salario.referencia.h * pmin(tasa.vejez.h, tasa.maxima)
pension.vejez.m <- salario.referencia.m * pmin(tasa.vejez.m, tasa.maxima)

# El salario base
salario.referencia.inv.h <- beneficio.invalidez.h
salario.referencia.inv.m <- beneficio.invalidez.m

# La cuantía básica
cuantia.invalidez.h <- cuantia.basica(salario.referencia.inv.h)
cuantia.invalidez.m <- cuantia.basica(salario.referencia.inv.m)

# La bonificación por cuotas (más de 300)
meses.extra.inv.h <- pmax(0, cuotas.finales.h[filas.inv.h] - 300)
meses.extra.inv.m <- pmax(0, cuotas.finales.m[filas.inv.m] - 300)
bono.cuotas.inv.h <- meses.extra.inv.h * bono.cotizaciones
bono.cuotas.inv.m <- meses.extra.inv.m * bono.cotizaciones

# La tasa de reemplazo
tasa.invalidez.h <- cuantia.invalidez.h + bono.cuotas.inv.h
tasa.invalidez.m <- cuantia.invalidez.m + bono.cuotas.inv.m

# La pensión por invalidez
pension.invalidez.h <- salario.referencia.inv.h * pmin(tasa.invalidez.h, tasa.maxima)
pension.invalidez.m <- salario.referencia.inv.m * pmin(tasa.invalidez.m, tasa.maxima)

# La pensión por sucesión
pension.sucesion.h <- beneficio.conyuge.h + beneficio.hijo.h
pension.sucesion.m <- beneficio.conyuge.m + beneficio.hijo.m

### Pensiones por vejez

# Filtramos la matriz de estados a partir de las personas con beneficio por vejez
matriz.vejez.h <- estados.h[filas.vejez.h, ]
matriz.vejez.m <- estados.m[filas.vejez.m, ]

# Filtramos la matriz de edades a partir de las personas con beneficio por vejez
edades.vejez.h <- edades.h[filas.vejez.h, ]
edades.vejez.m <- edades.m[filas.vejez.m, ]

# Calculamos en qué año ocurre el retiro por vejez para cada individuo
restantes.ret.h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Retirado")[1]
})

restantes.ret.m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Retirado")[1]
})

# Calculamos en qué año ocurre el fallecimiento para cada individuo
indices.2h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices de beneficio con ceros
matriz.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))
matriz.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Construimos la matriz de beneficios para hombres
for (i in 1:nrow(matriz.vejez.h)) {
  
  indice <- indices.2h[i]  # Año en que fallece la i-ésima persona
  
  # Se asigna 1 desde el retiro hasta justo antes del fallecimiento
  matriz.vejez.h[i, restantes.ret.h[i]:(indice - 1)] <- 1 

  edad <- edades.vejez.h[i, indice]  # Edad al fallecer

  # Se calcula la cantidad de años para simular la sobrevivencia del cónyuge
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Se extraen las probabilidades de muerte del cónyuge (mujer) por edad y año
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]

  # Se simula la vida del cónyuge comparando las probabilidades con números aleatorios
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio  # TRUE si muere

  # Se determina cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Se asigna 0.7 al beneficio durante los años en que el cónyuge está vivo
  matriz.vejez.h[i, indice:(indice + indice.3)] <- 0.7
}

# Lo mismo para mujeres
for (i in 1:nrow(matriz.vejez.m)) {
  
  indice <- indices.2m[i]
  matriz.vejez.m[i, restantes.ret.m[i]:(indice - 1)] <- 1
  
  edad <- edades.vejez.m[i, indice]
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejez.m[i, indice:(indice + indice.3)] <- 0.7
}

# Se construyen las matrices con los montos de pensión
monto.vejez.h <- matrix(pension.vejez.h, nrow(matriz.vejez.h), ncol(matriz.vejez.h))
monto.vejez.m <- matrix(pension.vejez.m, nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Multiplicamos las matrices de beneficios (0, 1, 0.7) por el monto de pensión
matriz.vejez.h <- matriz.vejez.h * monto.vejez.h
matriz.vejez.m <- matriz.vejez.m * monto.vejez.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejez.h <- pmin(matriz.vejez.h, 3500000)
matriz.vejez.m <- pmin(matriz.vejez.m, 3500000)

rm(edades.vejez.h, edades.vejez.m, monto.vejez.h, monto.vejez.m)

### Pensiones por invalidez

# Extraemos las filas correspondientes a inválidos
matriz.inv.h <- estados.h[filas.inv.h, ]
matriz.inv.m <- estados.m[filas.inv.m, ]

# Extraemos las edades correspondientes a inválidos
edades.inv.h <- edades.h[filas.inv.h, ]
edades.inv.m <- edades.m[filas.inv.m, ]

# Obtenemos el primer periodo donde se observa el estado "Fallecido"
indices.2h <- apply(matriz.inv.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.inv.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices con ceros para hombres y mujeres inválidos
matriz.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
matriz.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))

# Llenamos la matriz de hombres
for (i in 1:nrow(matriz.inv.h)) {
  
  indice <- indices.2h[i]  # Primer año de fallecimiento
  matriz.inv.h[i, restantes.inv.h[i]:(indice - 1)] <- 1  # Periodo de invalidez antes de fallecer
  
  edad <- edades.inv.h[i, indice]  # Edad al fallecer
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Obtenemos el qx del cónyuge (mujer)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  # Simulamos la vida del cónyuge con aleatoriedad
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1  # Tiempo que sobrevive el cónyuge

  # Asignamos el porcentaje de pensión según la edad
  if(edad >= 60){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)  # Máximo hasta que el hijo cumpla 25

    matriz.inv.h[i, indice:(indice + indice.4)] <- 
      matriz.inv.h[i, indice:(indice + indice.4)] + 0.3  # Agregamos el beneficio por hijo

  } else {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para las mujeres
for (i in 1:nrow(matriz.inv.m)) {
  
  indice <- indices.2m[i]
  matriz.inv.m[i, restantes.inv.m[i]:(indice - 1)] <- 1
  
  edad <- edades.inv.m[i, indice]
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)

  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Beneficio por hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.inv.m[i, indice:(indice + indice.4)] <- 
      matriz.inv.m[i, indice:(indice + indice.4)] + 0.3
    
  } else {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indices.2m[i] + 50 - edad):(indices.2m[i] + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Creamos las matrices de montos
monto.inv.h <- matrix(pension.invalidez.h, nrow(matriz.inv.h), ncol(matriz.inv.h))
monto.inv.m <- matrix(pension.invalidez.m, nrow(matriz.inv.m), ncol(matriz.inv.m))

# Aplicamos el monto a cada proporción de pensión
matriz.inv.h <- matriz.inv.h * monto.inv.h
matriz.inv.m <- matriz.inv.m * monto.inv.m

# Aplicamos el tope de pensión máximo de 3.5 millones
matriz.inv.h <- pmin(matriz.inv.h, 3500000)
matriz.inv.m <- pmin(matriz.inv.m, 3500000)

rm(edades.inv.h, edades.inv.m, monto.inv.h, monto.inv.m)

### Pensiones por sucesión

# Se inicializan matrices de ceros para guardar la sucesión de los hombres y mujeres
matriz.suc.h <- matrix(as.numeric(0), nrow(estados.h[filas.muerte.h, ]),
                       ncol(estados.h[filas.muerte.h, ]))

matriz.suc.m <- matrix(as.numeric(0), nrow(estados.m[filas.muerte.m, ]),
                       ncol(estados.m[filas.muerte.m, ]))

# Se calcula la matriz de sucesión de los hombres fallecidos
for(i in 1:nrow(matriz.suc.h)){
  
  edad <- edad.fallecido.h[i]  # Edad del hombre fallecido
  col <- col.fallecido.h[i]    # Columna donde inicia la sucesión

  # Se determina la cantidad de años a simular
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - col + 1)

  # Se obtienen las probabilidades de fallecimiento del cónyuge
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), col:(col + n - 1))]

  # Se simulan eventos aleatorios de fallecimiento del cónyuge
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio

  # Se identifica cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Asignación de porcentaje según edad al fallecer y condiciones
  if(edad >= 60){
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.h[i]){  # Si hay hijos
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.h[i, col:(col + indice.4)] <- 
      matriz.suc.h[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para mujeres
for(i in 1:nrow(matriz.suc.m)){
  
  edad <- edad.fallecido.m[i]
  col <- col.fallecido.m[i]

  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - col + 1)
  
  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), col:(col + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.m[i]){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  
    # Mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.m[i, col:(col + indice.4)] <- 
      matriz.suc.m[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se asigna el monto del beneficio base solo a los que tienen derecho a sucesión
sucesion.aux.h <- ifelse(tiene.derecho.sucesion.h, beneficio.base.h, 0)
sucesion.aux.m <- ifelse(tiene.derecho.sucesion.m, beneficio.base.m, 0)

# Se crean matrices con los montos por sucesión
monto.suc.h <- matrix(sucesion.aux.h, nrow(matriz.suc.h), ncol(matriz.suc.h))
monto.suc.m <- matrix(sucesion.aux.m, nrow(matriz.suc.m), ncol(matriz.suc.m))

# Se multiplica la proporción asignada por el monto base
matriz.suc.h <- matriz.suc.h * monto.suc.h
matriz.suc.m <- matriz.suc.m * monto.suc.m

# Se limita el monto máximo de la pensión por sucesión a 3.5 millones
matriz.suc.h <- pmin(matriz.suc.h, 3500000)
matriz.suc.m <- pmin(matriz.suc.m, 3500000)

rm(monto.suc.h, monto.suc.m, sucesion.aux.h, sucesion.aux.m)

### Pensionados iniciales

## Vejez

# Inicializamos las matrices de beneficio con ceros
matriz.vejini.h <- matrix(as.numeric(0), nrow(pensini.vej.h), ncol(edades))
matriz.vejini.m <- matrix(as.numeric(0), nrow(pensini.vej.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.vejini.h)) {
  
  edad <- edadini.vej.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.h[i, indice:(indice + indice.3)] <- 0.7
}

# Caso para mujeres
for (i in 1:nrow(matriz.vejini.m)) {
  
  edad <- edadini.vej.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.m[i, indice:(indice + indice.3)] <- 0.7
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.vejini.h <- matriz.vejini.h * pensini.vej.h
matriz.vejini.m <- matriz.vejini.m * pensini.vej.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejini.h <- pmin(matriz.vejini.h, 3500000)
matriz.vejini.m <- pmin(matriz.vejini.m, 3500000)

## Invalidez

# Inicializamos las matrices de beneficio con ceros
matriz.invini.h <- matrix(as.numeric(0), nrow(pensini.inv.h), ncol(edades))
matriz.invini.m <- matrix(as.numeric(0), nrow(pensini.inv.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.invini.h)) {
  
  edad <- edadini.inv.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.h[i, indice:(indice + indice.4)] <- 
      matriz.invini.h[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Caso para mujeres
for (i in 1:nrow(matriz.invini.m)) {
  
  edad <- edadini.inv.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.m[i, indice:(indice + indice.4)] <- 
      matriz.invini.m[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.invini.h <- matriz.invini.h * pensini.inv.h
matriz.invini.m <- matriz.invini.m * pensini.inv.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.invini.h <- pmin(matriz.invini.h, 3500000)
matriz.invini.m <- pmin(matriz.invini.m, 3500000)

## Sucesión cónyuge

# Inicializamos las matrices de beneficio con ceros
matriz.suc.ch <- matrix(as.numeric(0), nrow(pension.suc.ch), ncol(edades))
matriz.suc.cm <- matrix(as.numeric(0), nrow(pension.suc.cm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.ch)) {
  
  edad <- edad.suc.ch[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.ch[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.ch[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Caso para las mujeres
for (i in 1:nrow(matriz.suc.cm)) {
  
  edad <- edad.suc.cm[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.cm[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.cm[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.ch <- matriz.suc.ch * pension.suc.ch
matriz.suc.cm <- matriz.suc.cm * pension.suc.cm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.ch <- pmin(matriz.suc.ch, 3500000)
matriz.suc.cm <- pmin(matriz.suc.cm, 3500000)

## Sucesión hijo

# Inicializamos las matrices de beneficio con ceros
matriz.suc.hh <- matrix(as.numeric(0), nrow(pension.suc.hh), ncol(edades))
matriz.suc.hm <- matrix(as.numeric(0), nrow(pension.suc.hm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.hh)) {
  
  edad <- edad.suc.hh[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hh[i, 1:indice] <- 1  
    
  }
  
}

# Caso para mujeres
for (i in 1:nrow(matriz.suc.hm)) {
  
  edad <- edad.suc.hm[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hm[i, 1:indice] <- 1  
    
  }
  
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.hh <- matriz.suc.hh * pension.suc.hh
matriz.suc.hm <- matriz.suc.hm * pension.suc.hm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.hh <- pmin(matriz.suc.hh, 3500000)
matriz.suc.hm <- pmin(matriz.suc.hm, 3500000)

# Se juntan las matrices de sucesión por cónyuge e hijo en una sola
matriz.sucini.h <- rbind(matriz.suc.ch, matriz.suc.hh)
matriz.sucini.m <- rbind(matriz.suc.cm, matriz.suc.hm)

# Limpieza de variables temporales
rm(qx.conyuge, vect.aleatorio, estados.conyuge, indice.3, qx.hijo, estados.hijo,
   indice.4, edad, col, n, indice, qx.pensionado, estados.pensionado)

### Activo actuarial

# Se crea una lista con las matrices calculadas
matrices.pension <- list(matriz.vejez.h, matriz.vejez.m, matriz.inv.h, 
                         matriz.inv.m, matriz.suc.h, matriz.suc.m, 
                         matriz.vejini.h, matriz.vejini.m, matriz.invini.h, 
                         matriz.invini.m, matriz.sucini.h, matriz.sucini.m)

# Lista para matrices con los montos valor presente
matrices.vp <- list()

# Vector que tendrá el monto de las cotizaciones de los pensionados
cotizacion.pensiones <- rep(0, length(matrices.pension))

# Se itera sobre las matrices
for (i in 1:length(matrices.pension)) {
  
  # Se extienden las matrices de forma mensual, considerando el aguinaldo
  matrices.pension[[i]] <- t(apply(matrices.pension[[i]], 1, 
                                   function(fila) rep(fila, each = 13)))
  
  # Se obtiene el valor presente de cada matriz
  matrices.vp[[i]] <- matrices.pension[[i]] * matriz.vp[1:nrow(matrices.pension[[i]]), ]
  
  # Se determina la contribución de los pensionados
  mayores.2mill <- matrices.vp[[i]][matrices.pension[[i]] > 2000000]
  cotizacion.pensiones[i] <- sum(0.05 * mayores.2mill)
  
  # Se actualiza el monto de las pensiones correspondientes
  matrices.vp[[i]] <- matrices.vp[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
  matrices.pension[[i]] <- matrices.pension[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
}

# Se suman las cotizaciones de los pensionados de cada matriz
cotizacion.pensiones <- sum(cotizacion.pensiones)

# Se construye la matriz con los salarios totales para determinar la masa salarial
salarios.finales <- rbind(salario.estoc.h * cotizaciones.h, 
                          salario.estoc.m * cotizaciones.m)

# Se crea la matriz con los factores de descuento para determinar las cotizaciones de los trabajadores
matriz.descuento <- matrix(rep(s, times = nrow(salarios.finales)), 
                           nrow(salarios.finales), byrow = TRUE)

# Se calcula la masa salarial
masa.salarial <- sum(salarios.finales * matriz.descuento)

# Se calcula la contribución de los trabajadores
cotizacion.trab <- masa.salarial * 0.15

# Se calcula el activo actuarial
total.activo <- cotizacion.pensiones + cotizacion.trab + reserva.ini

rm(mayores.2mill)

### Flujos de balance

# Inicializamos los vectores para determinar los años críticos
reserva <- c(reserva.ini)
total.egresos <- c()
cotizaciones <- c()
rends <- c()

# Inicializamos el vector de años críticos
annos <- c(0, 0, 0)

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Cotizaciones de los trabajadores
  cotizaciones <- c(cotizaciones, (sum(salarios.finales[, i]) * 0.15))
  
  # Costo de las pensiones
  costo.pens <- Reduce("+", sapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto administrativo del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Total de egresos
  total.egresos <- c(total.egresos, costo.pens + sem)
  
  # Rendimientos
  rends <- c(rends, ifelse((reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real > 0, 
                           (reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real, 0))
  
  # Total de ingresos
  total.ingresos <- cotizaciones[i] + rends[i]
  
  # Guardamos la reserva final (reserva inicial del siguiente año)
  reserva <- c(reserva, (reserva[i] + total.ingresos - total.egresos[i] + sem))
}

# Eliminamos la última reserva final
reserva <- reserva[-length(reserva)]

# Determinamos los años críticos
idx <- which(total.egresos > cotizaciones)[1]
annos[1] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends))[1]
annos[2] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends + reserva))[1]
annos[3] <- idx + 2024

### Pasivo actuarial

# Se calcula el total de las pensiones
total.pensiones <- sum(sapply(matrices.vp, sum))

# Se calcula el monto del SEM
sem <- total.pensiones * (12/13) * 0.085

# Por último se calcula el pasivo actuarial
total.pasivo <- total.pensiones + sem

### Indicadores de solvencia

# Agregamos los indicadores a sus respectivas listas
razon.solvencia <- append(razon.solvencia, (total.activo / total.pasivo))
annos.crit <- append(annos.crit, list(annos))
balance <- append(balance, list(c(total.activo, total.pasivo)))
prima.media <- append(prima.media, ((total.pasivo - reserva.ini) / masa.salarial))

# Actualizamos los promedios para el ciclo while
prom.antes <- prom.despues
prom.despues <- mean(unlist(razon.solvencia))

# Se guardan las matrices de pensión
pensiones <- append(pensiones, matrices.vp)
}

end.time <- Sys.time()

end.time - start.time
```

Una vez el modelo haya terminado de hacer las iteraciones, se procede a determinar la tasa de ingresos, la prima de reparto y la razón de fondo de contingencias, usando las variables de la última iteración.

```{r metricas_optimista}
# Inicializamos la reserva inicial en el 2025 y los vectores para las métricas
reserva <- reserva.ini
tasa.ingresos <- c()
prima.reparto <- c()
razon.fondo.cont <- c()

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Masa salarial
  ms <- sum(salarios.finales[, i])
  
  # Cotizaciones de los trabajadores
  cotizaciones <- ms * 0.15
  
  # Costo de las pensiones en cada año
  costo.pens <- Reduce("+", lapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Egresos totales
  total.egresos <- costo.pens + sem
  
  # Rendimientos
  rends <- ifelse((reserva + (cotizaciones - total.egresos) / 2) * interes.real > 0, 
                  (reserva + (cotizaciones - total.egresos) / 2) * interes.real, 0)
  
  # Ingresos totales
  total.ingresos <- cotizaciones + rends
  
  # Guardamos las métricas
  tasa.ingresos <- c(tasa.ingresos, ifelse(ms > 0, (total.ingresos / ms), NA))
  prima.reparto <- c(prima.reparto, ifelse(ms > 0, (total.egresos / ms), NA))
  razon.fondo.cont <- c(razon.fondo.cont, total.egresos / reserva)
  
  # Actualizamos la reserva inicial para el siguiente año
  reserva <- reserva + total.ingresos - total.egresos + sem
  
}
```

## Resultados caso optimista

## Razón de solvencia

Ahora se procede con las razones de solvencia. Inicialmente, se tiene el promedio de las razones de solvencia para este caso:

```{r rs_optimista}
(prom.rs <- mean(unlist(razon.solvencia)))
```

Se puede observar en un gráfico de densidad las distintas razones de solvencia.

```{r densidad_rs_optimista}
# Se crea un dataframe con los datos
data.rs <- data.frame(rs = unlist(razon.solvencia))

# Gráfico de las razones de solvencia
ggplot(data.rs, aes(x = rs)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.rs,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.rs,
    y = 50,
    label = "Media de las RS",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón de solvencia",
       y = "Densidad") +
  theme_minimal()
```

## Años críticos

En primer lugar, se obtendrá un promedio de los años críticos.

```{r annos_criticos_optimista}
# Se guarda como matriz
annos.crit.mat <- do.call(cbind, annos.crit)

# Se redondean los promedios
round(rowMeans(annos.crit.mat, na.rm = TRUE), 0)
```

Los anteriores están ordenados en primer, segundo y tercer año crítico respectivamente. Si los resultados son **NaN** significa que en ningún caso se llega a ese año crítico.

Para el caso en estudio, usualmente solo se llega al primer año crítico entre las iteraciones, por lo que se grafica ese caso.

```{r grafico_annos_criticos_optimista}
# Se guardan los primeros años críticos en un DataFrame
df.annos.crit <- data.frame(primer_momento = annos.crit.mat[1, ])

# Se grafican los primeros momentos correspondientes
ggplot(df.annos.crit, aes(x = primer_momento)) +
  geom_histogram(
    aes(y = after_stat(count / sum(count))),
    bins = 2,
    fill = "#A34022",
    color = "black"
  ) +
  labs(x = "Año",
       y = "Densidad")
theme_minimal()
```

## Prima media

Como se menciona en el reglamento, se procede con la prima media. Inicialmente se obtiene el promedio de estas:

```{r prima_media_optimista}
(prom.pm <- mean(unlist(prima.media)))
```

Un análisis más detallado se observa en el siguiente gráfico:

```{r grafico_prima_media_optimista}
# Se crea un dataframe con los datos
data.pm <- data.frame(pm = unlist(prima.media))

# Gráfico de las primas medias niveladas
ggplot(data.pm, aes(x = pm)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pm,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pm,
    y = 10,
    label = "Promedio de la prima media",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima media nivelada",
       y = "Densidad") +
  theme_minimal()
```

## Razón del fondo de contingencia

Se muestra la razón del fondo de contingencia de la última simulación, visualizada en un gráfico.

```{r grafico_rc_optimista}
# Se crea un dataframe con los datos
data.rc <- data.frame(rc = razon.fondo.cont)

# Gráfico de las razones del fondo de contingencia
ggplot(data.rc, aes(x = rc)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = mean(razon.fondo.cont),
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = mean(razon.fondo.cont),
    y = 100,
    label = "Media de la RC",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón del fondo de contingencia",
       y = "Densidad") +
  theme_minimal()
```

Una vez más, se aprecia que la reserva es muy grande en comparación con los egresos, lo cual produce resultados muy cercanos a 0 para esta métrica.

## Tasa de ingresos

La tasa de ingresos se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_optimista}
(prom.ti <- mean(tasa.ingresos, na.rm = TRUE))
```

Se observan los resultados en un gráfico.

```{r grafico_ti_optimista}
# Se crea un dataframe con los datos
data.ti <- data.frame(ti = tasa.ingresos)

# Gráfico de las razones del fondo de contingencia
ggplot(data.ti, aes(x = ti)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.ti,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.ti,
    y = 0.002,
    label = "Media de la TI",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Tasa de ingresos",
       y = "Densidad") +
  theme_minimal()
```

Los primeros valores están entre 10 y 20, lo cual condiciona mucho el gráfico.

## Prima de reparto

La prima de reparto se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_optimista}
(prom.pr <- mean(prima.reparto, na.rm = TRUE))
```

Se observa el comportamiento en un gráfico.

```{r grafico_pr_optimista}
# Se crea un dataframe con los datos
data.pr <- data.frame(pr = prima.reparto)

# Gráfico de las razones del fondo de contingencia
ggplot(data.pr, aes(x = pr)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pr,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pr,
    y = 0.04,
    label = "Media de la prima de reparto",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima de reparto",
       y = "Densidad") +
  theme_minimal()
```

Se observa que muchos de los valores son menores a 1. Incluso, más del $75\%$ tienen menos de 2 dígitos.

## Balance

El promedio del activo y del pasivo a lo largo de las iteraciones se muestra a continuación.

```{r prom_balance_optimista}
# Se obtienen los valores en una matriz
matriz.balance <- do.call(cbind, balance)

# Promedio del activo y del pasivo respectivamente
rowMeans(matriz.balance)
```

Seguidamente, como pide el reglamento, se muestran las pensiones separadas por generaciones y por razón de salida.

```{r pasivo_separado_optimista}
# Se defina una matriz para obtener los montos
matriz.pasivo <- matrix(0, nrow = 6, ncol = (length(pensiones) / 12))

# Se obtienen los montos con un ciclo
for (i in 1:ncol(matriz.pasivo)) {
  # Se hace la suma de la iteración correspondiente
  suma.iter <- sapply(pensiones[(1+(i*12 - 12)):(12*i)], sum)
  
  # Se actualiza la matriz
  matriz.pasivo[, i] <-
    c((suma.iter[1] + suma.iter[2]),
      (suma.iter[3] + suma.iter[4]),
      (suma.iter[5] + suma.iter[6]),
      (suma.iter[7] + suma.iter[8]),
      (suma.iter[9] + suma.iter[10]),
      (suma.iter[11] + suma.iter[12]))
}

# Se pone la información en un dataframe
(
  df.pasivo <-
    data.frame(
      "Generación actual" = c(rowMeans(matriz.pasivo)[1:3], sum(rowMeans(matriz.pasivo)[1:3])),
      "Generación pensionada" = c(rowMeans(matriz.pasivo)[4:6], sum(rowMeans(matriz.pasivo)[4:6])),
      row.names = c("Vejez", "Invalidez", "Sucesion", "Total")
    )
)
```


Lo anterior se muestra en el siguiente gráfico.

```{r grafico_balance_optimista}
# Se pone la información en un dataframe
df.balance <- data.frame(valor = rowMeans(matriz.balance),
                         categoria = c("Activo", "Pasivo"))

# Gráfico del balance
ggplot(df.balance, aes(x = categoria, y = (valor / 1000000000))) +
  geom_bar(stat = "identity", fill = "#A34022") +
  labs(x = "Categoría del balance", y = "Valor (Miles de millones de colones)") +
  theme_minimal()
```


estos se muestran por separado, tal y como menciona el reglamento. Esto representa el promedio del valor presente de todos los activos y pasivos, respectivamente, de los 95 años proyectados.

# Análisis de sensibilidad

## Incremento en las tasas de mortalidad

Para este caso, todas las variables serán constantes con respecto al escenario base, solo se cambiará la mortalidad a través de un aumento del $5\%$. Entonces, se inicia cambiando las variables modificadas anteriormente.

```{r correcciones_as1}
# Tasa de interés real
interes.real <- ((0.1376-0.04) / 1.04) - 0.02
tasa.mensual <- (1 + interes.real)^(1/12) - 1

# Se crea el vector con las tasas de descuento
s <- 1 / ((1 + interes.real)^(0:(ncol(matriz.salarios) - 1)))

# Se obtienen las potencias de los valores presentes, incluyendo el aguinaldo
potencia.mensual <-
  rep(seq(1:(ncol(edades) * 12)), 
      times = ifelse((seq(1:(ncol(edades) * 12)) %% 12) == 0, 2, 1))

# Se obtiene el valor presente de cada periodo proyectado
matriz.vp <-
  matrix(((1 + tasa.mensual) ^ -((potencia.mensual - 1) / 12)), nrow(cotizantes), 
         length(potencia.mensual), byrow = TRUE)
```

Luego, se debe proceder a modificar la mortalidad en las variables correspondientes.

```{r mortalidad_as1}
# Se incrementa la mortalidad en cada caso
mortalidad$qx <- mortalidad$qx * 1.05

# Se pone el tope de 1 la la mortalidad
mortalidad$qx <- ifelse(mortalidad$qx > 1, 1, mortalidad$qx)

# Para las probabilidades de muerte, se inicia creando las matrices vacías
mort.h <- matrix(0, nrow = nrow(edades.h), ncol = ncol(edades.h))
mort.m <- matrix(0, nrow = nrow(edades.m), ncol = ncol(edades.m))

# Se corrigen los nombres de sus columnas
colnames(mort.h) <- colnames(edades.h)
colnames(mort.m) <- colnames(edades.m)

# Se agregan las probabilidades por cada año (columna), para ambos sexos
for (i in 1:ncol(mort.h)) {
  mort.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.h)[i])][.(edad = edades.h[, i]), 
                                                         on = .(edad), qx]
  mort.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.m)[i])][.(edad = edades.m[, i]), 
                                                         on = .(edad), qx]
}

# Se corrigen las mortalidades para derechos sucesorios
mort.completa.h <- matrix(0, length(ages), ncol(edades))
mort.completa.m <- matrix(0, length(ages), ncol(edades))

colnames(mort.completa.h) <- colnames(edades)
colnames(mort.completa.m) <- colnames(edades)

for (i in 1:ncol(mort.completa.h)) {
  
  mort.completa.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.completa.h)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
  mort.completa.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.completa.m)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
}

mort.completa.h[is.na(mort.completa.h)] <- 1
mort.completa.m[is.na(mort.completa.m)] <- 1

mort.hijos <- 0.5 * (mort.completa.h + mort.completa.m)
```


Posteriormente, se tiene un modelo idéntico. Iniciamos con las listas.

```{r listas_iniciales_as1}
razon.solvencia <- list()
annos.crit <- list()
balance <- list()
prima.media <- list()
beneficio.devengado.vejez <- list()
beneficio.devengado.invalidez <- list()
beneficio.devengado.sucesion <- list()
pensiones <- list()

# Inicializamos los promedios para asegurarnos de que se harán mínimo 2 iteraciones
prom.antes <- 0
prom.despues <- 1
```

Con esto, se procede con el modelo en sí.

```{r estocastico_as1, echo = FALSE}
start.time <- Sys.time()

while(abs(prom.despues - prom.antes) >= 0.00001){
  
# Se crean dos matrices aleatorias usando distribución Uniforme(0, 1)
matriz.aleatoria.h <- matrix(runif(nrow(cotizantes.h) * ncol(mort.h)), 
                             nrow(cotizantes.h), ncol(mort.h))

matriz.aleatoria.m <- matrix(runif(nrow(cotizantes.m) * ncol(mort.m)), 
                             nrow(cotizantes.m), ncol(mort.m))

# Se continúa con las matrices de probabilidades de postergación
postergacion.simulada.h <- matriz.aleatoria.h < df.probabilidad.postergacion.h
postergacion.simulada.m <- matriz.aleatoria.m < df.probabilidad.postergacion.m

# Se corrigen las postergaciones incorrectas
postergacion.simulada.h <-
  t(apply(postergacion.simulada.h, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))
postergacion.simulada.m <-
  t(apply(postergacion.simulada.m, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))

# Matrices de números uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <-
  inv.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.h[[2]] <-
  mort.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.m[[1]] <-
  inv.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

lista.estados.m[[2]] <-
  mort.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Se hacen las correcciones, para que si entra en un estado se mantenga en él durante el tiempo
lista.estados.h[[1]] <-
  t(apply(lista.estados.h[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.h[[2]] <-
  t(apply(lista.estados.h[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[1]] <-
  t(apply(lista.estados.m[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[2]] <-
  t(apply(lista.estados.m[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))

# Se hace la matriz con los estados de cada persona, separando por sexo
estados.h <-
  ifelse(lista.estados.h[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.h[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.h == 1) * (cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 1,
           "Posterga",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 1)) == 1,
           "Activo",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 0)) == 1, "Inactivo", ifelse(
             edades.h > 64,
             "Retirado",
             ifelse(actividad.h == 1, "Activo", "Inactivo")
           ))
           ))
         ))
estados.m <-
  ifelse(lista.estados.m[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.m[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 404) * (edades.m == 63)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 356) * (edades.m == 64)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 179) * (edades.m > 64)
           ) == 1,
           "Posterga",
           ifelse(
             ((edades.m == 63) * (cotizaciones.acum.m > 404)) == 1,
             "Retirado",
             ifelse(((edades.m == 64) * (cotizaciones.acum.m > 356)
             ) == 1, "Retirado", ifelse(((edades.m > 64) * (cotizaciones.acum.m > 179)) == 1,
                                        "Retirado",
                                        ifelse(actividad.m == 1, "Activo", "Inactivo")
             ))
           ))
           ))
         ))

# Existe el caso en donde una persona retirada puede quedar inválida posteriormente, por lo que se corrije dicho escenario
estados.h <- t(apply(estados.h, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))

# Ahora, existe el caso en donde una persona retirada puede postergar, por lo que se corrije ese caso
estados.h <- t(apply(estados.h, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))

# Se obtiene el salario, separado por sexo
salario.estoc.h <-
  salarios.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
salario.estoc.m <-
  salarios.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Obtenemos las razones de salida, separado por sexo
salida.h <- apply(estados.h, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})
salida.m <- apply(estados.m, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})

# Cotizaciones reales
cotizaciones.h <- matriz.cot.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
cotizaciones.m <- matriz.cot.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Consideramos la cantidad final de cuotas, separada por sexo
cuotas.finales.h <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + rowSums(cotizaciones.h)
cuotas.finales.m <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + rowSums(cotizaciones.m)

# Vamos a obtener los salarios de cada persona, separado por sexo, de la parte estocástica
salarios.aux.h <- do.call(rbind, lapply(1:nrow(salario.estoc.h), function(i) {
  unlist(lapply(1:ncol(salario.estoc.h), function(j) {
    c(rep(salario.estoc.h[i, j], times = cotizaciones.h[i, j]),
      rep(0, 12 - cotizaciones.h[i, j]))
  }))
}))
salarios.aux.m <- do.call(rbind, lapply(1:nrow(salario.estoc.m), function(i) {
  unlist(lapply(1:ncol(salario.estoc.m), function(j) {
    c(rep(salario.estoc.m[i, j], times = cotizaciones.m[i, j]),
      rep(0, 12 - cotizaciones.m[i, j]))
  }))
}))

# Se juntan las matrices de salarios
matriz.salarios.h <- cbind(cotizantes.h, salarios.aux.h)
matriz.salarios.m <- cbind(cotizantes.m, salarios.aux.m)

# Obtenemos los mejores salarios ordenados (pueden incluir 0), separados por sexo
salarios.top.h <- t(apply(matriz.salarios.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))
salarios.top.m <- t(apply(matriz.salarios.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))

# Identificamos las diferencias entre los salarios
diferencias.h <- t(apply(salarios.top.h, 1, function(fila) {
  abs(diff(fila))
}))
diferencias.m <- t(apply(salarios.top.m, 1, function(fila) {
  abs(diff(fila))
}))

# Cantidad de columnas en las diferencias
columnas.diff <- ncol(diferencias.h) - 1

# Un salario será atípico si es mayor a 5 millones y tiene menos de 12 salarios en un rango de 500 000 colones con ese monto o tiene un salario con una diferencia de más de 500 000 colones al siguiente 
# Iniciamos viendo las diferencias
atipicos.h <- t(apply(diferencias.h, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))
atipicos.m <- t(apply(diferencias.m, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))

# Ahora consideramos los atípicos en la matriz de salarios, considerando aquellos que son de más de 5 millones
salarios.top.h <-
  salarios.top.h[, -ncol(salarios.top.h)] * !(atipicos.h * (salarios.top.h[, -ncol(salarios.top.h)] > 5000000))
salarios.top.m <-
  salarios.top.m[, -ncol(salarios.top.m)] * !(atipicos.m * (salarios.top.m[, -ncol(salarios.top.m)] > 5000000))

# Se sacan los 300 mejores salarios, ahora sin los salarios atípicos
salarios.top.h <- t(apply(salarios.top.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))
salarios.top.m <- t(apply(salarios.top.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))

# Beneficio por vejez, separado por sexo
beneficio.vejez.h <-
  (pmin(300, cuotas.finales.h[which(salida.h == "Retirado")]) / 300) * (rowSums(salarios.top.h[which(salida.h == "Retirado"),]) / rowSums(salarios.top.h[which(salida.h == "Retirado"),] > 9999))
# Hacer la corrección a estados M, en donde las mujeres pueden retirarse a partir de los 63 si cumplen los requisitos
beneficio.vejez.m <-
  (pmin(300, cuotas.finales.m[which(salida.m == "Retirado")]) / 300) * (rowSums(salarios.top.m[which(salida.m == "Retirado"),]) / rowSums(salarios.top.m[which(salida.m == "Retirado"),] > 9999))

# Filas de invalidez
filas.inv.h <- which(salida.h == "Invalido")
filas.inv.m <- which(salida.m == "Invalido")

# Para el beneficio por invalidez, separado por sexo, iniciamos obteniendo la casilla en donde quedaron inválidos
restantes.inv.h <-
  apply(estados.h[filas.inv.h, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })
restantes.inv.m <-
  apply(estados.m[filas.inv.m, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })

# Se compara si se han tenido las cuotas necesarias
cuotas.binario.h <- mapply(function(i, j) {
  requisitos.inv.h[i, j] <= cuotas.finales.h[i]
}, i = filas.inv.h, j = restantes.inv.h)
cuotas.binario.m <- mapply(function(i, j) {
  requisitos.inv.m[i, j] <= cuotas.finales.m[i]
}, i = filas.inv.m, j = restantes.inv.m)

# Se obtienen las edades para las cuales se invalidó la persona (se pone acá y se borra la anterior que estaba)
edad.final.h <- restantes.inv.h + edades.h[filas.inv.h, 1] - 1
edad.final.m <- restantes.inv.m + edades.m[filas.inv.m, 1] - 1

# En este punto, se ve si las personas pensionadas por invalidez tienen las cuotas necesarias según el inciso b del artículo 6
requisito.cuotas.h <-
  (ifelse(
    ((restantes.inv.h == 1) * (edad.final.h < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.h == 2) * (edad.final.h < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
      ifelse((edad.final.h < 48), rowSums(cotizaciones.h[filas.inv.h, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.h == 1) * (edad.final.h > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.h == 2) * (edad.final.h > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 325:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
                           ifelse(((restantes.inv.h == 3) * (edad.final.h > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:2]),
                                  ifelse(((restantes.inv.h == 4) * (edad.final.h > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:3]),
                                         ifelse((edad.final.h > 47) == 1, rowSums(cotizaciones.h[filas.inv.h, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23
requisito.cuotas.m <-
  (ifelse(
    ((restantes.inv.m == 1) * (edad.final.m < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.m == 2) * (edad.final.m < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
      ifelse((edad.final.m < 48), rowSums(cotizaciones.m[filas.inv.m, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.m == 1) * (edad.final.m > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.m == 2) * (edad.final.m > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 325:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
                           ifelse(((restantes.inv.m == 3) * (edad.final.m > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:2]),
                                  ifelse(((restantes.inv.m == 4) * (edad.final.m > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:3]),
                                         ifelse((edad.final.m > 47) == 1, rowSums(cotizaciones.m[filas.inv.m, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23

# Si una persona inválida tiene las cuotas necesarias para su edad y cotizó 12 veces en los últimos 24 meses, tiene derecho a recibir pensión
resultado.binario.h <- cuotas.binario.h * requisito.cuotas.h
resultado.binario.m <- cuotas.binario.m * requisito.cuotas.m

# Beneficios por invalidez
beneficio.invalidez.h <-
  ifelse(cuotas.finales.h[filas.inv.h] > 299,
         (rowSums(salarios.top.h[filas.inv.h, ]) / 300),
         ifelse(cuotas.finales.h[filas.inv.h] > 179, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), ifelse(((cuotas.finales.h[filas.inv.h] < 180) * (resultado.binario.h == 1)
         ) == 1, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), 0)))
beneficio.invalidez.m <-
  ifelse(cuotas.finales.m[filas.inv.m] > 299,
         (rowSums(salarios.top.m[filas.inv.m, ]) / 300),
         ifelse(cuotas.finales.m[filas.inv.m] > 179, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), ifelse(((cuotas.finales.m[filas.inv.m] < 180) * (resultado.binario.m == 1)
         ) == 1, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), 0)))

# Primero, los índices de las personas que mueren
filas.muerte.h <- which(salida.h == "Fallecido")
filas.muerte.m <- which(salida.m == "Fallecido")

# Se identifican las columnas en la que ocurre la muerte (el año)
col.fallecido.h <-
  apply(estados.h[filas.muerte.h,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

col.fallecido.m <-
  apply(estados.m[filas.muerte.m,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

# Edad de la persona al morir para cada sexo
edad.fallecido.h <-
  mapply(function(i, j)
    edades.h[i, j], i = filas.muerte.h, j = col.fallecido.h)

edad.fallecido.m <-
  mapply(function(i, j)
    edades.m[i, j], i = filas.muerte.m, j = col.fallecido.m)

# Se crean dos vectores donde se identifica si al momento de la muerte el afiliado tenía un hijo
hijos.h <- edad.fallecido.h >= 25 & (edad.fallecido.h - 25) < 25
hijos.m <- edad.fallecido.m >= 25 & (edad.fallecido.m - 25) < 25

# Se calcula la pensión sucesoria con base en la pensión por vejez que hubiera recibido (art. 27)
salarios.sucesion.h <- salarios.top.h[filas.muerte.h,]
salarios.sucesion.m <- salarios.top.m[filas.muerte.m,]

beneficio.base.h <- rowSums(salarios.sucesion.h) / rowSums(salarios.top.h[which(salida.h == "Fallecido"),] > 9999)
beneficio.base.m <- rowSums(salarios.sucesion.m) / rowSums(salarios.top.m[which(salida.m == "Fallecido"),] > 9999)

# Se calcula el porcentaje para pensión por viudez según edad del cónyuge por art. 27: 70% si cónyuge ≥ 60, 60% si 50–59, 50% si < 50
porcentaje.viudez.h <- ifelse(edad.fallecido.h >= 60,
                              0.70,
                              ifelse(edad.fallecido.h >= 50, 0.60, 0.50))

porcentaje.viudez.m <- ifelse(edad.fallecido.m >= 60,
                              0.70,
                              ifelse(edad.fallecido.m >= 50, 0.60, 0.50))

# Así como el porcentaje para pensión por orfandad (30% si el hijo califica) art. 27: 30% para hijos menores de 25 años
porcentaje.hijo.h <- ifelse(hijos.h, 0.30, 0)
porcentaje.hijo.m <- ifelse(hijos.m, 0.30, 0)

# Se calcula el beneficio por sucesión (sin validar aún si tiene derecho)
beneficio.conyuge.h <- beneficio.base.h * porcentaje.viudez.h
beneficio.conyuge.m <- beneficio.base.m * porcentaje.viudez.m

beneficio.hijo.h <- beneficio.base.h * porcentaje.hijo.h
beneficio.hijo.m <- beneficio.base.m * porcentaje.hijo.m

# Se verifica si tiene derecho al beneficio por sucesion (art. 18)

# Condición 1: tener al menos 180 cotizaciones totales
requisito.180.h <- cuotas.finales.h[filas.muerte.h] >= 180
requisito.180.m <- cuotas.finales.m[filas.muerte.m] >= 180

# Condición 2: haber cotizado al menos 12 veces en los últimos 24 meses antes de morir, si murió antes de los 24 meses simulados se usan los datos anteriores que están en la base

requisito.24meses.h <-
  ifelse(
    col.fallecido.h == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 337:360] > 10000),
    ifelse(
      col.fallecido.h == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 349:360] > 10000) + cotizaciones.h[filas.muerte.h, 1],
      rowSums(cotizaciones.h[filas.muerte.h, 1:2])
    )
  ) > 11

requisito.24meses.m <-
  ifelse(
    col.fallecido.m == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 337:360] > 10000),
    ifelse(
      col.fallecido.m == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 349:360] > 10000) + cotizaciones.m[filas.muerte.m, 1],
      rowSums(cotizaciones.m[filas.muerte.m, 1:2])
    )
  ) > 11

# Debe de cumplir ambos requisitos
tiene.derecho.sucesion.h <- requisito.180.h & requisito.24meses.h
tiene.derecho.sucesion.m <- requisito.180.m & requisito.24meses.m

# Se verifica si califica para el derecho o no. En caso de que no se asigna un beneficio = 0
beneficio.conyuge.h <-
  ifelse(tiene.derecho.sucesion.h, beneficio.conyuge.h, 0)
beneficio.hijo.h    <-
  ifelse(tiene.derecho.sucesion.h, beneficio.hijo.h, 0)

beneficio.conyuge.m <-
  ifelse(tiene.derecho.sucesion.m, beneficio.conyuge.m, 0)
beneficio.hijo.m    <-
  ifelse(tiene.derecho.sucesion.m, beneficio.hijo.m, 0)

# Las filas de personas que se retiraron
filas.vejez.h <- which(salida.h == "Retirado")
filas.vejez.m <- which(salida.m == "Retirado")

# Los salario promedio base (prom. de 300 mejores salarios)
salario.referencia.h <- beneficio.vejez.h
salario.referencia.m <- beneficio.vejez.m

# La cuantía básica según salario
cuantia.vejez.h <- cuantia.basica(salario.referencia.h)
cuantia.vejez.m <- cuantia.basica(salario.referencia.m)

# La bonificación por cotizaciones adicionales (exceso sobre 300)
meses.extra.h <- pmax(0, cuotas.finales.h[filas.vejez.h] - 300)
meses.extra.m <- pmax(0, cuotas.finales.m[filas.vejez.m] - 300)
bono.cuotas.h <- meses.extra.h * bono.cotizaciones
bono.cuotas.m <- meses.extra.m * bono.cotizaciones

# La bonificación por postergación (meses en estado "Posterga")
meses.post.h <- 12 * rowSums(postergacion.simulada.h[filas.vejez.h, ])
meses.post.m <- 12 * rowSums(postergacion.simulada.m[filas.vejez.m, ])
bono.post.h <- meses.post.h * bono.postergacion
bono.post.m <- meses.post.m * bono.postergacion

# La tasa de reemplazo final
tasa.vejez.h <- cuantia.vejez.h + bono.cuotas.h + bono.post.h
tasa.vejez.m <- cuantia.vejez.m + bono.cuotas.m + bono.post.m

# Pensión final por vejez
pension.vejez.h <- salario.referencia.h * pmin(tasa.vejez.h, tasa.maxima)
pension.vejez.m <- salario.referencia.m * pmin(tasa.vejez.m, tasa.maxima)

# El salario base
salario.referencia.inv.h <- beneficio.invalidez.h
salario.referencia.inv.m <- beneficio.invalidez.m

# La cuantía básica
cuantia.invalidez.h <- cuantia.basica(salario.referencia.inv.h)
cuantia.invalidez.m <- cuantia.basica(salario.referencia.inv.m)

# La bonificación por cuotas (más de 300)
meses.extra.inv.h <- pmax(0, cuotas.finales.h[filas.inv.h] - 300)
meses.extra.inv.m <- pmax(0, cuotas.finales.m[filas.inv.m] - 300)
bono.cuotas.inv.h <- meses.extra.inv.h * bono.cotizaciones
bono.cuotas.inv.m <- meses.extra.inv.m * bono.cotizaciones

# La tasa de reemplazo
tasa.invalidez.h <- cuantia.invalidez.h + bono.cuotas.inv.h
tasa.invalidez.m <- cuantia.invalidez.m + bono.cuotas.inv.m

# La pensión por invalidez
pension.invalidez.h <- salario.referencia.inv.h * pmin(tasa.invalidez.h, tasa.maxima)
pension.invalidez.m <- salario.referencia.inv.m * pmin(tasa.invalidez.m, tasa.maxima)

# La pensión por sucesión
pension.sucesion.h <- beneficio.conyuge.h + beneficio.hijo.h
pension.sucesion.m <- beneficio.conyuge.m + beneficio.hijo.m

### Pensiones por vejez

# Filtramos la matriz de estados a partir de las personas con beneficio por vejez
matriz.vejez.h <- estados.h[filas.vejez.h, ]
matriz.vejez.m <- estados.m[filas.vejez.m, ]

# Filtramos la matriz de edades a partir de las personas con beneficio por vejez
edades.vejez.h <- edades.h[filas.vejez.h, ]
edades.vejez.m <- edades.m[filas.vejez.m, ]

# Calculamos en qué año ocurre el retiro por vejez para cada individuo
restantes.ret.h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Retirado")[1]
})

restantes.ret.m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Retirado")[1]
})

# Calculamos en qué año ocurre el fallecimiento para cada individuo
indices.2h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices de beneficio con ceros
matriz.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))
matriz.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Construimos la matriz de beneficios para hombres
for (i in 1:nrow(matriz.vejez.h)) {
  
  indice <- indices.2h[i]  # Año en que fallece la i-ésima persona
  
  # Se asigna 1 desde el retiro hasta justo antes del fallecimiento
  matriz.vejez.h[i, restantes.ret.h[i]:(indice - 1)] <- 1 

  edad <- edades.vejez.h[i, indice]  # Edad al fallecer

  # Se calcula la cantidad de años para simular la sobrevivencia del cónyuge
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Se extraen las probabilidades de muerte del cónyuge (mujer) por edad y año
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]

  # Se simula la vida del cónyuge comparando las probabilidades con números aleatorios
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio  # TRUE si muere

  # Se determina cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Se asigna 0.7 al beneficio durante los años en que el cónyuge está vivo
  matriz.vejez.h[i, indice:(indice + indice.3)] <- 0.7
}

# Lo mismo para mujeres
for (i in 1:nrow(matriz.vejez.m)) {
  
  indice <- indices.2m[i]
  matriz.vejez.m[i, restantes.ret.m[i]:(indice - 1)] <- 1
  
  edad <- edades.vejez.m[i, indice]
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejez.m[i, indice:(indice + indice.3)] <- 0.7
}

# Se construyen las matrices con los montos de pensión
monto.vejez.h <- matrix(pension.vejez.h, nrow(matriz.vejez.h), ncol(matriz.vejez.h))
monto.vejez.m <- matrix(pension.vejez.m, nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Multiplicamos las matrices de beneficios (0, 1, 0.7) por el monto de pensión
matriz.vejez.h <- matriz.vejez.h * monto.vejez.h
matriz.vejez.m <- matriz.vejez.m * monto.vejez.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejez.h <- pmin(matriz.vejez.h, 3500000)
matriz.vejez.m <- pmin(matriz.vejez.m, 3500000)

rm(edades.vejez.h, edades.vejez.m, monto.vejez.h, monto.vejez.m)

### Pensiones por invalidez

# Extraemos las filas correspondientes a inválidos
matriz.inv.h <- estados.h[filas.inv.h, ]
matriz.inv.m <- estados.m[filas.inv.m, ]

# Extraemos las edades correspondientes a inválidos
edades.inv.h <- edades.h[filas.inv.h, ]
edades.inv.m <- edades.m[filas.inv.m, ]

# Obtenemos el primer periodo donde se observa el estado "Fallecido"
indices.2h <- apply(matriz.inv.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.inv.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices con ceros para hombres y mujeres inválidos
matriz.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
matriz.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))

# Llenamos la matriz de hombres
for (i in 1:nrow(matriz.inv.h)) {
  
  indice <- indices.2h[i]  # Primer año de fallecimiento
  matriz.inv.h[i, restantes.inv.h[i]:(indice - 1)] <- 1  # Periodo de invalidez antes de fallecer
  
  edad <- edades.inv.h[i, indice]  # Edad al fallecer
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Obtenemos el qx del cónyuge (mujer)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  # Simulamos la vida del cónyuge con aleatoriedad
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1  # Tiempo que sobrevive el cónyuge

  # Asignamos el porcentaje de pensión según la edad
  if(edad >= 60){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)  # Máximo hasta que el hijo cumpla 25

    matriz.inv.h[i, indice:(indice + indice.4)] <- 
      matriz.inv.h[i, indice:(indice + indice.4)] + 0.3  # Agregamos el beneficio por hijo

  } else {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para las mujeres
for (i in 1:nrow(matriz.inv.m)) {
  
  indice <- indices.2m[i]
  matriz.inv.m[i, restantes.inv.m[i]:(indice - 1)] <- 1
  
  edad <- edades.inv.m[i, indice]
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)

  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Beneficio por hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.inv.m[i, indice:(indice + indice.4)] <- 
      matriz.inv.m[i, indice:(indice + indice.4)] + 0.3
    
  } else {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indices.2m[i] + 50 - edad):(indices.2m[i] + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Creamos las matrices de montos
monto.inv.h <- matrix(pension.invalidez.h, nrow(matriz.inv.h), ncol(matriz.inv.h))
monto.inv.m <- matrix(pension.invalidez.m, nrow(matriz.inv.m), ncol(matriz.inv.m))

# Aplicamos el monto a cada proporción de pensión
matriz.inv.h <- matriz.inv.h * monto.inv.h
matriz.inv.m <- matriz.inv.m * monto.inv.m

# Aplicamos el tope de pensión máximo de 3.5 millones
matriz.inv.h <- pmin(matriz.inv.h, 3500000)
matriz.inv.m <- pmin(matriz.inv.m, 3500000)

rm(edades.inv.h, edades.inv.m, monto.inv.h, monto.inv.m)

### Pensiones por sucesión

# Se inicializan matrices de ceros para guardar la sucesión de los hombres y mujeres
matriz.suc.h <- matrix(as.numeric(0), nrow(estados.h[filas.muerte.h, ]),
                       ncol(estados.h[filas.muerte.h, ]))

matriz.suc.m <- matrix(as.numeric(0), nrow(estados.m[filas.muerte.m, ]),
                       ncol(estados.m[filas.muerte.m, ]))

# Se calcula la matriz de sucesión de los hombres fallecidos
for(i in 1:nrow(matriz.suc.h)){
  
  edad <- edad.fallecido.h[i]  # Edad del hombre fallecido
  col <- col.fallecido.h[i]    # Columna donde inicia la sucesión

  # Se determina la cantidad de años a simular
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - col + 1)

  # Se obtienen las probabilidades de fallecimiento del cónyuge
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), col:(col + n - 1))]

  # Se simulan eventos aleatorios de fallecimiento del cónyuge
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio

  # Se identifica cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Asignación de porcentaje según edad al fallecer y condiciones
  if(edad >= 60){
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.h[i]){  # Si hay hijos
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.h[i, col:(col + indice.4)] <- 
      matriz.suc.h[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para mujeres
for(i in 1:nrow(matriz.suc.m)){
  
  edad <- edad.fallecido.m[i]
  col <- col.fallecido.m[i]

  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - col + 1)
  
  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), col:(col + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.m[i]){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  
    # Mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.m[i, col:(col + indice.4)] <- 
      matriz.suc.m[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se asigna el monto del beneficio base solo a los que tienen derecho a sucesión
sucesion.aux.h <- ifelse(tiene.derecho.sucesion.h, beneficio.base.h, 0)
sucesion.aux.m <- ifelse(tiene.derecho.sucesion.m, beneficio.base.m, 0)

# Se crean matrices con los montos por sucesión
monto.suc.h <- matrix(sucesion.aux.h, nrow(matriz.suc.h), ncol(matriz.suc.h))
monto.suc.m <- matrix(sucesion.aux.m, nrow(matriz.suc.m), ncol(matriz.suc.m))

# Se multiplica la proporción asignada por el monto base
matriz.suc.h <- matriz.suc.h * monto.suc.h
matriz.suc.m <- matriz.suc.m * monto.suc.m

# Se limita el monto máximo de la pensión por sucesión a 3.5 millones
matriz.suc.h <- pmin(matriz.suc.h, 3500000)
matriz.suc.m <- pmin(matriz.suc.m, 3500000)

rm(monto.suc.h, monto.suc.m, sucesion.aux.h, sucesion.aux.m)

### Pensionados iniciales

## Vejez

# Inicializamos las matrices de beneficio con ceros
matriz.vejini.h <- matrix(as.numeric(0), nrow(pensini.vej.h), ncol(edades))
matriz.vejini.m <- matrix(as.numeric(0), nrow(pensini.vej.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.vejini.h)) {
  
  edad <- edadini.vej.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.h[i, indice:(indice + indice.3)] <- 0.7
}

# Caso para mujeres
for (i in 1:nrow(matriz.vejini.m)) {
  
  edad <- edadini.vej.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.m[i, indice:(indice + indice.3)] <- 0.7
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.vejini.h <- matriz.vejini.h * pensini.vej.h
matriz.vejini.m <- matriz.vejini.m * pensini.vej.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejini.h <- pmin(matriz.vejini.h, 3500000)
matriz.vejini.m <- pmin(matriz.vejini.m, 3500000)

## Invalidez

# Inicializamos las matrices de beneficio con ceros
matriz.invini.h <- matrix(as.numeric(0), nrow(pensini.inv.h), ncol(edades))
matriz.invini.m <- matrix(as.numeric(0), nrow(pensini.inv.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.invini.h)) {
  
  edad <- edadini.inv.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.h[i, indice:(indice + indice.4)] <- 
      matriz.invini.h[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Caso para mujeres
for (i in 1:nrow(matriz.invini.m)) {
  
  edad <- edadini.inv.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.m[i, indice:(indice + indice.4)] <- 
      matriz.invini.m[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.invini.h <- matriz.invini.h * pensini.inv.h
matriz.invini.m <- matriz.invini.m * pensini.inv.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.invini.h <- pmin(matriz.invini.h, 3500000)
matriz.invini.m <- pmin(matriz.invini.m, 3500000)

## Sucesión cónyuge

# Inicializamos las matrices de beneficio con ceros
matriz.suc.ch <- matrix(as.numeric(0), nrow(pension.suc.ch), ncol(edades))
matriz.suc.cm <- matrix(as.numeric(0), nrow(pension.suc.cm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.ch)) {
  
  edad <- edad.suc.ch[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.ch[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.ch[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Caso para las mujeres
for (i in 1:nrow(matriz.suc.cm)) {
  
  edad <- edad.suc.cm[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.cm[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.cm[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.ch <- matriz.suc.ch * pension.suc.ch
matriz.suc.cm <- matriz.suc.cm * pension.suc.cm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.ch <- pmin(matriz.suc.ch, 3500000)
matriz.suc.cm <- pmin(matriz.suc.cm, 3500000)

## Sucesión hijo

# Inicializamos las matrices de beneficio con ceros
matriz.suc.hh <- matrix(as.numeric(0), nrow(pension.suc.hh), ncol(edades))
matriz.suc.hm <- matrix(as.numeric(0), nrow(pension.suc.hm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.hh)) {
  
  edad <- edad.suc.hh[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hh[i, 1:indice] <- 1  
    
  }
  
}

# Caso para mujeres
for (i in 1:nrow(matriz.suc.hm)) {
  
  edad <- edad.suc.hm[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hm[i, 1:indice] <- 1  
    
  }
  
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.hh <- matriz.suc.hh * pension.suc.hh
matriz.suc.hm <- matriz.suc.hm * pension.suc.hm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.hh <- pmin(matriz.suc.hh, 3500000)
matriz.suc.hm <- pmin(matriz.suc.hm, 3500000)

# Se juntan las matrices de sucesión por cónyuge e hijo en una sola
matriz.sucini.h <- rbind(matriz.suc.ch, matriz.suc.hh)
matriz.sucini.m <- rbind(matriz.suc.cm, matriz.suc.hm)

# Limpieza de variables temporales
rm(qx.conyuge, vect.aleatorio, estados.conyuge, indice.3, qx.hijo, estados.hijo,
   indice.4, edad, col, n, indice, qx.pensionado, estados.pensionado)

### Activo actuarial

# Se crea una lista con las matrices calculadas
matrices.pension <- list(matriz.vejez.h, matriz.vejez.m, matriz.inv.h, 
                         matriz.inv.m, matriz.suc.h, matriz.suc.m, 
                         matriz.vejini.h, matriz.vejini.m, matriz.invini.h, 
                         matriz.invini.m, matriz.sucini.h, matriz.sucini.m)

# Lista para matrices con los montos valor presente
matrices.vp <- list()

# Vector que tendrá el monto de las cotizaciones de los pensionados
cotizacion.pensiones <- rep(0, length(matrices.pension))

# Se itera sobre las matrices
for (i in 1:length(matrices.pension)) {
  
  # Se extienden las matrices de forma mensual, considerando el aguinaldo
  matrices.pension[[i]] <- t(apply(matrices.pension[[i]], 1, 
                                   function(fila) rep(fila, each = 13)))
  
  # Se obtiene el valor presente de cada matriz
  matrices.vp[[i]] <- matrices.pension[[i]] * matriz.vp[1:nrow(matrices.pension[[i]]), ]
  
  # Se determina la contribución de los pensionados
  mayores.2mill <- matrices.vp[[i]][matrices.pension[[i]] > 2000000]
  cotizacion.pensiones[i] <- sum(0.05 * mayores.2mill)
  
  # Se actualiza el monto de las pensiones correspondientes
  matrices.vp[[i]] <- matrices.vp[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
  matrices.pension[[i]] <- matrices.pension[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
}

# Se suman las cotizaciones de los pensionados de cada matriz
cotizacion.pensiones <- sum(cotizacion.pensiones)

# Se construye la matriz con los salarios totales para determinar la masa salarial
salarios.finales <- rbind(salario.estoc.h * cotizaciones.h, 
                          salario.estoc.m * cotizaciones.m)

# Se crea la matriz con los factores de descuento para determinar las cotizaciones de los trabajadores
matriz.descuento <- matrix(rep(s, times = nrow(salarios.finales)), 
                           nrow(salarios.finales), byrow = TRUE)

# Se calcula la masa salarial
masa.salarial <- sum(salarios.finales * matriz.descuento)

# Se calcula la contribución de los trabajadores
cotizacion.trab <- masa.salarial * 0.15

# Se calcula el activo actuarial
total.activo <- cotizacion.pensiones + cotizacion.trab + reserva.ini

rm(mayores.2mill)

### Flujos de balance

# Inicializamos los vectores para determinar los años críticos
reserva <- c(reserva.ini)
total.egresos <- c()
cotizaciones <- c()
rends <- c()

# Inicializamos el vector de años críticos
annos <- c(0, 0, 0)

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Cotizaciones de los trabajadores
  cotizaciones <- c(cotizaciones, (sum(salarios.finales[, i]) * 0.15))
  
  # Costo de las pensiones
  costo.pens <- Reduce("+", sapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto administrativo del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Total de egresos
  total.egresos <- c(total.egresos, costo.pens + sem)
  
  # Rendimientos
  rends <- c(rends, ifelse((reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real > 0, 
                           (reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real, 0))
  
  # Total de ingresos
  total.ingresos <- cotizaciones[i] + rends[i]
  
  # Guardamos la reserva final (reserva inicial del siguiente año)
  reserva <- c(reserva, (reserva[i] + total.ingresos - total.egresos[i] + sem))
}

# Eliminamos la última reserva final
reserva <- reserva[-length(reserva)]

# Determinamos los años críticos
idx <- which(total.egresos > cotizaciones)[1]
annos[1] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends))[1]
annos[2] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends + reserva))[1]
annos[3] <- idx + 2024

### Pasivo actuarial

# Se calcula el total de las pensiones
total.pensiones <- sum(sapply(matrices.vp, sum))

# Se calcula el monto del SEM
sem <- total.pensiones * (12/13) * 0.085

# Por último se calcula el pasivo actuarial
total.pasivo <- total.pensiones + sem

### Indicadores de solvencia

# Agregamos los indicadores a sus respectivas listas
razon.solvencia <- append(razon.solvencia, (total.activo / total.pasivo))
annos.crit <- append(annos.crit, list(annos))
balance <- append(balance, list(c(total.activo, total.pasivo)))
prima.media <- append(prima.media, ((total.pasivo - reserva.ini) / masa.salarial))

# Actualizamos los promedios para el ciclo while
prom.antes <- prom.despues
prom.despues <- mean(unlist(razon.solvencia))

# Se guardan las matrices de pensión
pensiones <- append(pensiones, matrices.vp)
}

end.time <- Sys.time()

end.time - start.time
```

Una vez el modelo haya terminado de hacer las iteraciones, se procede a determinar la tasa de ingresos, la prima de reparto y la razón de fondo de contingencias, usando las variables de la última iteración.

```{r metricas_as1}
# Inicializamos la reserva inicial en el 2025 y los vectores para las métricas
reserva <- reserva.ini
tasa.ingresos <- c()
prima.reparto <- c()
razon.fondo.cont <- c()

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Masa salarial
  ms <- sum(salarios.finales[, i])
  
  # Cotizaciones de los trabajadores
  cotizaciones <- ms * 0.15
  
  # Costo de las pensiones en cada año
  costo.pens <- Reduce("+", lapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Egresos totales
  total.egresos <- costo.pens + sem
  
  # Rendimientos
  rends <- ifelse((reserva + (cotizaciones - total.egresos) / 2) * interes.real > 0, 
                  (reserva + (cotizaciones - total.egresos) / 2) * interes.real, 0)
  
  # Ingresos totales
  total.ingresos <- cotizaciones + rends
  
  # Guardamos las métricas
  tasa.ingresos <- c(tasa.ingresos, ifelse(ms > 0, (total.ingresos / ms), NA))
  prima.reparto <- c(prima.reparto, ifelse(ms > 0, (total.egresos / ms), NA))
  razon.fondo.cont <- c(razon.fondo.cont, total.egresos / reserva)
  
  # Actualizamos la reserva inicial para el siguiente año
  reserva <- reserva + total.ingresos - total.egresos + sem
  
}
```

## Resultados de incremento de mortalidad

## Razón de solvencia

Ahora se procede con las razones de solvencia. Inicialmente, se tiene el promedio de las razones de solvencia para este caso:

```{r rs_as1}
(prom.rs <- mean(unlist(razon.solvencia)))
```

Se puede observar en un gráfico de densidad las distintas razones de solvencia.

```{r densidad_rs_as1}
# Se crea un dataframe con los datos
data.rs <- data.frame(rs = unlist(razon.solvencia))

# Gráfico de las razones de solvencia
ggplot(data.rs, aes(x = rs)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.rs,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.rs,
    y = 50,
    label = "Media de las RS",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón de solvencia",
       y = "Densidad") +
  theme_minimal()
```

## Años críticos

En primer lugar, se obtendrá un promedio de los años críticos.

```{r annos_criticos_as1}
# Se guarda como matriz
annos.crit.mat <- do.call(cbind, annos.crit)

# Se redondean los promedios
round(rowMeans(annos.crit.mat, na.rm = TRUE), 0)
```

Los anteriores están ordenados en primer, segundo y tercer año crítico respectivamente. Si los resultados son **NaN** significa que en ningún caso se llega a ese año crítico.

Para el caso en estudio, usualmente solo se llega al primer año crítico entre las iteraciones, por lo que se grafica ese caso.

```{r grafico_annos_criticos_as1}
# Se guardan los primeros años críticos en un DataFrame
df.annos.crit <- data.frame(primer_momento = annos.crit.mat[1, ])

# Se grafican los primeros momentos correspondientes
ggplot(df.annos.crit, aes(x = primer_momento)) +
  geom_histogram(
    aes(y = after_stat(count / sum(count))),
    bins = 2,
    fill = "#A34022",
    color = "black"
  ) +
  labs(x = "Año",
       y = "Densidad")
theme_minimal()
```

## Prima media

Como se menciona en el reglamento, se procede con la prima media. Inicialmente se obtiene el promedio de estas:

```{r prima_media_as1}
(prom.pm <- mean(unlist(prima.media)))
```

Un análisis más detallado se observa en el siguiente gráfico:

```{r grafico_prima_media_as1}
# Se crea un dataframe con los datos
data.pm <- data.frame(pm = unlist(prima.media))

# Gráfico de las primas medias niveladas
ggplot(data.pm, aes(x = pm)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pm,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pm,
    y = 20,
    label = "Promedio de la prima media",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima media nivelada",
       y = "Densidad") +
  theme_minimal()
```

## Razón del fondo de contingencia

Se muestra la razón del fondo de contingencia de la última simulación, visualizada en un gráfico.

```{r grafico_rc_as1}
# Se crea un dataframe con los datos
data.rc <- data.frame(rc = razon.fondo.cont)

# Gráfico de las razones del fondo de contingencia
ggplot(data.rc, aes(x = rc)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = mean(razon.fondo.cont),
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = mean(razon.fondo.cont),
    y = 100,
    label = "Media de la RC",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón del fondo de contingencia",
       y = "Densidad") +
  theme_minimal()
```

Una vez más, se aprecia que la reserva es muy grande en comparación con los egresos, lo cual produce resultados muy cercanos a 0 para esta métrica.

## Tasa de ingresos

La tasa de ingresos se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_as1}
(prom.ti <- mean(tasa.ingresos, na.rm = TRUE))
```

Se observan los resultados en un gráfico.

```{r grafico_ti_as1}
# Se crea un dataframe con los datos
data.ti <- data.frame(ti = tasa.ingresos)

# Gráfico de las razones del fondo de contingencia
ggplot(data.ti, aes(x = ti)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.ti,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.ti,
    y = 0.002,
    label = "Media de la TI",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Tasa de ingresos",
       y = "Densidad") +
  theme_minimal()
```

Los primeros valores están entre 10 y 20, lo cual condiciona mucho el gráfico.

## Prima de reparto

La prima de reparto se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_as1}
(prom.pr <- mean(prima.reparto, na.rm = TRUE))
```

Se observa el comportamiento en un gráfico.

```{r grafico_pr_as1}
# Se crea un dataframe con los datos
data.pr <- data.frame(pr = prima.reparto)

# Gráfico de las razones del fondo de contingencia
ggplot(data.pr, aes(x = pr)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pr,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pr,
    y = 0.04,
    label = "Media de la prima de reparto",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima de reparto",
       y = "Densidad") +
  theme_minimal()
```

Se observa que muchos de los valores son menores a 1. Incluso, más del $75\%$ tienen menos de 2 dígitos.

## Balance

El promedio del activo y del pasivo a lo largo de las iteraciones se muestra a continuación.

```{r prom_balance_as1}
# Se obtienen los valores en una matriz
matriz.balance <- do.call(cbind, balance)

# Promedio del activo y del pasivo respectivamente
rowMeans(matriz.balance)
```

Seguidamente, como pide el reglamento, se muestran las pensiones separadas por generaciones y por razón de salida.

```{r pasivo_separado_as1}
# Se defina una matriz para obtener los montos
matriz.pasivo <- matrix(0, nrow = 6, ncol = (length(pensiones) / 12))

# Se obtienen los montos con un ciclo
for (i in 1:ncol(matriz.pasivo)) {
  # Se hace la suma de la iteración correspondiente
  suma.iter <- sapply(pensiones[(1+(i*12 - 12)):(12*i)], sum)
  
  # Se actualiza la matriz
  matriz.pasivo[, i] <-
    c((suma.iter[1] + suma.iter[2]),
      (suma.iter[3] + suma.iter[4]),
      (suma.iter[5] + suma.iter[6]),
      (suma.iter[7] + suma.iter[8]),
      (suma.iter[9] + suma.iter[10]),
      (suma.iter[11] + suma.iter[12]))
}

# Se pone la información en un dataframe
(
  df.pasivo <-
    data.frame(
      "Generación actual" = c(rowMeans(matriz.pasivo)[1:3], sum(rowMeans(matriz.pasivo)[1:3])),
      "Generación pensionada" = c(rowMeans(matriz.pasivo)[4:6], sum(rowMeans(matriz.pasivo)[4:6])),
      row.names = c("Vejez", "Invalidez", "Sucesion", "Total")
    )
)
```


Lo anterior se muestra en el siguiente gráfico.

```{r grafico_balance_as1}
# Se pone la información en un dataframe
df.balance <- data.frame(valor = rowMeans(matriz.balance),
                         categoria = c("Activo", "Pasivo"))

# Gráfico del balance
ggplot(df.balance, aes(x = categoria, y = (valor / 1000000000))) +
  geom_bar(stat = "identity", fill = "#A34022") +
  labs(x = "Categoría del balance", y = "Valor (Miles de millones de colones)") +
  theme_minimal()
```


estos se muestran por separado, tal y como menciona el reglamento. Esto representa el promedio del valor presente de todos los activos y pasivos, respectivamente, de los 95 años proyectados.

## Decremento en las tasas de mortalidad

Se debe proceder a modificar la mortalidad en las variables correspondientes.

```{r mortalidad_as2}
# Se obtiene la mortalidad original
mortalidad <- read_excel("data/mortalidad.xls")

# Se cambia el formato necesario
mortalidad$qx <- as.numeric(mortalidad$qx)

# Se guarda como DataTable
mortalidad <- setDT(mortalidad)

# Se desciende la mortalidad en cada caso
mortalidad$qx <- mortalidad$qx * 0.95

# Se pone el tope de 1 la la mortalidad
mortalidad$qx <- ifelse(mortalidad$qx == 0.95, 1, mortalidad$qx)

# Para las probabilidades de muerte, se inicia creando las matrices vacías
mort.h <- matrix(0, nrow = nrow(edades.h), ncol = ncol(edades.h))
mort.m <- matrix(0, nrow = nrow(edades.m), ncol = ncol(edades.m))

# Se corrigen los nombres de sus columnas
colnames(mort.h) <- colnames(edades.h)
colnames(mort.m) <- colnames(edades.m)

# Se agregan las probabilidades por cada año (columna), para ambos sexos
for (i in 1:ncol(mort.h)) {
  mort.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.h)[i])][.(edad = edades.h[, i]), 
                                                         on = .(edad), qx]
  mort.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.m)[i])][.(edad = edades.m[, i]), 
                                                         on = .(edad), qx]
}

# Se corrigen las mortalidades para derechos sucesorios
mort.completa.h <- matrix(0, length(ages), ncol(edades))
mort.completa.m <- matrix(0, length(ages), ncol(edades))

colnames(mort.completa.h) <- colnames(edades)
colnames(mort.completa.m) <- colnames(edades)

for (i in 1:ncol(mort.completa.h)) {
  
  mort.completa.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.completa.h)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
  mort.completa.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.completa.m)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
}

mort.completa.h[is.na(mort.completa.h)] <- 1
mort.completa.m[is.na(mort.completa.m)] <- 1

mort.hijos <- 0.5 * (mort.completa.h + mort.completa.m)
```

Posteriormente, se tiene un modelo idéntico. Iniciamos con las listas.

```{r listas_iniciales_as2}
razon.solvencia <- list()
annos.crit <- list()
balance <- list()
prima.media <- list()
beneficio.devengado.vejez <- list()
beneficio.devengado.invalidez <- list()
beneficio.devengado.sucesion <- list()
pensiones <- list()

# Inicializamos los promedios para asegurarnos de que se harán mínimo 2 iteraciones
prom.antes <- 0
prom.despues <- 1
```

Con esto, se procede con el modelo en sí.

```{r estocastico_as2, echo = FALSE}
start.time <- Sys.time()

while(abs(prom.despues - prom.antes) >= 0.00001){
  
# Se crean dos matrices aleatorias usando distribución Uniforme(0, 1)
matriz.aleatoria.h <- matrix(runif(nrow(cotizantes.h) * ncol(mort.h)), 
                             nrow(cotizantes.h), ncol(mort.h))

matriz.aleatoria.m <- matrix(runif(nrow(cotizantes.m) * ncol(mort.m)), 
                             nrow(cotizantes.m), ncol(mort.m))

# Se continúa con las matrices de probabilidades de postergación
postergacion.simulada.h <- matriz.aleatoria.h < df.probabilidad.postergacion.h
postergacion.simulada.m <- matriz.aleatoria.m < df.probabilidad.postergacion.m

# Se corrigen las postergaciones incorrectas
postergacion.simulada.h <-
  t(apply(postergacion.simulada.h, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))
postergacion.simulada.m <-
  t(apply(postergacion.simulada.m, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))

# Matrices de números uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <-
  inv.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.h[[2]] <-
  mort.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.m[[1]] <-
  inv.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

lista.estados.m[[2]] <-
  mort.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Se hacen las correcciones, para que si entra en un estado se mantenga en él durante el tiempo
lista.estados.h[[1]] <-
  t(apply(lista.estados.h[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.h[[2]] <-
  t(apply(lista.estados.h[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[1]] <-
  t(apply(lista.estados.m[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[2]] <-
  t(apply(lista.estados.m[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))

# Se hace la matriz con los estados de cada persona, separando por sexo
estados.h <-
  ifelse(lista.estados.h[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.h[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.h == 1) * (cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 1,
           "Posterga",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 1)) == 1,
           "Activo",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 0)) == 1, "Inactivo", ifelse(
             edades.h > 64,
             "Retirado",
             ifelse(actividad.h == 1, "Activo", "Inactivo")
           ))
           ))
         ))
estados.m <-
  ifelse(lista.estados.m[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.m[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 404) * (edades.m == 63)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 356) * (edades.m == 64)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 179) * (edades.m > 64)
           ) == 1,
           "Posterga",
           ifelse(
             ((edades.m == 63) * (cotizaciones.acum.m > 404)) == 1,
             "Retirado",
             ifelse(((edades.m == 64) * (cotizaciones.acum.m > 356)
             ) == 1, "Retirado", ifelse(((edades.m > 64) * (cotizaciones.acum.m > 179)) == 1,
                                        "Retirado",
                                        ifelse(actividad.m == 1, "Activo", "Inactivo")
             ))
           ))
           ))
         ))

# Existe el caso en donde una persona retirada puede quedar inválida posteriormente, por lo que se corrije dicho escenario
estados.h <- t(apply(estados.h, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))

# Ahora, existe el caso en donde una persona retirada puede postergar, por lo que se corrije ese caso
estados.h <- t(apply(estados.h, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))

# Se obtiene el salario, separado por sexo
salario.estoc.h <-
  salarios.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
salario.estoc.m <-
  salarios.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Obtenemos las razones de salida, separado por sexo
salida.h <- apply(estados.h, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})
salida.m <- apply(estados.m, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})

# Cotizaciones reales
cotizaciones.h <- matriz.cot.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
cotizaciones.m <- matriz.cot.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Consideramos la cantidad final de cuotas, separada por sexo
cuotas.finales.h <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + rowSums(cotizaciones.h)
cuotas.finales.m <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + rowSums(cotizaciones.m)

# Vamos a obtener los salarios de cada persona, separado por sexo, de la parte estocástica
salarios.aux.h <- do.call(rbind, lapply(1:nrow(salario.estoc.h), function(i) {
  unlist(lapply(1:ncol(salario.estoc.h), function(j) {
    c(rep(salario.estoc.h[i, j], times = cotizaciones.h[i, j]),
      rep(0, 12 - cotizaciones.h[i, j]))
  }))
}))
salarios.aux.m <- do.call(rbind, lapply(1:nrow(salario.estoc.m), function(i) {
  unlist(lapply(1:ncol(salario.estoc.m), function(j) {
    c(rep(salario.estoc.m[i, j], times = cotizaciones.m[i, j]),
      rep(0, 12 - cotizaciones.m[i, j]))
  }))
}))

# Se juntan las matrices de salarios
matriz.salarios.h <- cbind(cotizantes.h, salarios.aux.h)
matriz.salarios.m <- cbind(cotizantes.m, salarios.aux.m)

# Obtenemos los mejores salarios ordenados (pueden incluir 0), separados por sexo
salarios.top.h <- t(apply(matriz.salarios.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))
salarios.top.m <- t(apply(matriz.salarios.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))

# Identificamos las diferencias entre los salarios
diferencias.h <- t(apply(salarios.top.h, 1, function(fila) {
  abs(diff(fila))
}))
diferencias.m <- t(apply(salarios.top.m, 1, function(fila) {
  abs(diff(fila))
}))

# Cantidad de columnas en las diferencias
columnas.diff <- ncol(diferencias.h) - 1

# Un salario será atípico si es mayor a 5 millones y tiene menos de 12 salarios en un rango de 500 000 colones con ese monto o tiene un salario con una diferencia de más de 500 000 colones al siguiente 
# Iniciamos viendo las diferencias
atipicos.h <- t(apply(diferencias.h, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))
atipicos.m <- t(apply(diferencias.m, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))

# Ahora consideramos los atípicos en la matriz de salarios, considerando aquellos que son de más de 5 millones
salarios.top.h <-
  salarios.top.h[, -ncol(salarios.top.h)] * !(atipicos.h * (salarios.top.h[, -ncol(salarios.top.h)] > 5000000))
salarios.top.m <-
  salarios.top.m[, -ncol(salarios.top.m)] * !(atipicos.m * (salarios.top.m[, -ncol(salarios.top.m)] > 5000000))

# Se sacan los 300 mejores salarios, ahora sin los salarios atípicos
salarios.top.h <- t(apply(salarios.top.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))
salarios.top.m <- t(apply(salarios.top.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))

# Beneficio por vejez, separado por sexo
beneficio.vejez.h <-
  (pmin(300, cuotas.finales.h[which(salida.h == "Retirado")]) / 300) * (rowSums(salarios.top.h[which(salida.h == "Retirado"),]) / rowSums(salarios.top.h[which(salida.h == "Retirado"),] > 9999))
# Hacer la corrección a estados M, en donde las mujeres pueden retirarse a partir de los 63 si cumplen los requisitos
beneficio.vejez.m <-
  (pmin(300, cuotas.finales.m[which(salida.m == "Retirado")]) / 300) * (rowSums(salarios.top.m[which(salida.m == "Retirado"),]) / rowSums(salarios.top.m[which(salida.m == "Retirado"),] > 9999))

# Filas de invalidez
filas.inv.h <- which(salida.h == "Invalido")
filas.inv.m <- which(salida.m == "Invalido")

# Para el beneficio por invalidez, separado por sexo, iniciamos obteniendo la casilla en donde quedaron inválidos
restantes.inv.h <-
  apply(estados.h[filas.inv.h, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })
restantes.inv.m <-
  apply(estados.m[filas.inv.m, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })

# Se compara si se han tenido las cuotas necesarias
cuotas.binario.h <- mapply(function(i, j) {
  requisitos.inv.h[i, j] <= cuotas.finales.h[i]
}, i = filas.inv.h, j = restantes.inv.h)
cuotas.binario.m <- mapply(function(i, j) {
  requisitos.inv.m[i, j] <= cuotas.finales.m[i]
}, i = filas.inv.m, j = restantes.inv.m)

# Se obtienen las edades para las cuales se invalidó la persona (se pone acá y se borra la anterior que estaba)
edad.final.h <- restantes.inv.h + edades.h[filas.inv.h, 1] - 1
edad.final.m <- restantes.inv.m + edades.m[filas.inv.m, 1] - 1

# En este punto, se ve si las personas pensionadas por invalidez tienen las cuotas necesarias según el inciso b del artículo 6
requisito.cuotas.h <-
  (ifelse(
    ((restantes.inv.h == 1) * (edad.final.h < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.h == 2) * (edad.final.h < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
      ifelse((edad.final.h < 48), rowSums(cotizaciones.h[filas.inv.h, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.h == 1) * (edad.final.h > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.h == 2) * (edad.final.h > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 325:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
                           ifelse(((restantes.inv.h == 3) * (edad.final.h > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:2]),
                                  ifelse(((restantes.inv.h == 4) * (edad.final.h > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:3]),
                                         ifelse((edad.final.h > 47) == 1, rowSums(cotizaciones.h[filas.inv.h, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23
requisito.cuotas.m <-
  (ifelse(
    ((restantes.inv.m == 1) * (edad.final.m < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.m == 2) * (edad.final.m < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
      ifelse((edad.final.m < 48), rowSums(cotizaciones.m[filas.inv.m, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.m == 1) * (edad.final.m > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.m == 2) * (edad.final.m > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 325:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
                           ifelse(((restantes.inv.m == 3) * (edad.final.m > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:2]),
                                  ifelse(((restantes.inv.m == 4) * (edad.final.m > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:3]),
                                         ifelse((edad.final.m > 47) == 1, rowSums(cotizaciones.m[filas.inv.m, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23

# Si una persona inválida tiene las cuotas necesarias para su edad y cotizó 12 veces en los últimos 24 meses, tiene derecho a recibir pensión
resultado.binario.h <- cuotas.binario.h * requisito.cuotas.h
resultado.binario.m <- cuotas.binario.m * requisito.cuotas.m

# Beneficios por invalidez
beneficio.invalidez.h <-
  ifelse(cuotas.finales.h[filas.inv.h] > 299,
         (rowSums(salarios.top.h[filas.inv.h, ]) / 300),
         ifelse(cuotas.finales.h[filas.inv.h] > 179, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), ifelse(((cuotas.finales.h[filas.inv.h] < 180) * (resultado.binario.h == 1)
         ) == 1, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), 0)))
beneficio.invalidez.m <-
  ifelse(cuotas.finales.m[filas.inv.m] > 299,
         (rowSums(salarios.top.m[filas.inv.m, ]) / 300),
         ifelse(cuotas.finales.m[filas.inv.m] > 179, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), ifelse(((cuotas.finales.m[filas.inv.m] < 180) * (resultado.binario.m == 1)
         ) == 1, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), 0)))

# Primero, los índices de las personas que mueren
filas.muerte.h <- which(salida.h == "Fallecido")
filas.muerte.m <- which(salida.m == "Fallecido")

# Se identifican las columnas en la que ocurre la muerte (el año)
col.fallecido.h <-
  apply(estados.h[filas.muerte.h,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

col.fallecido.m <-
  apply(estados.m[filas.muerte.m,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

# Edad de la persona al morir para cada sexo
edad.fallecido.h <-
  mapply(function(i, j)
    edades.h[i, j], i = filas.muerte.h, j = col.fallecido.h)

edad.fallecido.m <-
  mapply(function(i, j)
    edades.m[i, j], i = filas.muerte.m, j = col.fallecido.m)

# Se crean dos vectores donde se identifica si al momento de la muerte el afiliado tenía un hijo
hijos.h <- edad.fallecido.h >= 25 & (edad.fallecido.h - 25) < 25
hijos.m <- edad.fallecido.m >= 25 & (edad.fallecido.m - 25) < 25

# Se calcula la pensión sucesoria con base en la pensión por vejez que hubiera recibido (art. 27)
salarios.sucesion.h <- salarios.top.h[filas.muerte.h,]
salarios.sucesion.m <- salarios.top.m[filas.muerte.m,]

beneficio.base.h <- rowSums(salarios.sucesion.h) / rowSums(salarios.top.h[which(salida.h == "Fallecido"),] > 9999)
beneficio.base.m <- rowSums(salarios.sucesion.m) / rowSums(salarios.top.m[which(salida.m == "Fallecido"),] > 9999)

# Se calcula el porcentaje para pensión por viudez según edad del cónyuge por art. 27: 70% si cónyuge ≥ 60, 60% si 50–59, 50% si < 50
porcentaje.viudez.h <- ifelse(edad.fallecido.h >= 60,
                              0.70,
                              ifelse(edad.fallecido.h >= 50, 0.60, 0.50))

porcentaje.viudez.m <- ifelse(edad.fallecido.m >= 60,
                              0.70,
                              ifelse(edad.fallecido.m >= 50, 0.60, 0.50))

# Así como el porcentaje para pensión por orfandad (30% si el hijo califica) art. 27: 30% para hijos menores de 25 años
porcentaje.hijo.h <- ifelse(hijos.h, 0.30, 0)
porcentaje.hijo.m <- ifelse(hijos.m, 0.30, 0)

# Se calcula el beneficio por sucesión (sin validar aún si tiene derecho)
beneficio.conyuge.h <- beneficio.base.h * porcentaje.viudez.h
beneficio.conyuge.m <- beneficio.base.m * porcentaje.viudez.m

beneficio.hijo.h <- beneficio.base.h * porcentaje.hijo.h
beneficio.hijo.m <- beneficio.base.m * porcentaje.hijo.m

# Se verifica si tiene derecho al beneficio por sucesion (art. 18)

# Condición 1: tener al menos 180 cotizaciones totales
requisito.180.h <- cuotas.finales.h[filas.muerte.h] >= 180
requisito.180.m <- cuotas.finales.m[filas.muerte.m] >= 180

# Condición 2: haber cotizado al menos 12 veces en los últimos 24 meses antes de morir, si murió antes de los 24 meses simulados se usan los datos anteriores que están en la base

requisito.24meses.h <-
  ifelse(
    col.fallecido.h == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 337:360] > 10000),
    ifelse(
      col.fallecido.h == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 349:360] > 10000) + cotizaciones.h[filas.muerte.h, 1],
      rowSums(cotizaciones.h[filas.muerte.h, 1:2])
    )
  ) > 11

requisito.24meses.m <-
  ifelse(
    col.fallecido.m == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 337:360] > 10000),
    ifelse(
      col.fallecido.m == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 349:360] > 10000) + cotizaciones.m[filas.muerte.m, 1],
      rowSums(cotizaciones.m[filas.muerte.m, 1:2])
    )
  ) > 11

# Debe de cumplir ambos requisitos
tiene.derecho.sucesion.h <- requisito.180.h & requisito.24meses.h
tiene.derecho.sucesion.m <- requisito.180.m & requisito.24meses.m

# Se verifica si califica para el derecho o no. En caso de que no se asigna un beneficio = 0
beneficio.conyuge.h <-
  ifelse(tiene.derecho.sucesion.h, beneficio.conyuge.h, 0)
beneficio.hijo.h    <-
  ifelse(tiene.derecho.sucesion.h, beneficio.hijo.h, 0)

beneficio.conyuge.m <-
  ifelse(tiene.derecho.sucesion.m, beneficio.conyuge.m, 0)
beneficio.hijo.m    <-
  ifelse(tiene.derecho.sucesion.m, beneficio.hijo.m, 0)

# Las filas de personas que se retiraron
filas.vejez.h <- which(salida.h == "Retirado")
filas.vejez.m <- which(salida.m == "Retirado")

# Los salario promedio base (prom. de 300 mejores salarios)
salario.referencia.h <- beneficio.vejez.h
salario.referencia.m <- beneficio.vejez.m

# La cuantía básica según salario
cuantia.vejez.h <- cuantia.basica(salario.referencia.h)
cuantia.vejez.m <- cuantia.basica(salario.referencia.m)

# La bonificación por cotizaciones adicionales (exceso sobre 300)
meses.extra.h <- pmax(0, cuotas.finales.h[filas.vejez.h] - 300)
meses.extra.m <- pmax(0, cuotas.finales.m[filas.vejez.m] - 300)
bono.cuotas.h <- meses.extra.h * bono.cotizaciones
bono.cuotas.m <- meses.extra.m * bono.cotizaciones

# La bonificación por postergación (meses en estado "Posterga")
meses.post.h <- 12 * rowSums(postergacion.simulada.h[filas.vejez.h, ])
meses.post.m <- 12 * rowSums(postergacion.simulada.m[filas.vejez.m, ])
bono.post.h <- meses.post.h * bono.postergacion
bono.post.m <- meses.post.m * bono.postergacion

# La tasa de reemplazo final
tasa.vejez.h <- cuantia.vejez.h + bono.cuotas.h + bono.post.h
tasa.vejez.m <- cuantia.vejez.m + bono.cuotas.m + bono.post.m

# Pensión final por vejez
pension.vejez.h <- salario.referencia.h * pmin(tasa.vejez.h, tasa.maxima)
pension.vejez.m <- salario.referencia.m * pmin(tasa.vejez.m, tasa.maxima)

# El salario base
salario.referencia.inv.h <- beneficio.invalidez.h
salario.referencia.inv.m <- beneficio.invalidez.m

# La cuantía básica
cuantia.invalidez.h <- cuantia.basica(salario.referencia.inv.h)
cuantia.invalidez.m <- cuantia.basica(salario.referencia.inv.m)

# La bonificación por cuotas (más de 300)
meses.extra.inv.h <- pmax(0, cuotas.finales.h[filas.inv.h] - 300)
meses.extra.inv.m <- pmax(0, cuotas.finales.m[filas.inv.m] - 300)
bono.cuotas.inv.h <- meses.extra.inv.h * bono.cotizaciones
bono.cuotas.inv.m <- meses.extra.inv.m * bono.cotizaciones

# La tasa de reemplazo
tasa.invalidez.h <- cuantia.invalidez.h + bono.cuotas.inv.h
tasa.invalidez.m <- cuantia.invalidez.m + bono.cuotas.inv.m

# La pensión por invalidez
pension.invalidez.h <- salario.referencia.inv.h * pmin(tasa.invalidez.h, tasa.maxima)
pension.invalidez.m <- salario.referencia.inv.m * pmin(tasa.invalidez.m, tasa.maxima)

# La pensión por sucesión
pension.sucesion.h <- beneficio.conyuge.h + beneficio.hijo.h
pension.sucesion.m <- beneficio.conyuge.m + beneficio.hijo.m

### Pensiones por vejez

# Filtramos la matriz de estados a partir de las personas con beneficio por vejez
matriz.vejez.h <- estados.h[filas.vejez.h, ]
matriz.vejez.m <- estados.m[filas.vejez.m, ]

# Filtramos la matriz de edades a partir de las personas con beneficio por vejez
edades.vejez.h <- edades.h[filas.vejez.h, ]
edades.vejez.m <- edades.m[filas.vejez.m, ]

# Calculamos en qué año ocurre el retiro por vejez para cada individuo
restantes.ret.h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Retirado")[1]
})

restantes.ret.m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Retirado")[1]
})

# Calculamos en qué año ocurre el fallecimiento para cada individuo
indices.2h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices de beneficio con ceros
matriz.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))
matriz.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Construimos la matriz de beneficios para hombres
for (i in 1:nrow(matriz.vejez.h)) {
  
  indice <- indices.2h[i]  # Año en que fallece la i-ésima persona
  
  # Se asigna 1 desde el retiro hasta justo antes del fallecimiento
  matriz.vejez.h[i, restantes.ret.h[i]:(indice - 1)] <- 1 

  edad <- edades.vejez.h[i, indice]  # Edad al fallecer

  # Se calcula la cantidad de años para simular la sobrevivencia del cónyuge
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Se extraen las probabilidades de muerte del cónyuge (mujer) por edad y año
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]

  # Se simula la vida del cónyuge comparando las probabilidades con números aleatorios
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio  # TRUE si muere

  # Se determina cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Se asigna 0.7 al beneficio durante los años en que el cónyuge está vivo
  matriz.vejez.h[i, indice:(indice + indice.3)] <- 0.7
}

# Lo mismo para mujeres
for (i in 1:nrow(matriz.vejez.m)) {
  
  indice <- indices.2m[i]
  matriz.vejez.m[i, restantes.ret.m[i]:(indice - 1)] <- 1
  
  edad <- edades.vejez.m[i, indice]
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejez.m[i, indice:(indice + indice.3)] <- 0.7
}

# Se construyen las matrices con los montos de pensión
monto.vejez.h <- matrix(pension.vejez.h, nrow(matriz.vejez.h), ncol(matriz.vejez.h))
monto.vejez.m <- matrix(pension.vejez.m, nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Multiplicamos las matrices de beneficios (0, 1, 0.7) por el monto de pensión
matriz.vejez.h <- matriz.vejez.h * monto.vejez.h
matriz.vejez.m <- matriz.vejez.m * monto.vejez.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejez.h <- pmin(matriz.vejez.h, 3500000)
matriz.vejez.m <- pmin(matriz.vejez.m, 3500000)

rm(edades.vejez.h, edades.vejez.m, monto.vejez.h, monto.vejez.m)

### Pensiones por invalidez

# Extraemos las filas correspondientes a inválidos
matriz.inv.h <- estados.h[filas.inv.h, ]
matriz.inv.m <- estados.m[filas.inv.m, ]

# Extraemos las edades correspondientes a inválidos
edades.inv.h <- edades.h[filas.inv.h, ]
edades.inv.m <- edades.m[filas.inv.m, ]

# Obtenemos el primer periodo donde se observa el estado "Fallecido"
indices.2h <- apply(matriz.inv.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.inv.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices con ceros para hombres y mujeres inválidos
matriz.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
matriz.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))

# Llenamos la matriz de hombres
for (i in 1:nrow(matriz.inv.h)) {
  
  indice <- indices.2h[i]  # Primer año de fallecimiento
  matriz.inv.h[i, restantes.inv.h[i]:(indice - 1)] <- 1  # Periodo de invalidez antes de fallecer
  
  edad <- edades.inv.h[i, indice]  # Edad al fallecer
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Obtenemos el qx del cónyuge (mujer)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  # Simulamos la vida del cónyuge con aleatoriedad
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1  # Tiempo que sobrevive el cónyuge

  # Asignamos el porcentaje de pensión según la edad
  if(edad >= 60){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)  # Máximo hasta que el hijo cumpla 25

    matriz.inv.h[i, indice:(indice + indice.4)] <- 
      matriz.inv.h[i, indice:(indice + indice.4)] + 0.3  # Agregamos el beneficio por hijo

  } else {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para las mujeres
for (i in 1:nrow(matriz.inv.m)) {
  
  indice <- indices.2m[i]
  matriz.inv.m[i, restantes.inv.m[i]:(indice - 1)] <- 1
  
  edad <- edades.inv.m[i, indice]
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)

  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Beneficio por hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo >= vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.inv.m[i, indice:(indice + indice.4)] <- 
      matriz.inv.m[i, indice:(indice + indice.4)] + 0.3
    
  } else {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indices.2m[i] + 50 - edad):(indices.2m[i] + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Creamos las matrices de montos
monto.inv.h <- matrix(pension.invalidez.h, nrow(matriz.inv.h), ncol(matriz.inv.h))
monto.inv.m <- matrix(pension.invalidez.m, nrow(matriz.inv.m), ncol(matriz.inv.m))

# Aplicamos el monto a cada proporción de pensión
matriz.inv.h <- matriz.inv.h * monto.inv.h
matriz.inv.m <- matriz.inv.m * monto.inv.m

# Aplicamos el tope de pensión máximo de 3.5 millones
matriz.inv.h <- pmin(matriz.inv.h, 3500000)
matriz.inv.m <- pmin(matriz.inv.m, 3500000)

rm(edades.inv.h, edades.inv.m, monto.inv.h, monto.inv.m)

### Pensiones por sucesión

# Se inicializan matrices de ceros para guardar la sucesión de los hombres y mujeres
matriz.suc.h <- matrix(as.numeric(0), nrow(estados.h[filas.muerte.h, ]),
                       ncol(estados.h[filas.muerte.h, ]))

matriz.suc.m <- matrix(as.numeric(0), nrow(estados.m[filas.muerte.m, ]),
                       ncol(estados.m[filas.muerte.m, ]))

# Se calcula la matriz de sucesión de los hombres fallecidos
for(i in 1:nrow(matriz.suc.h)){
  
  edad <- edad.fallecido.h[i]  # Edad del hombre fallecido
  col <- col.fallecido.h[i]    # Columna donde inicia la sucesión

  # Se determina la cantidad de años a simular
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - col + 1)

  # Se obtienen las probabilidades de fallecimiento del cónyuge
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), col:(col + n - 1))]

  # Se simulan eventos aleatorios de fallecimiento del cónyuge
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio

  # Se identifica cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Asignación de porcentaje según edad al fallecer y condiciones
  if(edad >= 60){
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.h[i]){  # Si hay hijos
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.h[i, col:(col + indice.4)] <- 
      matriz.suc.h[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para mujeres
for(i in 1:nrow(matriz.suc.m)){
  
  edad <- edad.fallecido.m[i]
  col <- col.fallecido.m[i]

  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - col + 1)
  
  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), col:(col + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.m[i]){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  
    # Mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.m[i, col:(col + indice.4)] <- 
      matriz.suc.m[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se asigna el monto del beneficio base solo a los que tienen derecho a sucesión
sucesion.aux.h <- ifelse(tiene.derecho.sucesion.h, beneficio.base.h, 0)
sucesion.aux.m <- ifelse(tiene.derecho.sucesion.m, beneficio.base.m, 0)

# Se crean matrices con los montos por sucesión
monto.suc.h <- matrix(sucesion.aux.h, nrow(matriz.suc.h), ncol(matriz.suc.h))
monto.suc.m <- matrix(sucesion.aux.m, nrow(matriz.suc.m), ncol(matriz.suc.m))

# Se multiplica la proporción asignada por el monto base
matriz.suc.h <- matriz.suc.h * monto.suc.h
matriz.suc.m <- matriz.suc.m * monto.suc.m

# Se limita el monto máximo de la pensión por sucesión a 3.5 millones
matriz.suc.h <- pmin(matriz.suc.h, 3500000)
matriz.suc.m <- pmin(matriz.suc.m, 3500000)

rm(monto.suc.h, monto.suc.m, sucesion.aux.h, sucesion.aux.m)

### Pensionados iniciales

## Vejez

# Inicializamos las matrices de beneficio con ceros
matriz.vejini.h <- matrix(as.numeric(0), nrow(pensini.vej.h), ncol(edades))
matriz.vejini.m <- matrix(as.numeric(0), nrow(pensini.vej.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.vejini.h)) {
  
  edad <- edadini.vej.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.h[i, indice:(indice + indice.3)] <- 0.7
}

# Caso para mujeres
for (i in 1:nrow(matriz.vejini.m)) {
  
  edad <- edadini.vej.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.vejini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejini.m[i, indice:(indice + indice.3)] <- 0.7
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.vejini.h <- matriz.vejini.h * pensini.vej.h
matriz.vejini.m <- matriz.vejini.m * pensini.vej.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejini.h <- pmin(matriz.vejini.h, 3500000)
matriz.vejini.m <- pmin(matriz.vejini.m, 3500000)

## Invalidez

# Inicializamos las matrices de beneficio con ceros
matriz.invini.h <- matrix(as.numeric(0), nrow(pensini.inv.h), ncol(edades))
matriz.invini.m <- matrix(as.numeric(0), nrow(pensini.inv.m), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.invini.h)) {
  
  edad <- edadini.inv.h[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.h[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.h[i, indice:(indice + indice.4)] <- 
      matriz.invini.h[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Caso para mujeres
for (i in 1:nrow(matriz.invini.m)) {
  
  edad <- edadini.inv.m[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1]
  edad <- edad + indice
  
  matriz.invini.m[i, 1:(indice - 1)] <- 1 
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge >= vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 60){
    
    matriz.invini.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    estados.hijo <- qx.hijo >= vect.aleatorio
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.invini.m[i, indice:(indice + indice.4)] <- 
      matriz.invini.m[i, indice:(indice + indice.4)] + 0.3

  } else {
    
    matriz.invini.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.invini.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.invini.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.invini.h <- matriz.invini.h * pensini.inv.h
matriz.invini.m <- matriz.invini.m * pensini.inv.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.invini.h <- pmin(matriz.invini.h, 3500000)
matriz.invini.m <- pmin(matriz.invini.m, 3500000)

## Sucesión cónyuge

# Inicializamos las matrices de beneficio con ceros
matriz.suc.ch <- matrix(as.numeric(0), nrow(pension.suc.ch), ncol(edades))
matriz.suc.cm <- matrix(as.numeric(0), nrow(pension.suc.cm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.ch)) {
  
  edad <- edad.suc.ch[i]
  n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.ch[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.ch[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.ch[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.ch[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Caso para las mujeres
for (i in 1:nrow(matriz.suc.cm)) {
  
  edad <- edad.suc.cm[i]
  n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
  qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
  vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
  estados.pensionado <- qx.pensionado >= vect.aleatorio
  indice <- which(estados.pensionado == TRUE)[1] - 1
  
  matriz.suc.cm[i, 1:indice] <- 1
  
  # Asignamos el porcentaje de pensión por viudez según la edad
  if(edad >= 50 & edad < 60){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
  } else if(edad < 50){
    
    if((edad + indice) >= 60){
      
      matriz.suc.cm[i, (51 - edad):(60 - edad)] <- 0.6 / 0.5
      
      matriz.suc.cm[i, (61 - edad):indice] <- 0.7 / 0.6
      
    }
    
    if((edad + indice) >= 50 & (edad + indice) < 60){
      
      matriz.suc.cm[i, (51 - edad):indice] <- 0.6 / 0.5
      
    }
    
  }
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.ch <- matriz.suc.ch * pension.suc.ch
matriz.suc.cm <- matriz.suc.cm * pension.suc.cm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.ch <- pmin(matriz.suc.ch, 3500000)
matriz.suc.cm <- pmin(matriz.suc.cm, 3500000)

## Sucesión hijo

# Inicializamos las matrices de beneficio con ceros
matriz.suc.hh <- matrix(as.numeric(0), nrow(pension.suc.hh), ncol(edades))
matriz.suc.hm <- matrix(as.numeric(0), nrow(pension.suc.hm), ncol(edades))

# Construimos la matriz de beneficios para hombres similar a los otros casos
for (i in 1:nrow(matriz.suc.hh)) {
  
  edad <- edad.suc.hh[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.h) - edad + 1, ncol(mort.completa.h))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.h[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hh[i, 1:indice] <- 1  
    
  }
  
}

# Caso para mujeres
for (i in 1:nrow(matriz.suc.hm)) {
  
  edad <- edad.suc.hm[i]
  
  if(edad < 25){
    
    n <- min(nrow(mort.completa.m) - edad + 1, ncol(mort.completa.m))
    qx.pensionado <- sapply(0:(n - 1), 
                          function(k) mort.completa.m[edad + k, 1 + k])
    vect.aleatorio <- c(1, runif(length(qx.pensionado) - 1))
    estados.pensionado <- qx.pensionado >= vect.aleatorio
    indice <- which(estados.pensionado == TRUE)[1] - 1
    indice <- min(indice, (25 - edad), na.rm = TRUE)
    
    matriz.suc.hm[i, 1:indice] <- 1  
    
  }
  
}

# Multiplicamos las matrices de beneficios por el monto de pensión
matriz.suc.hh <- matriz.suc.hh * pension.suc.hh
matriz.suc.hm <- matriz.suc.hm * pension.suc.hm

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.suc.hh <- pmin(matriz.suc.hh, 3500000)
matriz.suc.hm <- pmin(matriz.suc.hm, 3500000)

# Se juntan las matrices de sucesión por cónyuge e hijo en una sola
matriz.sucini.h <- rbind(matriz.suc.ch, matriz.suc.hh)
matriz.sucini.m <- rbind(matriz.suc.cm, matriz.suc.hm)

# Limpieza de variables temporales
rm(qx.conyuge, vect.aleatorio, estados.conyuge, indice.3, qx.hijo, estados.hijo,
   indice.4, edad, col, n, indice, qx.pensionado, estados.pensionado)

### Activo actuarial

# Se crea una lista con las matrices calculadas
matrices.pension <- list(matriz.vejez.h, matriz.vejez.m, matriz.inv.h, 
                         matriz.inv.m, matriz.suc.h, matriz.suc.m, 
                         matriz.vejini.h, matriz.vejini.m, matriz.invini.h, 
                         matriz.invini.m, matriz.sucini.h, matriz.sucini.m)

# Lista para matrices con los montos valor presente
matrices.vp <- list()

# Vector que tendrá el monto de las cotizaciones de los pensionados
cotizacion.pensiones <- rep(0, length(matrices.pension))

# Se itera sobre las matrices
for (i in 1:length(matrices.pension)) {
  
  # Se extienden las matrices de forma mensual, considerando el aguinaldo
  matrices.pension[[i]] <- t(apply(matrices.pension[[i]], 1, 
                                   function(fila) rep(fila, each = 13)))
  
  # Se obtiene el valor presente de cada matriz
  matrices.vp[[i]] <- matrices.pension[[i]] * matriz.vp[1:nrow(matrices.pension[[i]]), ]
  
  # Se determina la contribución de los pensionados
  mayores.2mill <- matrices.vp[[i]][matrices.pension[[i]] > 2000000]
  cotizacion.pensiones[i] <- sum(0.05 * mayores.2mill)
  
  # Se actualiza el monto de las pensiones correspondientes
  matrices.vp[[i]] <- matrices.vp[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
  matrices.pension[[i]] <- matrices.pension[[i]] * ifelse(matrices.pension[[i]] > 2000000, 0.95, 1)
}

# Se suman las cotizaciones de los pensionados de cada matriz
cotizacion.pensiones <- sum(cotizacion.pensiones)

# Se construye la matriz con los salarios totales para determinar la masa salarial
salarios.finales <- rbind(salario.estoc.h * cotizaciones.h, 
                          salario.estoc.m * cotizaciones.m)

# Se crea la matriz con los factores de descuento para determinar las cotizaciones de los trabajadores
matriz.descuento <- matrix(rep(s, times = nrow(salarios.finales)), 
                           nrow(salarios.finales), byrow = TRUE)

# Se calcula la masa salarial
masa.salarial <- sum(salarios.finales * matriz.descuento)

# Se calcula la contribución de los trabajadores
cotizacion.trab <- masa.salarial * 0.15

# Se calcula el activo actuarial
total.activo <- cotizacion.pensiones + cotizacion.trab + reserva.ini

rm(mayores.2mill)

### Flujos de balance

# Inicializamos los vectores para determinar los años críticos
reserva <- c(reserva.ini)
total.egresos <- c()
cotizaciones <- c()
rends <- c()

# Inicializamos el vector de años críticos
annos <- c(0, 0, 0)

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Cotizaciones de los trabajadores
  cotizaciones <- c(cotizaciones, (sum(salarios.finales[, i]) * 0.15))
  
  # Costo de las pensiones
  costo.pens <- Reduce("+", sapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto administrativo del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Total de egresos
  total.egresos <- c(total.egresos, costo.pens + sem)
  
  # Rendimientos
  rends <- c(rends, ifelse((reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real > 0, 
                           (reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real, 0))
  
  # Total de ingresos
  total.ingresos <- cotizaciones[i] + rends[i]
  
  # Guardamos la reserva final (reserva inicial del siguiente año)
  reserva <- c(reserva, (reserva[i] + total.ingresos - total.egresos[i] + sem))
}

# Eliminamos la última reserva final
reserva <- reserva[-length(reserva)]

# Determinamos los años críticos
idx <- which(total.egresos > cotizaciones)[1]
annos[1] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends))[1]
annos[2] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends + reserva))[1]
annos[3] <- idx + 2024

### Pasivo actuarial

# Se calcula el total de las pensiones
total.pensiones <- sum(sapply(matrices.vp, sum))

# Se calcula el monto del SEM
sem <- total.pensiones * (12/13) * 0.085

# Por último se calcula el pasivo actuarial
total.pasivo <- total.pensiones + sem

### Indicadores de solvencia

# Agregamos los indicadores a sus respectivas listas
razon.solvencia <- append(razon.solvencia, (total.activo / total.pasivo))
annos.crit <- append(annos.crit, list(annos))
balance <- append(balance, list(c(total.activo, total.pasivo)))
prima.media <- append(prima.media, ((total.pasivo - reserva.ini) / masa.salarial))

# Actualizamos los promedios para el ciclo while
prom.antes <- prom.despues
prom.despues <- mean(unlist(razon.solvencia))

# Se guardan las matrices de pensión
pensiones <- append(pensiones, matrices.vp)
}

end.time <- Sys.time()

end.time - start.time
```

Una vez el modelo haya terminado de hacer las iteraciones, se procede a determinar la tasa de ingresos, la prima de reparto y la razón de fondo de contingencias, usando las variables de la última iteración.

```{r metricas_as2}
# Inicializamos la reserva inicial en el 2025 y los vectores para las métricas
reserva <- reserva.ini
tasa.ingresos <- c()
prima.reparto <- c()
razon.fondo.cont <- c()

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Masa salarial
  ms <- sum(salarios.finales[, i])
  
  # Cotizaciones de los trabajadores
  cotizaciones <- ms * 0.15
  
  # Costo de las pensiones en cada año
  costo.pens <- Reduce("+", lapply(matrices.pension, function(mat) sum(mat[, (13*i - 12):(13*i)])))
  
  # Gasto del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Egresos totales
  total.egresos <- costo.pens + sem
  
  # Rendimientos
  rends <- ifelse((reserva + (cotizaciones - total.egresos) / 2) * interes.real > 0, 
                  (reserva + (cotizaciones - total.egresos) / 2) * interes.real, 0)
  
  # Ingresos totales
  total.ingresos <- cotizaciones + rends
  
  # Guardamos las métricas
  tasa.ingresos <- c(tasa.ingresos, ifelse(ms > 0, (total.ingresos / ms), NA))
  prima.reparto <- c(prima.reparto, ifelse(ms > 0, (total.egresos / ms), NA))
  razon.fondo.cont <- c(razon.fondo.cont, total.egresos / reserva)
  
  # Actualizamos la reserva inicial para el siguiente año
  reserva <- reserva + total.ingresos - total.egresos + sem
  
}
```

## Resultados de incremento de mortalidad

## Razón de solvencia

Ahora se procede con las razones de solvencia. Inicialmente, se tiene el promedio de las razones de solvencia para este caso:

```{r rs_as2}
(prom.rs <- mean(unlist(razon.solvencia)))
```

Se puede observar en un gráfico de densidad las distintas razones de solvencia.

```{r densidad_rs_as2}
# Se crea un dataframe con los datos
data.rs <- data.frame(rs = unlist(razon.solvencia))

# Gráfico de las razones de solvencia
ggplot(data.rs, aes(x = rs)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.rs,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.rs,
    y = 50,
    label = "Media de las RS",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón de solvencia",
       y = "Densidad") +
  theme_minimal()
```

## Años críticos

En primer lugar, se obtendrá un promedio de los años críticos.

```{r annos_criticos_as2}
# Se guarda como matriz
annos.crit.mat <- do.call(cbind, annos.crit)

# Se redondean los promedios
round(rowMeans(annos.crit.mat, na.rm = TRUE), 0)
```

Los anteriores están ordenados en primer, segundo y tercer año crítico respectivamente. Si los resultados son **NaN** significa que en ningún caso se llega a ese año crítico.

Para el caso en estudio, usualmente solo se llega al primer año crítico entre las iteraciones, por lo que se grafica ese caso.

```{r grafico_annos_criticos_as2}
# Se guardan los primeros años críticos en un DataFrame
df.annos.crit <- data.frame(primer_momento = annos.crit.mat[1, ])

# Se grafican los primeros momentos correspondientes
ggplot(df.annos.crit, aes(x = primer_momento)) +
  geom_histogram(
    aes(y = after_stat(count / sum(count))),
    bins = 2,
    fill = "#A34022",
    color = "black"
  ) +
  labs(x = "Año",
       y = "Densidad")
theme_minimal()
```

## Prima media

Como se menciona en el reglamento, se procede con la prima media. Inicialmente se obtiene el promedio de estas:

```{r prima_media_as2}
(prom.pm <- mean(unlist(prima.media)))
```

Un análisis más detallado se observa en el siguiente gráfico:

```{r grafico_prima_media_as2}
# Se crea un dataframe con los datos
data.pm <- data.frame(pm = unlist(prima.media))

# Gráfico de las primas medias niveladas
ggplot(data.pm, aes(x = pm)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pm,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pm,
    y = 20,
    label = "Promedio de la prima media",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima media nivelada",
       y = "Densidad") +
  theme_minimal()
```

## Razón del fondo de contingencia

Se muestra la razón del fondo de contingencia de la última simulación, visualizada en un gráfico.

```{r grafico_rc_as2}
# Se crea un dataframe con los datos
data.rc <- data.frame(rc = razon.fondo.cont)

# Gráfico de las razones del fondo de contingencia
ggplot(data.rc, aes(x = rc)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = mean(razon.fondo.cont),
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = mean(razon.fondo.cont),
    y = 100,
    label = "Media de la RC",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón del fondo de contingencia",
       y = "Densidad") +
  theme_minimal()
```

Una vez más, se aprecia que la reserva es muy grande en comparación con los egresos, lo cual produce resultados muy cercanos a 0 para esta métrica.

## Tasa de ingresos

La tasa de ingresos se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_as2}
(prom.ti <- mean(tasa.ingresos, na.rm = TRUE))
```

Se observan los resultados en un gráfico.

```{r grafico_ti_as2}
# Se crea un dataframe con los datos
data.ti <- data.frame(ti = tasa.ingresos)

# Gráfico de las razones del fondo de contingencia
ggplot(data.ti, aes(x = ti)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.ti,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.ti,
    y = 0.002,
    label = "Media de la TI",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Tasa de ingresos",
       y = "Densidad") +
  theme_minimal()
```

Los primeros valores están entre 10 y 20, lo cual condiciona mucho el gráfico.

## Prima de reparto

La prima de reparto se calcula siempre que la masa salarial sea mayor a 0. Por lo que se quitan los nulos en el promedio:

```{r promedio_ti_as2}
(prom.pr <- mean(prima.reparto, na.rm = TRUE))
```

Se observa el comportamiento en un gráfico.

```{r grafico_pr_as2}
# Se crea un dataframe con los datos
data.pr <- data.frame(pr = prima.reparto)

# Gráfico de las razones del fondo de contingencia
ggplot(data.pr, aes(x = pr)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pr,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pr,
    y = 0.04,
    label = "Media de la prima de reparto",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima de reparto",
       y = "Densidad") +
  theme_minimal()
```

Se observa que muchos de los valores son menores a 1. Incluso, más del $75\%$ tienen menos de 2 dígitos.

## Balance

El promedio del activo y del pasivo a lo largo de las iteraciones se muestra a continuación.

```{r prom_balance_as2}
# Se obtienen los valores en una matriz
matriz.balance <- do.call(cbind, balance)

# Promedio del activo y del pasivo respectivamente
rowMeans(matriz.balance)
```

Seguidamente, como pide el reglamento, se muestran las pensiones separadas por generaciones y por razón de salida.

```{r pasivo_separado_as2}
# Se defina una matriz para obtener los montos
matriz.pasivo <- matrix(0, nrow = 6, ncol = (length(pensiones) / 12))

# Se obtienen los montos con un ciclo
for (i in 1:ncol(matriz.pasivo)) {
  # Se hace la suma de la iteración correspondiente
  suma.iter <- sapply(pensiones[(1+(i*12 - 12)):(12*i)], sum)
  
  # Se actualiza la matriz
  matriz.pasivo[, i] <-
    c((suma.iter[1] + suma.iter[2]),
      (suma.iter[3] + suma.iter[4]),
      (suma.iter[5] + suma.iter[6]),
      (suma.iter[7] + suma.iter[8]),
      (suma.iter[9] + suma.iter[10]),
      (suma.iter[11] + suma.iter[12]))
}

# Se pone la información en un dataframe
(
  df.pasivo <-
    data.frame(
      "Generación actual" = c(rowMeans(matriz.pasivo)[1:3], sum(rowMeans(matriz.pasivo)[1:3])),
      "Generación pensionada" = c(rowMeans(matriz.pasivo)[4:6], sum(rowMeans(matriz.pasivo)[4:6])),
      row.names = c("Vejez", "Invalidez", "Sucesion", "Total")
    )
)
```


Lo anterior se muestra en el siguiente gráfico.

```{r grafico_balance_as2}
# Se pone la información en un dataframe
df.balance <- data.frame(valor = rowMeans(matriz.balance),
                         categoria = c("Activo", "Pasivo"))

# Gráfico del balance
ggplot(df.balance, aes(x = categoria, y = (valor / 1000000000))) +
  geom_bar(stat = "identity", fill = "#A34022") +
  labs(x = "Categoría del balance", y = "Valor (Miles de millones de colones)") +
  theme_minimal()
```


estos se muestran por separado, tal y como menciona el reglamento. Esto representa el promedio del valor presente de todos los activos y pasivos, respectivamente, de los 95 años proyectados.
