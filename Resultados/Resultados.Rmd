---
title: "Resultados"
author: "Alejandro Brenes, Santiago Fernández, Eyeri Méndez y Erick Venegas"
date: "`r Sys.Date()`"
output: html_document
---

# Preparación inicial

## Librerías

Inicialmente, cargamos las librerías necesarias para el desarrollo del modelo.

```{r librerias, message = FALSE, warning = FALSE}
pacman::p_load(data.table,
               janitor,
               purrr,
               readxl,
               tidyverse,
               zoo)
```

## Datos del régimen

Se leen las bases de cotizantes, pensionados y de estados financieros.

```{r carga_cotpen, message = FALSE, warning = FALSE}
cotizantes <- read_excel("data/BD_Cotizantes.xlsx")
pensionados <- read_excel("data/BD_Pensionados.xlsx")
financiero <- read_excel("data/BD_Financiero.xlsx", sheet = "EEFF")
```

Se realizan algunas correcciones de formato en los pensionados y en los cotizantes.

```{r correcciones_cotpen}
# Se cambian los nombres de las columnas no numéricas de los cotizantes
cotizantes <- cotizantes %>% clean_names()

# Se corrigen los nombres de las columnas de la base de cotizantes
colnames(cotizantes)[4:363] <- format(seq(
  from = ymd("1995-01-01"),
  to = ymd("2024-12-01"),
  by = "1 month"
), "%m-%Y")

# Se corrigen los nombres de la base de pensionados
pensionados <- pensionados %>% clean_names() %>% select(-c("x9"))
```

## Probabilidades de muerte

Se cargan los datos de mortalidad dinámicos de la SUPEN.

```{r carga_mort}
mortalidad <- read_excel("data/mortalidad.xls")
```

Las probabilidades aparecen como caracteres, por lo que se realiza el cambio correspondiente.

```{r correcciones_mort}
# Se cambia el formato necesario
mortalidad$qx <- as.numeric(mortalidad$qx)

# Se guarda como DataTable
mortalidad <- setDT(mortalidad)
```

## Probabilidades de invalidez

Se procede a cargar las probabilidades de invalidez.

```{r carga_inv}
invalidez <- read_excel("data/invalidez.xlsx")
```

Todas las columnas salen como caracteres, por lo que se cambian.

```{r correcciones_inv}
# Se ponen las edades como números enteros
invalidez$Edad <- as.integer(invalidez$Edad)

# Se corrigen las probabilidades
invalidez$Hombres <- as.numeric(invalidez$Hombres)
invalidez$Mujeres <- as.numeric(invalidez$Mujeres)

# Se corrigen los nombres a un formato más simple
invalidez <- invalidez %>% clean_names()

# Se guarda como DataTable
invalidez <- setDT(invalidez)
```

## Inflación

```{r carga_inflacion, message = FALSE, warning = FALSE}
inflacion <- read_excel("data/inflacion_mundial.xls")
```

Se corrigen ciertos aspectos.

```{r correcciones_inflacion}
# Se filtran para tener solo los datos de Costa Rica
inflacion.cr <- inflacion %>%
  filter(`Data Source` %in% c("Costa Rica", "Country Name"))

inflacion.cr <- inflacion.cr[, -c(2, 3, 4)]

inflacion.cr[1, 1] <- "Año"

inflacion.cr <- as.data.frame(t(inflacion.cr))

colnames(inflacion.cr) <- as.character(inflacion.cr[1, ])

inflacion.cr <- inflacion.cr[-1, ]

# Se agrega el valor de 2024
inflacion.2024 <- data.frame("Año" = 2024, "Costa Rica" = 0.84)

colnames(inflacion.2024) <- colnames(inflacion.cr)

inflacion.cr <- rbind(inflacion.cr, inflacion.2024)

# Se reasignan las filas con numeración normal (1, 2, 3, ...)
row.names(inflacion.cr) <- NULL

# Se pasan las columnas a tipo numérico
inflacion.cr <- inflacion.cr %>%
  mutate(across(c(1, 2), as.numeric))

rm(inflacion)
rm(inflacion.2024)
```

# Modelo básico

## Parte determinista

En esta sección se concentran las variables invariantes. Es decir, aquellas que no cambiarán durante las iteraciones del modelo.

### Variables necesarias

```{r deterministica_base}
# Se guarda el valor de las reservas en formación (reserva inicial)
reserva.ini <- as.numeric(financiero[1, 2]) + as.numeric(financiero[31, 2])

### Beneficios de los cotizantes sin contar estado ###

# Se inicia creando la matriz de edades de los cotizantes, iniciando en la edad del 2025
edades <-
  matrix((2025 - year(cotizantes$fec_nac)),
         nrow = nrow(cotizantes),
         ncol = 95,
         byrow = FALSE
  )

# Se pone el año en cada columna
colnames(edades) <- format(seq(
  from = ymd("2025-01-01"),
  to = ymd("2119-01-01"),
  by = "1 year"
), "%Y")

# Se cambia la edad en cada columna
for (i in 2:ncol(edades)) {
  edades[, i] <- edades[, (i - 1)] + 1
}

# Se corrije la edad máxima a 115
edades <- ifelse(edades > 115, 115, edades)

# Se separan las edades por sexo
edades.h <- edades[which(cotizantes$sexo == 1), ]
edades.m <- edades[which(cotizantes$sexo == 2), ]

# Se determina el estado de actividad/inactividad de las personas en el 2023
estados23 <- rowSums(cotizantes[, 340:351] > 10000) > 0

# Se agrega el estado, separado por sexo, 1 es activo y 0 es inactivo
actividad.h <-
  matrix(
    estados23[which(cotizantes$sexo == 1)],
    nrow = nrow(edades.h),
    ncol = ncol(edades.h),
    byrow = FALSE
  )

actividad.m <-
  matrix(
    estados23[which(cotizantes$sexo == 2)],
    nrow = nrow(edades.m),
    ncol = ncol(edades.m),
    byrow = FALSE
  )

# Se eliminan las variables innecesarias
rm(estados23)

### Distintos estados a considerar ###

# Probabilidades de invalidez por sexo
inv.h <-
  matrix(
    invalidez[match(edades.h, edad), hombres],
    ncol = ncol(edades.h),
    nrow = nrow(edades.h),
    byrow = FALSE
  )

inv.m <-
  matrix(
    invalidez[match(edades.m, edad), mujeres],
    ncol = ncol(edades.m),
    nrow = nrow(edades.m),
    byrow = FALSE
  )

# Se cambia el nombre de las columnas de la matriz de invalidez
colnames(inv.h) <- colnames(edades.h)
colnames(inv.m) <- colnames(edades.m)

# Para las probabilidades de muerte, se inicia creando las matrices vacías
mort.h <- matrix(0, nrow = nrow(edades.h), ncol = ncol(edades.h))
mort.m <- matrix(0, nrow = nrow(edades.m), ncol = ncol(edades.m))

# Se corrigen los nombres de sus columnas
colnames(mort.h) <- colnames(edades.h)
colnames(mort.m) <- colnames(edades.m)

# Se agregan las probabilidades por cada año (columna), para ambos sexos
for (i in 1:ncol(mort.h)) {
  mort.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.h)[i])][.(edad = edades.h[, i]), 
                                                         on = .(edad), qx]
  mort.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.m)[i])][.(edad = edades.m[, i]), 
                                                         on = .(edad), qx]
}

# Se crea una lista para guardar los estados de invalidez y muerte de los cotizantes
lista.estados.h <- list()
lista.estados.m <- list()
```

### Proyección salarial

Se crea la función que permite anualizar los salarios en otro DataFrame.

```{r funcion_anualizar}
meses.to.annos <-
  function(df, columnas.excluir, anno.inicio = 1995) {
    # Se extrae el nombre de las columnas mensuales
    columnas.mensuales <- setdiff(names(df), columnas.excluir)
    
    # Se ordenan los nombres cronológicamente
    columnas.mensuales <- sort(columnas.mensuales)
    
    # Se calcula la cantidad de años completos
    n.meses <- length(columnas.mensuales)
    n.annos <- floor(n.meses / 12)
    
    nombres.annos <-
      as.character(seq(anno.inicio, by = 1, length.out = n.annos))
    
    # Se calculan los promedios anuales
    annos <- lapply(1:n.annos, function(i) {
      cols <- columnas.mensuales[((i - 1) * 12 + 1):(i * 12)]
      rowMeans(df[, cols], na.rm = TRUE)
    })
    
    # Se crea el DF de promedios
    df.anual <- as.data.frame(annos)
    names(df.anual) <- nombres.annos
    
    # Se combinan las columnas fijas y los promedios anuales
    df.final <- cbind(df[, columnas.excluir], df.anual)
    
    return(df.final)
  }

# Se crea el DF con salarios anualizados.
cotizantes.anualizado <-
  meses.to.annos(cotizantes, c("id", "fec_nac", "sexo"))

rm(meses.to.annos)
```

Se crea un nuevo DataFrame donde está la información con los salarios anualizados. Además, se cambia el formato de las columnas.

```{r formato_fecha}
# Se establece el tipo de variable fecha de la columna
cotizantes.anualizado$fec_nac <-
  as.Date(cotizantes.anualizado$fec_nac,
          format = "%Y/%m/%d")

# Se agrega una nueva variable edad al df
cotizantes.anualizado$edad <-
  2024 - as.numeric(format(cotizantes.anualizado$fec_nac, "%Y"))

# Se establece el tipo de variable fecha de la columna
cotizantes$fec_nac <- as.Date(cotizantes$fec_nac,
                              format = "%Y/%m/%d")

# Se agrega una nueva variable edad al df
cotizantes$edad <-
  2024 - as.numeric(format(cotizantes$fec_nac, "%Y"))
```

Se calcula una nueva columna para la matriz, la cual contiene la información del factor acumulativo por cada año, esto con el objetivo de que se multiplique el factor multiplicativo por el salario del respecto año para que éste se acumule hasta el año 2024.

```{r factor_acumulado}
# Se actualiza la tasa, para utilizar en cálculos de forma porcentual
inflacion.cr$`Costa Rica` <- inflacion.cr$`Costa Rica` / 100

inflacion.cr$factor_acumulado <-
  sapply(inflacion.cr$Año, function(anno) {
    
    if (anno == 2024) {
      
      return(1)
      
    } else {
      
      años.a.usar <- inflacion.cr$Año >= anno & inflacion.cr$Año <= 2024
      
      return(prod(1 + inflacion.cr$`Costa Rica`[años.a.usar]))
    }
    
  })
```

Se procede con el cálculo del valor presente de todos los salarios de la base, donde se toma como tasa de acumulación la inflación observada en el respectivo año.

```{r valor_presente}
# Se introducen los años contabilizados históricamente
columnas.años <- as.character(1995:2024)

# Copia del DataFrame para obtener el valor presente
cotizantes.anualizado.VP <- cotizantes.anualizado

# Se agrega iterativamente la inflación
for (año in columnas.años) {
  año.num <- as.numeric(año)
  
  factor <-
    inflacion.cr$factor_acumulado[inflacion.cr$Año == año.num]
  
  if (length(factor) == 1 && !is.na(factor)) {
    
    cotizantes.anualizado.VP[[año]] <-
      as.numeric(cotizantes.anualizado[[año]]) / factor
    
  }
}
```

Para graficar lo anterior, se debe pasar la base de datos a formato largo para su visualización.

```{r formato_largo}
# Convertir columnas de años a largo
cotizantes.anualizado.VP.largo <- cotizantes.anualizado.VP %>%
  pivot_longer(
    cols = all_of(columnas.años),
    names_to = "año",
    values_to = "salario.ajustado"
  ) %>%
  mutate(año = as.numeric(año))

rm(factor)
rm(año.num)
rm(año)
rm(columnas.años)
```

Se procede con la proyección de los salarios de manera brusca, es decir, se utilizan los datos sin suavizar.

```{r salarios_por_edad, message = FALSE, warning = FALSE}
salarios.por.edad <- cotizantes.anualizado %>%
  group_by(edad) %>%
  summarise(promedio.salario.2024 = mean(`2024`, na.rm = TRUE)) %>%
  arrange(edad) %>%
  mutate(tasa.incremento = promedio.salario.2024 / lag(promedio.salario.2024))

# Se obtienen las tasas de incremento
salarios.por.edad$tasa.incremento[1] = salarios.por.edad$tasa.incremento[2]
tasas.ext <- salarios.por.edad$tasa.incremento

# Se cambian los nombres de las tasas
names(tasas.ext) <- salarios.por.edad$edad

# Se procede a hacer la proyección
proyeccion.salarios <- cotizantes.anualizado.VP %>%
  select(id, edad, salario.2024 = `2024`) %>%
  rowwise() %>%
  mutate(proyeccion = list({
    
    edad.i <- edad
    salario.i <- salario.2024
    
    resultados <- tibble(edad = edad.i,
                         salario = salario.i)
    
    # 95 años hacia adelante
    for (anio in 1:95) {
      edad.i <- edad.i + 1
      
      if (edad.i < 65) {
        
        tasa.i <- tasas.ext[as.character(edad.i - 1)]
        
        if (is.na(tasa.i))
          
          break
        
        salario.i <- salario.i * tasa.i
        
      } else {
        
        # A partir de 65 años tasa = 1 (salario constante)
        salario.i <- salario.i
        
      }
      
      resultados <-
        add_row(resultados, edad = edad.i, salario = salario.i)
      
    }
    resultados
  })) %>%
  unnest(proyeccion, names_sep = ".")

# Se limpia el ambiente de las variables que fueron auxiliares
rm(tasas.ext)
```

Se crea la curva de salarios general, sin ser suavizada.

```{r}
curva.general <- proyeccion.salarios %>%
  group_by(proyeccion.edad) %>%
  summarise(salario.promedio = mean(proyeccion.salario, na.rm = TRUE))
```

El siguiente código tiene la finalidad de suavizar las tasas de incremento, lo que provocará que la curva salarial tenga un comportamiento menos errático. Además, el cálculo de estos valores es de utilidad a la hora de proyectar los salarios de cada individuo.

```{r obtencion_datos_suavizados}
modelo.loess <- loess(salario.promedio ~ proyeccion.edad, data = curva.general)

curva.suavizada <- curva.general %>%
  mutate(salario.suavizado = predict(modelo.loess, 
                                     newdata = data.frame(proyeccion.edad = 
                                                          proyeccion.edad)))

curva.suavizada <- curva.suavizada %>%
  arrange(proyeccion.edad) %>%  
  mutate(
    tasa.incremento = salario.suavizado / lag(salario.suavizado)
  )

curva.suavizada$tasa.incremento[1] <- curva.suavizada$tasa.incremento[2]
```

Se crea la función para proyectar en un gráfico a un individuo en particular. Esto utilizando los datos crudos de las tasas de incremento, con la finalidad de que se observe el comportamiento de la proyección.

```{r funcion_proyectar_persona}
graficar.proyeccion.id <- function(persona.id) {
  
  datos.iniciales <- cotizantes.anualizado.VP.largo %>%
    filter(id == persona.id, año == 2024) %>%
    select(id, edad, salario.2024 = salario.ajustado) %>%
    distinct()
  
  if (nrow(datos.iniciales) == 0) {
    stop("ID no encontrado en la base.")
  }
  
  edad.inicial <- datos.iniciales$edad
  salario.actual <- datos.iniciales$salario.2024
  
  proyeccion <- tibble(edad = edad.inicial,
                       salario = salario.actual)
  
  salario.i <- salario.actual
  edad.i <- edad.inicial
  
  for (i in 1:95) {
    
    edad.i <- edad.i + 1
    
    tasa.i <- curva.suavizada %>%
      filter(proyeccion.edad == edad.i) %>%
      pull(tasa.incremento)
    
    if (length(tasa.i) == 0 || is.na(tasa.i)) {
      tasa.i <- 1
    }
    
    salario.i <- salario.i * tasa.i
    
    proyeccion <-
      add_row(proyeccion, edad = edad.i, salario = salario.i)
  }
  
  ggplot(proyeccion, aes(x = edad, y = salario)) +
    geom_line(color = "purple", linewidth = 1.2) +
    labs(
      title = paste("Curva salarial proyectada para ID:", persona.id),
      x = "Edad proyectada",
      y = "Salario proyectado"
    ) +
    theme_minimal()
}
```

Se debe crear un nuevo DataFrame en el cual se tenga en valor presente las cotizaciones realizadas.

```{r Valor_presente_cotizantes}
# Extraemos todos los nombres de las columnas que tengan formato "MM-YYYY"
columnas.mensuales <-
  grep("^\\d{2}-\\d{4}$", colnames(cotizantes), value = TRUE)

cotizantes.VP <- cotizantes

for (col in columnas.mensuales) {
  # Extraemos el año del nombre de la columna, asumiendo formato "MM-YYYY"
  año <- as.numeric(sub(".*-(\\d{4})$", "\\1", col))
  
  # Buscamos el factor acumulado para ese año
  factor <- inflacion.cr$factor_acumulado[inflacion.cr$Año == año]
  
  if (length(factor) == 1 && !is.na(factor)) {
    
    # Dividimos la columna mensual por el factor para traer a valor presente
    cotizantes.VP[[col]] <- cotizantes[[col]] / factor
    
  } else {}
}

rm(año)
rm(col)
rm(columnas.mensuales)
rm(factor)
```

Se calcula el total de cotizaciones por persona.

```{r total_cotizaciones}
cotizantes.VP <- cotizantes.VP %>%
  rowwise() %>%
  mutate(cotizaciones = sum(c_across(`01-1995`:`12-2024`) >= 10000, 
                            na.rm = TRUE)) %>%
  ungroup()
```

Luego, se obtiene la cantidad de cotizaciones en 2023.

```{r numero_cotizaciones_2023}
meses.2023 <- paste0(sprintf("%02d", 1:12), "-2023")

cotizantes.VP <- cotizantes.VP %>%
  rowwise() %>%
  mutate(cotizaciones.2023 = sum(c_across(all_of(meses.2023)) >= 10000, 
                                 na.rm = TRUE)) %>%
  ungroup()

cotizantes.VP <- cotizantes.VP %>%
  mutate(edad = floor(interval(start = fec_nac, end = Sys.Date()) / years(1)))

rm(meses.2023)
```

Ahora, se obtienen las cotizaciones promedio, separando por edad, del año 2023.

```{r cotizaciones_promedio_edad}
cotizaciones.promedio.edad <- cotizantes.VP %>%
  group_by(edad) %>%
  summarise(promedio.cotizaciones = round(mean(cotizaciones.2023, 
                                               na.rm = TRUE))) %>%
  ungroup()
```

Se consigue el DataFrame con la información de las personas activas según el mes.

```{r data_inactivos}
columnas.excluir <- c("id", "fec_nac", "sexo", "edad", "cotizaciones", 
                      "cotizaciones.2023")

datos.variables <- cotizantes.VP[, !names(cotizantes.VP) %in% columnas.excluir]
datos.transformados <- as.data.frame(ifelse(datos.variables > 0, 1, 0))
datos.excluidos <- cotizantes.VP[, columnas.excluir, drop = FALSE]

cotizantes.VP.activos <- cbind(datos.excluidos, datos.transformados)
```

```{r frecuencia_inactivos}
data.anual <- cotizantes.VP.activos %>%
  pivot_longer(
    cols = -all_of(columnas.excluir),
    names_to = "mes_anio",
    values_to = "cotizacion"
  ) %>%
  mutate(anio = str_sub(mes_anio, start = 4)) 

resumen.anual <- data.anual %>%
  group_by(id, anio) %>%
  summarise(cotizaciones = sum(cotizacion, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = anio, values_from = cotizaciones)

columnas.info.extra <- cotizantes.VP.activos %>%
  select(all_of(columnas.excluir)) %>%
  distinct(id, .keep_all = TRUE)

cotizantes.activos <- columnas.info.extra %>%
  left_join(resumen.anual, by = "id")

rm(columnas.info.extra)
rm(resumen.anual)
rm(data.anual)
rm(columnas.excluir)
```

Se obtienen las probabilidades deterministas de postergación, para ambos sexos.

```{r probabilidad_postergacion_hombres}
df.probabilidad.postergacion.h <- ifelse(edades.h >= 65, 0.1, 0)
df.probabilidad.postergacion.m <- ifelse(edades.m >= 63, 0.1, 0)
```

Ahora, se construyen diversas variables auxiliares que servirán como apoyo para la parte estocástica.

```{r determinista_auxiliar}
# Se quitan las edades mayores a 66
cotizaciones.promedio.edad <- cotizaciones.promedio.edad %>% 
  filter(edad <= 66)

# Se agregan las edades restantes, que tienen densidad constante
cotizaciones.promedio.edad <- rbind(
  cotizaciones.promedio.edad,
  data.frame(
    edad = 67:115,
    promedio.cotizaciones = cotizaciones.promedio.edad[nrow(cotizaciones.promedio.edad), 2]
  )
)

# Se transforma en DT
cotizaciones.edad.dt <- setDT(cotizaciones.promedio.edad)

# Se obtiene una matriz con la cantidad de cuotas por edad, a partir de 2025, separado por sexo
matriz.cot.h <- matrix(
  cotizaciones.edad.dt[match(edades.h, edad), promedio.cotizaciones],
  ncol = ncol(edades.h),
  nrow = nrow(edades.h),
  byrow = FALSE
)

matriz.cot.m <- matrix(
  cotizaciones.edad.dt[match(edades.m, edad), promedio.cotizaciones],
  ncol = ncol(edades.m),
  nrow = nrow(edades.m),
  byrow = FALSE
)

# Matriz de 0s, del tamaño de la predicción mensualizada
matriz.salarios.h <- matrix(0, nrow = nrow(matriz.cot.h), 
                            ncol = (ncol(matriz.cot.h) * 12))
matriz.salarios.m <- matrix(0, nrow = nrow(matriz.cot.m), 
                            ncol = (ncol(matriz.cot.m) * 12))

# Se obtiene la inflación acumulada desde 1995
inflacion.95 <- (inflacion.cr %>% filter(Año >= 1995))[, 3]

# Se repite la inflación 12 veces (1 vez por mes)
inflacion.95 <- rep(inflacion.95, times = rep(12, length(inflacion.95)))

# Cotizaciones mensuales traídas a valor presente
cotizaciones.vp <-
  as.matrix(cotizantes[, (4:(ncol(cotizantes) - 1))]) * matrix(
    inflacion.95,
    nrow = nrow(cotizantes),
    ncol = ncol(cotizantes[(4:(ncol(cotizantes) - 1))]),
    byrow = TRUE
  )

# Cotizantes separados por sexo
cotizantes.h <- cotizaciones.vp[which(cotizantes$sexo == 1), ]
cotizantes.m <- cotizaciones.vp[which(cotizantes$sexo == 2), ]

# DataFrame de requisitos para invalidez
requisitos.inv <- data.table(edad = 21:115,
                             cotizaciones_min = c(rep(12, 3), 
                                                  seq(12, 84, 4), 
                                                  seq(90, 120, 6), 
                                                  rep(120, 67)))

# Matriz de edades modificada por los requisitos de invalidez, por sexo
requisitos.inv.h <- matrix(
  requisitos.inv[match(edades.h, edad), cotizaciones_min],
  ncol = ncol(edades.h),
  nrow = nrow(edades.h),
  byrow = FALSE
)

requisitos.inv.m <- matrix(
  requisitos.inv[match(edades.m, edad), cotizaciones_min],
  ncol = ncol(edades.m),
  nrow = nrow(edades.m),
  byrow = FALSE
)

# Se hace una corrección en los salarios. Primero, se agrega el año
proyeccion.salarios <- proyeccion.salarios %>% 
  mutate(anio = rep(c(2024:2119), nrow(cotizantes)))

# Se filtra la proyección para dejar los salarios futuros
proyeccion.salarios <- proyeccion.salarios %>% 
  filter(anio > 2024) %>% 
  mutate(proyeccion.salario = ifelse(edad > 115, 0, proyeccion.salario))

# Se hace una matriz con los salarios
matriz.salarios <-
  matrix(
    proyeccion.salarios$proyeccion.salario,
    nrow = nrow(cotizantes),
    ncol = ncol(edades),
    byrow = TRUE
  )

# Se filtra por sexo
salarios.h <- matriz.salarios[which(cotizantes$sexo == 1), ]
salarios.m <- matriz.salarios[which(cotizantes$sexo == 2), ]

# Ahora, se hará una matriz con las cotizaciones acumuladas de cada persona
cotizaciones.acum.h <- matriz.cot.h
cotizaciones.acum.m <- matriz.cot.m

# Se le suman las cotizaciones iniciales a la primer fila
cotizaciones.acum.h[, 1] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + 
  cotizaciones.acum.h[, 1]

cotizaciones.acum.m[, 1] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + 
  cotizaciones.acum.m[, 1]

# Se acumula la suma por fila
cotizaciones.acum.h <- t(apply(cotizaciones.acum.h, 1, cumsum))
cotizaciones.acum.m <- t(apply(cotizaciones.acum.m, 1, cumsum))

# Se corrige según si el trabajador está activo o inactivo
cotizaciones.acum.h <- cotizaciones.acum.h * actividad.h
cotizaciones.acum.m <- cotizaciones.acum.m * actividad.m

# Se agregan las cotizaciones acumuladas para los inactivos
cotizaciones.acum.h[which(cotizaciones.acum.h[, 1] == 0),] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][which(cotizaciones.acum.h[, 1] == 0)]

cotizaciones.acum.m[which(cotizaciones.acum.m[, 1] == 0),] <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][which(cotizaciones.acum.m[, 1] == 0)]

# Se define la tasa de interés (determinista)
interes.real <- 0.0738

# Se crea el vector con las tasas de descuento
s <- 1 / ((1 + interes.real)^(0:(ncol(matriz.salarios) - 1)))

# DataFrames para probabilidades de sobrevivencia acumuladas
sobrevivencia.h <- matrix(0, nrow = nrow(edades.h), ncol = ncol(edades.h))
sobrevivencia.m <- matrix(0, nrow = nrow(edades.m), ncol = ncol(edades.m))

# Se obtienen las tasas de mortalidad para todos los pensionados desde el año 2025, separados por sexo
for (i in 1:ncol(edades.h)) {
  
  sobrevivencia.h[, i] <- 1 - mortalidad[year == (2024 + i) & sex == 1][match(edades.h[, i], edad), qx]
  
  sobrevivencia.m[, i] <- 1 - mortalidad[year == (2024 + i) & sex == 2][match(edades.m[, i], edad), qx]
  
}

# Se acumulan las probabilidades por fila
sobrevivencia.h <- t(apply(sobrevivencia.h, 1, cumprod))
sobrevivencia.m <- t(apply(sobrevivencia.m, 1, cumprod))

# Se procede a construir las anualidades para cada edad en el 2025, separado por sexo
df.anualidades <- data.frame(edad = 21:115, hombres = 1, mujeres = 1)

# Se rellenan las anualidades menores a 115 años
for (i in 1:(nrow(df.anualidades) - 1)) {
  
  df.anualidades[i, 2] <-
    1 + sum(((1 + interes.real) ^ -c(1:(
      115 - df.anualidades[i, 1]
    ))) * cumprod(1 - sort(mortalidad[year == 2025 &
                                    sex == 1 &
                                    edad > (df.anualidades[i, 1] - 1) & edad < 115, qx])))
  
  df.anualidades[i, 3] <-
    1 + sum(((1 + interes.real) ^ -c(1:(
      115 - df.anualidades[i, 1]
    ))) * cumprod(1 - sort(mortalidad[year == 2025 &
                                    sex == 2 &
                                    edad > (df.anualidades[i, 1] - 1) & edad < 115, qx])))
  
}

# Se pasa a formato DataTable
df.anualidades <- setDT(df.anualidades)
```

### Probabilidades de muerte pensionados actuales

Se crea la matriz de edades de pensionados replicando la lógica del chunk "deterministica_base"

```{r edades_pensionados}
# Extraer el año de nacimiento
pensionados$anio_nac <- year(pensionados$fec_nac)

edades.pensionados <- matrix(
  2025 - pensionados$anio_nac,
  nrow = nrow(pensionados),
  ncol = ncol(edades),
  byrow = FALSE
)
colnames(edades.pensionados) <- as.character(2025:2119)


for (j in 2:ncol(edades.pensionados)) {
  edades.pensionados[, j] <- edades.pensionados[, j - 1] + 1
}

edades.pensionados <- ifelse(edades.pensionados > 115, 115, edades.pensionados)

# Se añaden columnas de relevancia
edades.pensionados.df <- as.data.frame(edades.pensionados)
rm(edades.pensionados)

# Para que coincida con la codificacion de la matriz de mortalidad
sex.cod <- ifelse(pensionados$sexo == "M", 1, 2)

edades.pensionados.df <- cbind(sexo = sex.cod, edades.pensionados.df)

edades.pensionados.df <- cbind(id = pensionados$id_pensionado, edades.pensionados.df)
```

A continuacion el df de las probabilidades de mortalidad específicas para cada pensionado que está actualmente. La idea es llenar la matriz vinculando el sexo, edad, y año específico de cada casilla con la mortalidad asociada en la matriz de probabilidades de muerte.

```{r qx.especificos.pensionados.iniciales}
# Se crea la matriz
matriz.qx.pensionados <- matrix(0, nrow(pensionados), ncol(edades))

colnames(matriz.qx.pensionados) <- as.character(2025:2119)

qx.pensionados.df <- as.data.frame(matriz.qx.pensionados)

rm(matriz.qx.pensionados)

# Se añade el sexo y el id
qx.pensionados.df <- cbind(sexo = sex.cod, qx.pensionados.df)

qx.pensionados.df <- cbind(id = pensionados$id_pensionado, qx.pensionados.df)

# Se llena el df iterando sobre las filas (recorre cada pensionado específico)

for(i in 1:nrow(qx.pensionados.df)){
  
  # La columna 2 es la del sexo, valor fijo para la iteración i-ésima
  sexo.esp <- qx.pensionados.df[i, 2]
  
  # Recorre cada columna (cada año). Empieza en 3 porque la 1 es de id y la 2 es de sexo
  for (j in 3:ncol(qx.pensionados.df)) {
    
    anio.esp <- as.numeric(colnames(qx.pensionados.df)[j])
    
    edad.esp <- edades.pensionados.df[i,j]
    
    qx.pensionados.df[i,j] <- mortalidad[mortalidad$sex == sexo.esp & 
                                         mortalidad$year == anio.esp & 
                                         mortalidad$edad == edad.esp, "qx"]
  }
}
```

### Probabilidades de muerte para cada edad

Seguidamente se crea una matriz con las probabilidades de muerte para cada edad desde 0 hasta 115 y desde el 2025 hasta el 2119.

```{r prob_muertes}
ages <- 0:115

edades.completas <- matrix(rep(ages, ncol(edades)), length(ages), ncol(edades))
colnames(edades.completas) <- colnames(edades)

mort.completa.h <- matrix(0, length(ages), ncol(edades))
mort.completa.m <- matrix(0, length(ages), ncol(edades))

colnames(mort.completa.h) <- colnames(edades)
colnames(mort.completa.m) <- colnames(edades)

for (i in 1:ncol(mort.completa.h)) {
  
  mort.completa.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.completa.h)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
  mort.completa.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.completa.m)[i])][.(edad = edades.completas[, i]), 
                                                                  on = .(edad), qx]
}

mort.completa.h[is.na(mort.completa.h)] <- 1
mort.completa.m[is.na(mort.completa.m)] <- 1

mort.hijos <- 0.5 * (mort.completa.h + mort.completa.m)
```

### Variables pensiones

Se definen algunos parámetros para el cálculo de las pensiones.

```{r parametros_pensiones}
# Que excedan las 300 cotizaciones
bono.cotizaciones <- 0.000833

# Por mes de postergación
bono.postergacion <- 0.001333

# Tasa límite
tasa.maxima <- 1.25

# Tomando como supuesto 4 fines de semana al mes, y meses de 30 dias, se multiplica el salario por jornada diaria ordinaria por los días laborales del mes
salario.minimo <- 12236.95 * 22

# Función que calcula la cuantía básica con base en el art. 24
cuantia.basica <- function(salario.referencia) {
  cuantia <- numeric(length(salario.referencia))

  cuantia[salario.referencia < 2 * salario.minimo] <- 0.525
  cuantia[salario.referencia >= 2 * salario.minimo & salario.referencia < 3 * salario.minimo] <- 0.51
  cuantia[salario.referencia >= 3 * salario.minimo & salario.referencia < 4 * salario.minimo] <- 0.494
  cuantia[salario.referencia >= 4 * salario.minimo & salario.referencia < 5 * salario.minimo] <- 0.478
  cuantia[salario.referencia >= 5 * salario.minimo & salario.referencia < 6 * salario.minimo] <- 0.462
  cuantia[salario.referencia >= 6 * salario.minimo & salario.referencia < 8 * salario.minimo] <- 0.446
  cuantia[salario.referencia >= 8 * salario.minimo] <- 0.43

  return(cuantia)
}
```

## Parte estocástica

En esta sección se encuentra todo objeto que sea, o dependa, de algún elemento estocástico. Son los factores que varían en cada una de las iteraciones del modelo en alguna forma.

Primero, se crean las listas para guardar las razones de solvencia, los balances (activo, pasivo), las primas medias niveladas y los años críticos en cada iteración.

```{r listas_iniciales}
razon.solvencia <- list()
annos.crit <- list()
balance <- list()
prima.media <- list()
beneficio.devengado.vejez <- list()
beneficio.devengado.invalidez <- list()
beneficio.devengado.sucesion <- list()

# Inicializamos los promedios para asegurarnos de que se harán mínimo 2 iteraciones
prom.antes <- 0
prom.despues <- 1
```

Con esto, se procede con el modelo en sí.

```{r estocastico_base}
start.time <- Sys.time()

while(abs(prom.despues - prom.antes) >= 0.001){
  
# Se crean dos matrices aleatorias usando distribución Uniforme(0, 1)
matriz.aleatoria.h <- matrix(runif(nrow(cotizantes.h) * ncol(mort.h)), 
                             nrow(cotizantes.h), ncol(mort.h))

matriz.aleatoria.m <- matrix(runif(nrow(cotizantes.m) * ncol(mort.m)), 
                             nrow(cotizantes.m), ncol(mort.m))

# Se continúa con las matrices de probabilidades de postergación
postergacion.simulada.h <- matriz.aleatoria.h < df.probabilidad.postergacion.h
postergacion.simulada.m <- matriz.aleatoria.m < df.probabilidad.postergacion.m

# Se corrigen las postergaciones incorrectas
postergacion.simulada.h <-
  t(apply(postergacion.simulada.h, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))
postergacion.simulada.m <-
  t(apply(postergacion.simulada.m, 1, function(fila) {
    corte <- cumsum(fila == 0 & cumsum(fila) > 0)
    fila <- fila * (corte == 0)
  }))

# Matrices de números uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <-
  inv.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.h[[2]] <-
  mort.h >= matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))

lista.estados.m[[1]] <-
  inv.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

lista.estados.m[[2]] <-
  mort.m >= matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Se hacen las correcciones, para que si entra en un estado se mantenga en él durante el tiempo
lista.estados.h[[1]] <-
  t(apply(lista.estados.h[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.h[[2]] <-
  t(apply(lista.estados.h[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[1]] <-
  t(apply(lista.estados.m[[1]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))
lista.estados.m[[2]] <-
  t(apply(lista.estados.m[[2]], 1, function(fila) {
    ifelse(cumsum(fila) > 0, 1, 0)
  }))

# Se hace la matriz con los estados de cada persona, separando por sexo
estados.h <-
  ifelse(lista.estados.h[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.h[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.h == 1) * (cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 1,
           "Posterga",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 1)) == 1,
           "Activo",
           ifelse(((((cotizaciones.acum.h > 179) * (edades.h > 64)
           ) == 0) * (actividad.h == 0)) == 1, "Inactivo", ifelse(
             edades.h > 64,
             "Retirado",
             ifelse(actividad.h == 1, "Activo", "Inactivo")
           ))
           ))
         ))
estados.m <-
  ifelse(lista.estados.m[[2]] == 1,
         "Fallecido",
         ifelse(
           lista.estados.m[[1]] == 1,
           "Invalido",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 404) * (edades.m == 63)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 356) * (edades.m == 64)
           ) == 1,
           "Posterga",
           ifelse(((postergacion.simulada.m == 1) * (cotizaciones.acum.m > 179) * (edades.m > 64)
           ) == 1,
           "Posterga",
           ifelse(
             ((edades.m == 63) * (cotizaciones.acum.m > 404)) == 1,
             "Retirado",
             ifelse(((edades.m == 64) * (cotizaciones.acum.m > 356)
             ) == 1, "Retirado", ifelse(((edades.m > 64) * (cotizaciones.acum.m > 179)) == 1,
                                        "Retirado",
                                        ifelse(actividad.m == 1, "Activo", "Inactivo")
             ))
           ))
           ))
         ))

# Existe el caso en donde una persona retirada puede quedar inválida posteriormente, por lo que se corrije dicho escenario
estados.h <- t(apply(estados.h, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if (all(c("Invalido", "Retirado") %in% fila)) {
    fila[fila %in% c("Invalido", "Retirado")] <-
      fila[which(fila %in% c("Invalido", "Retirado"))[1]]
  }
  fila
}))

# Ahora, existe el caso en donde una persona retirada puede postergar, por lo que se corrije ese caso
estados.h <- t(apply(estados.h, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))
estados.m <- t(apply(estados.m, 1, function(fila) {
  if ((all(c("Posterga", "Retirado") %in% fila)) &&
      (which(fila == "Retirado")[1] < which(fila == "Posterga")[1])) {
    fila[fila %in% c("Posterga", "Retirado")] <- "Retirado"
  }
  fila
}))

# Se obtiene el salario, separado por sexo
salario.estoc.h <-
  salarios.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
salario.estoc.m <-
  salarios.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Obtenemos las razones de salida, separado por sexo
salida.h <- apply(estados.h, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})
salida.m <- apply(estados.m, 1, function(fila) {
  fila[min(which(fila %in% c("Retirado", "Invalido", "Fallecido")))]
})

# Cotizaciones reales
cotizaciones.h <- matriz.cot.h * ((estados.h == "Activo") + (estados.h == "Posterga"))
cotizaciones.m <- matriz.cot.m * ((estados.m == "Activo") + (estados.m == "Posterga"))

# Consideramos la cantidad final de cuotas, separada por sexo
cuotas.finales.h <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)] + rowSums(cotizaciones.h)
cuotas.finales.m <-
  cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)] + rowSums(cotizaciones.m)

# Vamos a obtener los salarios de cada persona, separado por sexo, de la parte estocástica
salarios.aux.h <- do.call(rbind, lapply(1:nrow(salario.estoc.h), function(i) {
  unlist(lapply(1:ncol(salario.estoc.h), function(j) {
    c(rep(salario.estoc.h[i, j], times = cotizaciones.h[i, j]),
      rep(0, 12 - cotizaciones.h[i, j]))
  }))
}))
salarios.aux.m <- do.call(rbind, lapply(1:nrow(salario.estoc.m), function(i) {
  unlist(lapply(1:ncol(salario.estoc.m), function(j) {
    c(rep(salario.estoc.m[i, j], times = cotizaciones.m[i, j]),
      rep(0, 12 - cotizaciones.m[i, j]))
  }))
}))

# Se juntan las matrices de salarios
matriz.salarios.h <- cbind(cotizantes.h, salarios.aux.h)
matriz.salarios.m <- cbind(cotizantes.m, salarios.aux.m)

# Obtenemos los mejores salarios ordenados (pueden incluir 0), separados por sexo
salarios.top.h <- t(apply(matriz.salarios.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))
salarios.top.m <- t(apply(matriz.salarios.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)
}))

# Identificamos las diferencias entre los salarios
diferencias.h <- t(apply(salarios.top.h, 1, function(fila) {
  abs(diff(fila))
}))
diferencias.m <- t(apply(salarios.top.m, 1, function(fila) {
  abs(diff(fila))
}))

# Cantidad de columnas en las diferencias
columnas.diff <- ncol(diferencias.h) - 1

# Un salario será atípico si es mayor a 5 millones y tiene menos de 12 salarios en un rango de 500 000 colones con ese monto o tiene un salario con una diferencia de más de 500 000 colones al siguiente 
# Iniciamos viendo las diferencias
atipicos.h <- t(apply(diferencias.h, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))
atipicos.m <- t(apply(diferencias.m, 1, function(fila) {
  # Valores mayores a 500 000 serán atípicos
  v.altos <- fila > 500000
  
  # Se identifican las rachas de valores menores a 500 000
  v.bajos <- rle(!(v.altos))
  
  # Vector para marcar atípicos
  resultado <- rep(FALSE, columnas.diff)
  
  # Vector en donde se marcan atípicos si hay rachas menores a 12
  rachas.cortas <-
    with(v.bajos, rep(lengths < 12 & values, lengths))
  
  # Se combinan ambas condiciones en un vector
  resultado[v.altos | rachas.cortas] <- TRUE
  return(resultado)
}))

# Ahora consideramos los atípicos en la matriz de salarios, considerando aquellos que son de más de 5 millones
salarios.top.h <-
  salarios.top.h[, -ncol(salarios.top.h)] * !(atipicos.h * (salarios.top.h[, -ncol(salarios.top.h)] > 5000000))
salarios.top.m <-
  salarios.top.m[, -ncol(salarios.top.m)] * !(atipicos.m * (salarios.top.m[, -ncol(salarios.top.m)] > 5000000))

# Se sacan los 300 mejores salarios, ahora sin los salarios atípicos
salarios.top.h <- t(apply(salarios.top.h, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))
salarios.top.m <- t(apply(salarios.top.m, 1, function(fila) {
  sort(fila, decreasing = TRUE)[1:300]
}))

# Beneficio por vejez, separado por sexo
beneficio.vejez.h <-
  (pmin(300, cuotas.finales.h[which(salida.h == "Retirado")]) / 300) * (rowSums(salarios.top.h[which(salida.h == "Retirado"),]) / rowSums(salarios.top.h[which(salida.h == "Retirado"),] > 9999))
# Hacer la corrección a estados M, en donde las mujeres pueden retirarse a partir de los 63 si cumplen los requisitos
beneficio.vejez.m <-
  (pmin(300, cuotas.finales.m[which(salida.m == "Retirado")]) / 300) * (rowSums(salarios.top.m[which(salida.m == "Retirado"),]) / rowSums(salarios.top.m[which(salida.m == "Retirado"),] > 9999))

# Filas de invalidez
filas.inv.h <- which(salida.h == "Invalido")
filas.inv.m <- which(salida.m == "Invalido")

# Para el beneficio por invalidez, separado por sexo, iniciamos obteniendo la casilla en donde quedaron inválidos
restantes.inv.h <-
  apply(estados.h[filas.inv.h, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })
restantes.inv.m <-
  apply(estados.m[filas.inv.m, ], 1, function(fila) {
    which(fila == "Invalido")[1]
  })

# Se compara si se han tenido las cuotas necesarias
cuotas.binario.h <- mapply(function(i, j) {
  requisitos.inv.h[i, j] <= cuotas.finales.h[i]
}, i = filas.inv.h, j = restantes.inv.h)
cuotas.binario.m <- mapply(function(i, j) {
  requisitos.inv.m[i, j] <= cuotas.finales.m[i]
}, i = filas.inv.m, j = restantes.inv.m)

# Se obtienen las edades para las cuales se invalidó la persona (se pone acá y se borra la anterior que estaba)
edad.final.h <- restantes.inv.h + edades.h[filas.inv.h, 1] - 1
edad.final.m <- restantes.inv.m + edades.m[filas.inv.m, 1] - 1

# En este punto, se ve si las personas pensionadas por invalidez tienen las cuotas necesarias según el inciso b del artículo 6
requisito.cuotas.h <-
  (ifelse(
    ((restantes.inv.h == 1) * (edad.final.h < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.h == 2) * (edad.final.h < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
      ifelse((edad.final.h < 48), rowSums(cotizaciones.h[filas.inv.h, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.h == 1) * (edad.final.h > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.h == 2) * (edad.final.h > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 325:360] > 10000) + cotizaciones.h[filas.inv.h, 1],
                           ifelse(((restantes.inv.h == 3) * (edad.final.h > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 337:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:2]),
                                  ifelse(((restantes.inv.h == 4) * (edad.final.h > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1), ][filas.inv.h, ][, 349:360] > 10000) + rowSums(cotizaciones.h[filas.inv.h, 1:3]),
                                         ifelse((edad.final.h > 47) == 1, rowSums(cotizaciones.h[filas.inv.h, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23
requisito.cuotas.m <-
  (ifelse(
    ((restantes.inv.m == 1) * (edad.final.m < 48)) == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000),
    ifelse(
      ((restantes.inv.m == 2) * (edad.final.m < 48)) == 1,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
      ifelse((edad.final.m < 48), rowSums(cotizaciones.m[filas.inv.m, 1:2]), 0)
    )
  ) > 11) + (ifelse(((restantes.inv.m == 1) * (edad.final.m > 47)) == 1,
                    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 313:360] > 10000),
                    ifelse(((restantes.inv.m == 2) * (edad.final.m > 47)) == 1,
                           rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 325:360] > 10000) + cotizaciones.m[filas.inv.m, 1],
                           ifelse(((restantes.inv.m == 3) * (edad.final.m > 47)) == 1,
                                  rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 337:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:2]),
                                  ifelse(((restantes.inv.m == 4) * (edad.final.m > 47)) == 1,
                                         rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2), ][filas.inv.m, ][, 349:360] > 10000) + rowSums(cotizaciones.m[filas.inv.m, 1:3]),
                                         ifelse((edad.final.m > 47) == 1, rowSums(cotizaciones.m[filas.inv.m, 1:4]), 0)
                                  )
                           )
                    )
  )) > 23

# Si una persona inválida tiene las cuotas necesarias para su edad y cotizó 12 veces en los últimos 24 meses, tiene derecho a recibir pensión
resultado.binario.h <- cuotas.binario.h * requisito.cuotas.h
resultado.binario.m <- cuotas.binario.m * requisito.cuotas.m

# Beneficios por invalidez
beneficio.invalidez.h <-
  ifelse(cuotas.finales.h[filas.inv.h] > 299,
         (rowSums(salarios.top.h[filas.inv.h, ]) / 300),
         ifelse(cuotas.finales.h[filas.inv.h] > 179, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), ifelse(((cuotas.finales.h[filas.inv.h] < 180) * (resultado.binario.h == 1)
         ) == 1, (
           rowSums(salarios.top.h[filas.inv.h, ]) / rowSums(salarios.top.h[filas.inv.h, ] > 9999)
         ), 0)))
beneficio.invalidez.m <-
  ifelse(cuotas.finales.m[filas.inv.m] > 299,
         (rowSums(salarios.top.m[filas.inv.m, ]) / 300),
         ifelse(cuotas.finales.m[filas.inv.m] > 179, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), ifelse(((cuotas.finales.m[filas.inv.m] < 180) * (resultado.binario.m == 1)
         ) == 1, (
           rowSums(salarios.top.m[filas.inv.m, ]) / rowSums(salarios.top.m[filas.inv.m, ] > 9999)
         ), 0)))

# Primero, los índices de las personas que mueren
filas.muerte.h <- which(salida.h == "Fallecido")
filas.muerte.m <- which(salida.m == "Fallecido")

# Se identifican las columnas en la que ocurre la muerte (el año)
col.fallecido.h <-
  apply(estados.h[filas.muerte.h,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

col.fallecido.m <-
  apply(estados.m[filas.muerte.m,], 1, function(fila) {
    which(fila == "Fallecido")[1]
  })

# Edad de la persona al morir para cada sexo
edad.fallecido.h <-
  mapply(function(i, j)
    edades.h[i, j], i = filas.muerte.h, j = col.fallecido.h)

edad.fallecido.m <-
  mapply(function(i, j)
    edades.m[i, j], i = filas.muerte.m, j = col.fallecido.m)

# Se crean dos vectores donde se identifica si al momento de la muerte el afiliado tenía un hijo
hijos.h <- edad.fallecido.h >= 25 & (edad.fallecido.h - 25) < 25
hijos.m <- edad.fallecido.m >= 25 & (edad.fallecido.m - 25) < 25

# Se calcula la pensión sucesoria con base en la pensión por vejez que hubiera recibido (art. 27)
salarios.sucesion.h <- salarios.top.h[filas.muerte.h,]
salarios.sucesion.m <- salarios.top.m[filas.muerte.m,]

beneficio.base.h <- rowSums(salarios.sucesion.h) / rowSums(salarios.top.h[which(salida.h == "Fallecido"),] > 9999)
beneficio.base.m <- rowSums(salarios.sucesion.m) / rowSums(salarios.top.m[which(salida.m == "Fallecido"),] > 9999)

# Se calcula el porcentaje para pensión por viudez según edad del cónyuge por art. 27: 70% si cónyuge ≥ 60, 60% si 50–59, 50% si < 50
porcentaje.viudez.h <- ifelse(edad.fallecido.h >= 60,
                              0.70,
                              ifelse(edad.fallecido.h >= 50, 0.60, 0.50))

porcentaje.viudez.m <- ifelse(edad.fallecido.m >= 60,
                              0.70,
                              ifelse(edad.fallecido.m >= 50, 0.60, 0.50))

# Así como el porcentaje para pensión por orfandad (30% si el hijo califica) art. 27: 30% para hijos menores de 25 años
porcentaje.hijo.h <- ifelse(hijos.h, 0.30, 0)
porcentaje.hijo.m <- ifelse(hijos.m, 0.30, 0)

# Se calcula el beneficio por sucesión (sin validar aún si tiene derecho)
beneficio.conyuge.h <- beneficio.base.h * porcentaje.viudez.h
beneficio.conyuge.m <- beneficio.base.m * porcentaje.viudez.m

beneficio.hijo.h <- beneficio.base.h * porcentaje.hijo.h
beneficio.hijo.m <- beneficio.base.m * porcentaje.hijo.m

# Se verifica si tiene derecho al beneficio por sucesion (art. 18)

# Condición 1: tener al menos 180 cotizaciones totales
requisito.180.h <- cuotas.finales.h[filas.muerte.h] >= 180
requisito.180.m <- cuotas.finales.m[filas.muerte.m] >= 180

# Condición 2: haber cotizado al menos 12 veces en los últimos 24 meses antes de morir, si murió antes de los 24 meses simulados se usan los datos anteriores que están en la base

requisito.24meses.h <-
  ifelse(
    col.fallecido.h == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 337:360] > 10000),
    ifelse(
      col.fallecido.h == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 1),][filas.muerte.h,][, 349:360] > 10000) + cotizaciones.h[filas.muerte.h, 1],
      rowSums(cotizaciones.h[filas.muerte.h, 1:2])
    )
  ) > 11

requisito.24meses.m <-
  ifelse(
    col.fallecido.m == 1,
    rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 337:360] > 10000),
    ifelse(
      col.fallecido.m == 2,
      rowSums(cotizaciones.vp[which(cotizantes.activos$sexo == 2),][filas.muerte.m,][, 349:360] > 10000) + cotizaciones.m[filas.muerte.m, 1],
      rowSums(cotizaciones.m[filas.muerte.m, 1:2])
    )
  ) > 11

# Debe de cumplir ambos requisitos
tiene.derecho.sucesion.h <- requisito.180.h & requisito.24meses.h
tiene.derecho.sucesion.m <- requisito.180.m & requisito.24meses.m

# Se verifica si califica para el derecho o no. En caso de que no se asigna un beneficio = 0
beneficio.conyuge.h <-
  ifelse(tiene.derecho.sucesion.h, beneficio.conyuge.h, 0)
beneficio.hijo.h    <-
  ifelse(tiene.derecho.sucesion.h, beneficio.hijo.h, 0)

beneficio.conyuge.m <-
  ifelse(tiene.derecho.sucesion.m, beneficio.conyuge.m, 0)
beneficio.hijo.m    <-
  ifelse(tiene.derecho.sucesion.m, beneficio.hijo.m, 0)

# Las filas de personas que se retiraron
filas.vejez.h <- which(salida.h == "Retirado")
filas.vejez.m <- which(salida.m == "Retirado")

# Los salario promedio base (prom. de 300 mejores salarios)
salario.referencia.h <- beneficio.vejez.h
salario.referencia.m <- beneficio.vejez.m

# La cuantía básica según salario
cuantia.vejez.h <- cuantia.basica(salario.referencia.h)
cuantia.vejez.m <- cuantia.basica(salario.referencia.m)

# La bonificación por cotizaciones adicionales (exceso sobre 300)
meses.extra.h <- pmax(0, cuotas.finales.h[filas.vejez.h] - 300)
meses.extra.m <- pmax(0, cuotas.finales.m[filas.vejez.m] - 300)
bono.cuotas.h <- meses.extra.h * bono.cotizaciones
bono.cuotas.m <- meses.extra.m * bono.cotizaciones

# La bonificación por postergación (meses en estado "Posterga")
meses.post.h <- 12 * rowSums(postergacion.simulada.h[filas.vejez.h, ])
meses.post.m <- 12 * rowSums(postergacion.simulada.m[filas.vejez.m, ])
bono.post.h <- meses.post.h * bono.postergacion
bono.post.m <- meses.post.m * bono.postergacion

# La tasa de reemplazo final
tasa.vejez.h <- cuantia.vejez.h + bono.cuotas.h + bono.post.h
tasa.vejez.m <- cuantia.vejez.m + bono.cuotas.m + bono.post.m

# Pensión final por vejez
pension.vejez.h <- salario.referencia.h * pmin(tasa.vejez.h, tasa.maxima)
pension.vejez.m <- salario.referencia.m * pmin(tasa.vejez.m, tasa.maxima)

# El salario base
salario.referencia.inv.h <- beneficio.invalidez.h
salario.referencia.inv.m <- beneficio.invalidez.m

# La cuantía básica
cuantia.invalidez.h <- cuantia.basica(salario.referencia.inv.h)
cuantia.invalidez.m <- cuantia.basica(salario.referencia.inv.m)

# La bonificación por cuotas (más de 300)
meses.extra.inv.h <- pmax(0, cuotas.finales.h[filas.inv.h] - 300)
meses.extra.inv.m <- pmax(0, cuotas.finales.m[filas.inv.m] - 300)
bono.cuotas.inv.h <- meses.extra.inv.h * bono.cotizaciones
bono.cuotas.inv.m <- meses.extra.inv.m * bono.cotizaciones

# La tasa de reemplazo
tasa.invalidez.h <- cuantia.invalidez.h + bono.cuotas.inv.h
tasa.invalidez.m <- cuantia.invalidez.m + bono.cuotas.inv.m

# La pensión por invalidez
pension.invalidez.h <- salario.referencia.inv.h * pmin(tasa.invalidez.h, tasa.maxima)
pension.invalidez.m <- salario.referencia.inv.m * pmin(tasa.invalidez.m, tasa.maxima)

# La pensión por sucesión
pension.sucesion.h <- beneficio.conyuge.h + beneficio.hijo.h
pension.sucesion.m <- beneficio.conyuge.m + beneficio.hijo.m

# Filtramos la matriz de estados a partir de las personas con beneficio por vejez
matriz.vejez.h <- estados.h[filas.vejez.h, ]
matriz.vejez.m <- estados.m[filas.vejez.m, ]

# Filtramos la matriz de edades a partir de las personas con beneficio por vejez
edades.vejez.h <- edades.h[filas.vejez.h, ]
edades.vejez.m <- edades.m[filas.vejez.m, ]

# Calculamos en qué año ocurre el retiro por vejez para cada individuo
restantes.ret.h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Retirado")[1]
})

restantes.ret.m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Retirado")[1]
})

# Calculamos en qué año ocurre el fallecimiento para cada individuo
indices.2h <- apply(matriz.vejez.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.vejez.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

### Pensiones por vejez

# Inicializamos las matrices de beneficio con ceros
matriz.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))
matriz.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))

# Construimos la matriz de beneficios para hombres
for (i in 1:nrow(matriz.vejez.h)) {
  
  indice <- indices.2h[i]  # Año en que fallece la i-ésima persona
  
  # Se asigna 1 desde el retiro hasta justo antes del fallecimiento
  matriz.vejez.h[i, restantes.ret.h[i]:(indice - 1)] <- 1 

  edad <- edades.vejez.h[i, indice]  # Edad al fallecer

  # Se calcula la cantidad de años para simular la sobrevivencia del cónyuge
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Se extraen las probabilidades de muerte del cónyuge (mujer) por edad y año
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]

  # Se simula la vida del cónyuge comparando las probabilidades con números aleatorios
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge > vect.aleatorio  # TRUE si muere

  # Se determina cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Se asigna 0.7 al beneficio durante los años en que el cónyuge está vivo
  matriz.vejez.h[i, indice:(indice + indice.3)] <- 0.7
}

# Lo mismo para mujeres
for (i in 1:nrow(matriz.vejez.m)) {
  
  indice <- indices.2m[i]
  matriz.vejez.m[i, restantes.ret.m[i]:(indice - 1)] <- 1
  
  edad <- edades.vejez.m[i, indice]
  
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)
  
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge > vect.aleatorio
  
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1
  
  matriz.vejez.m[i, indice:(indice + indice.3)] <- 0.7
}

# Se construyen matrices con los montos de pensión (monto de pensión asociado al 1 o 0.7 anteriores)

monto.vejez.h <- matrix(as.numeric(0), nrow(matriz.vejez.h), ncol(matriz.vejez.h))

# Se construye una máscara lógica para identificar las columnas (años) posteriores al retiro
mascara <- col(monto.vejez.h) >= restantes.ret.h[row(monto.vejez.h)]

# Se asignan los valores de pensión correspondientes a los años de retiro
monto.vejez.h[mascara] <- pension.vejez.h[row(monto.vejez.h)[mascara]]

# Repetimos el proceso para mujeres
monto.vejez.m <- matrix(as.numeric(0), nrow(matriz.vejez.m), ncol(matriz.vejez.m))
mascara <- col(monto.vejez.m) >= restantes.ret.m[row(monto.vejez.m)]
monto.vejez.m[mascara] <- pension.vejez.m[row(monto.vejez.m)[mascara]]

# Multiplicamos las matrices de beneficios (0, 1, 0.7) por el monto de pensión
matriz.vejez.h <- matriz.vejez.h * monto.vejez.h
matriz.vejez.m <- matriz.vejez.m * monto.vejez.m

# Se impone el tope máximo de 3.5 millones a los beneficios
matriz.vejez.h <- pmin(matriz.vejez.h, 3500000)
matriz.vejez.m <- pmin(matriz.vejez.m, 3500000)

rm(edades.vejez.h, edades.vejez.m, monto.vejez.h, monto.vejez.m)

### Pensiones por invalidez

# Extraemos las filas correspondientes a inválidos
matriz.inv.h <- estados.h[filas.inv.h, ]
matriz.inv.m <- estados.m[filas.inv.m, ]

# Extraemos las edades correspondientes a inválidos
edades.inv.h <- edades.h[filas.inv.h, ]
edades.inv.m <- edades.m[filas.inv.m, ]

# Obtenemos el primer periodo donde se observa el estado "Fallecido"
indices.2h <- apply(matriz.inv.h, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

indices.2m <- apply(matriz.inv.m, 1, function(fila) {
  which(fila == "Fallecido")[1]
})

# Inicializamos las matrices con ceros para hombres y mujeres inválidos
matriz.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
matriz.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))

# Llenamos la matriz de hombres
for (i in 1:nrow(matriz.inv.h)) {
  
  indice <- indices.2h[i]  # Primer año de fallecimiento
  matriz.inv.h[i, restantes.inv.h[i]:(indice - 1)] <- 1  # Periodo de invalidez antes de fallecer
  
  edad <- edades.inv.h[i, indice]  # Edad al fallecer
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - indice + 1)

  # Obtenemos el qx del cónyuge (mujer)
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  
  # Simulamos la vida del cónyuge con aleatoriedad
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge > vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1  # Tiempo que sobrevive el cónyuge

  # Asignamos el porcentaje de pensión según la edad
  if(edad >= 60){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo > vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)  # Máximo hasta que el hijo cumpla 25

    matriz.inv.h[i, indice:(indice + indice.4)] <- 
      matriz.inv.h[i, indice:(indice + indice.4)] + 0.3  # Agregamos el beneficio por hijo

  } else {
    
    matriz.inv.h[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.h[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.h[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para las mujeres
for (i in 1:nrow(matriz.inv.m)) {
  
  indice <- indices.2m[i]
  matriz.inv.m[i, restantes.inv.m[i]:(indice - 1)] <- 1
  
  edad <- edades.inv.m[i, indice]
  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - indice + 1)

  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), indice:(indice + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge > vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  } else if(edad >= 25){
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }

    # Beneficio por hijo (mujeres)
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - indice + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), indice:(indice + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo > vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.inv.m[i, indice:(indice + indice.4)] <- 
      matriz.inv.m[i, indice:(indice + indice.4)] + 0.3
    
  } else {
    
    matriz.inv.m[i, indice:(indice + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 50 - edad):(indice + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.inv.m[i, (indice + 50 - edad):(indice + 59 - edad)] <- 
        matriz.inv.m[i, (indices.2m[i] + 50 - edad):(indices.2m[i] + 59 - edad)] + 0.1
      
      matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] <- 
        matriz.inv.m[i, (indice + 60 - edad):(indice + indice.3)] + 0.1
      
    }
  }
}

# Creamos la matriz de montos para hombres
monto.inv.h <- matrix(as.numeric(0), nrow(matriz.inv.h), ncol(matriz.inv.h))
mascara <- col(monto.inv.h) >= restantes.inv.h[row(monto.inv.h)]
monto.inv.h[mascara] <- pension.invalidez.h[row(monto.inv.h)[mascara]]

# Creamos la matriz de montos para mujeres
monto.inv.m <- matrix(as.numeric(0), nrow(matriz.inv.m), ncol(matriz.inv.m))
mascara <- col(monto.inv.m) >= restantes.inv.m[row(monto.inv.m)]
monto.inv.m[mascara] <- pension.invalidez.m[row(monto.inv.m)[mascara]]

# Aplicamos el monto a cada proporción de pensión
matriz.inv.h <- matriz.inv.h * monto.inv.h
matriz.inv.m <- matriz.inv.m * monto.inv.m

# Aplicamos el tope de pensión máximo de 3.5 millones
matriz.inv.h <- pmin(matriz.inv.h, 3500000)
matriz.inv.m <- pmin(matriz.inv.m, 3500000)

rm(edades.inv.h, edades.inv.m, monto.inv.h, monto.inv.m)

### Pensiones por sucesión

# Se inicializan matrices de ceros para guardar la sucesión de los hombres y mujeres
matriz.suc.h <- matrix(as.numeric(0), nrow(estados.h[filas.muerte.h, ]),
                       ncol(estados.h[filas.muerte.h, ]))

matriz.suc.m <- matrix(as.numeric(0), nrow(estados.m[filas.muerte.m, ]),
                       ncol(estados.m[filas.muerte.m, ]))

# Se calcula la matriz de sucesión de los hombres fallecidos
for(i in 1:nrow(matriz.suc.h)){
  
  edad <- edad.fallecido.h[i]  # Edad del hombre fallecido
  col <- col.fallecido.h[i]    # Columna donde inicia la sucesión

  # Se determina la cantidad de años a simular
  n <- min(nrow(mort.completa.m) - edad, ncol(mort.completa.m) - col + 1)

  # Se obtienen las probabilidades de fallecimiento del cónyuge
  qx.conyuge <- mort.completa.m[cbind((edad + 1):(edad + n), col:(col + n - 1))]

  # Se simulan eventos aleatorios de fallecimiento del cónyuge
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge > vect.aleatorio

  # Se identifica cuántos años sobrevive el cónyuge
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  # Asignación de porcentaje según edad al fallecer y condiciones
  if(edad >= 60){
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.h[i]){  # Si hay hijos
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }

    # Simulamos la mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo > vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.h[i, col:(col + indice.4)] <- 
      matriz.suc.h[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.h[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.h[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.h[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se repite el proceso para mujeres
for(i in 1:nrow(matriz.suc.m)){
  
  edad <- edad.fallecido.m[i]
  col <- col.fallecido.m[i]

  n <- min(nrow(mort.completa.h) - edad, ncol(mort.completa.h) - col + 1)
  
  # Mortalidad del cónyuge hombre
  qx.conyuge <- mort.completa.h[cbind((edad + 1):(edad + n), col:(col + n - 1))]
  vect.aleatorio <- c(1, runif(length(qx.conyuge) - 1))
  estados.conyuge <- qx.conyuge > vect.aleatorio
  indice.3 <- which(estados.conyuge == TRUE)[1] - 1

  if(edad >= 60){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.7
    
  } else if(edad >= 50) {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.6
    
    if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
    
  } else if(hijos.m[i]){
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  
    # Mortalidad del hijo
    n <- min(nrow(mort.hijos) - edad + 25, ncol(mort.hijos) - col + 1)
    
    qx.hijo <- mort.hijos[cbind((edad - 24):(edad - 25 + n), col:(col + n - 1))]
    
    vect.aleatorio <- c(1, runif(length(qx.hijo) - 1))
    
    estados.hijo <- qx.hijo > vect.aleatorio
    
    indice.4 <- which(estados.hijo == TRUE)[1] - 1
    
    indice.4 <- min(indice.4, (49 - edad), na.rm = TRUE)

    matriz.suc.m[i, col:(col + indice.4)] <- 
      matriz.suc.m[i, col:(col + indice.4)] + 0.3

  } else {
    
    matriz.suc.m[i, col:(col + indice.3)] <- 0.5
    
    if((edad + indice.3) >= 50 & (edad + indice.3) < 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + indice.3)] + 0.1
      
    } else if((edad + indice.3) >= 60){
      
      matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] <- 
        matriz.suc.m[i, (col + 50 - edad):(col + 59 - edad)] + 0.1
      
      matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] <- 
        matriz.suc.m[i, (col + 60 - edad):(col + indice.3)] + 0.1
      
    }
  }
}

# Se asigna el monto del beneficio base solo a los que tienen derecho a sucesión
sucesion.aux.h <- ifelse(tiene.derecho.sucesion.h, beneficio.base.h, 0)
sucesion.aux.m <- ifelse(tiene.derecho.sucesion.m, beneficio.base.m, 0)

# Se crean matrices de monto por sucesión con ceros
monto.suc.h <- matrix(as.numeric(0), nrow(matriz.suc.h), ncol(matriz.suc.h))
mascara <- col(monto.suc.h) >= col.fallecido.h[row(monto.suc.h)]  # Posiciones válidas
monto.suc.h[mascara] <- sucesion.aux.h[row(monto.suc.h)[mascara]]  # Se asignan los montos

# Se repite el proceso para mujeres
monto.suc.m <- matrix(as.numeric(0), nrow(matriz.suc.m), ncol(matriz.suc.m))
mascara <- col(monto.suc.m) >= col.fallecido.m[row(monto.suc.m)]
monto.suc.m[mascara] <- sucesion.aux.m[row(monto.suc.m)[mascara]]

# Se multiplica la proporción asignada por el monto base
matriz.suc.h <- matriz.suc.h * monto.suc.h
matriz.suc.m <- matriz.suc.m * monto.suc.m

# Se limita el monto máximo de la pensión por sucesión a 3.5 millones
matriz.suc.h <- pmin(matriz.suc.h, 3500000)
matriz.suc.m <- pmin(matriz.suc.m, 3500000)

# Limpieza de variables temporales
rm(qx.conyuge, vect.aleatorio, estados.conyuge, indice.3, qx.hijo, estados.hijo,
   indice.4, edad, col, mascara, monto.suc.h, monto.suc.m, sucesion.aux.h, 
   sucesion.aux.m, n, indice)

### Activo actuarial

# Se crea una lista con las 6 matrices calculadas
matrices.pension <- list(matriz.vejez.h, matriz.vejez.m, matriz.inv.h, 
                         matriz.inv.m, matriz.suc.h, matriz.suc.m)

# Vector que tendrá el monto de las cotizaciones de los pensionados
cotizacion.pensiones <- rep(0, length(matrices.pension))

# Se itera sobre cada matriz para determinar el monto de las cotizaciones en la misma
for(i in 1:length(matrices.pension)){
  
  indices <- which(matrices.pension[[i]] > 2000000, arr.ind = TRUE)[, "col"]
  
  mayores.2mill <- matrices.pension[[i]][matrices.pension[[i]] > 2000000]
  
  cotizacion.pensiones[i] <- sum(0.05 * mayores.2mill * s[indices])
  
}

# Se suman las cotizaciones de los pensionados de cada matriz
cotizacion.pensiones <- sum(cotizacion.pensiones)

salarios.finales <- rbind(salario.estoc.h * cotizaciones.h / 12, 
                          salario.estoc.m * cotizaciones.m / 12)

# Se crea la matriz con los factores de descuento para determinar las cotizaciones de los trabajadores
matriz.descuento <- matrix(rep(s, times = nrow(salarios.finales)), 
                           nrow(salarios.finales), byrow = TRUE)

# Se calcula la masa salarial
masa.salarial <- sum(salarios.finales * matriz.descuento)

# Se calcula la contribución de los trabajadores
cotizacion.trab <- masa.salarial * 0.15

# Se calcula el activo actuarial
total.activo <- cotizacion.pensiones + cotizacion.trab + reserva.ini

rm(mayores.2mill, indices)

### Flujos de balance

# Inicializamos los vectores para determinar los años críticos
reserva <- c(reserva.ini)
total.egresos <- c()
cotizaciones <- c()
rends <- c()

# Inicializamos el vector de años críticos
annos <- c(0, 0, 0)

# Iteramos sobre cada año
for(i in 1:ncol(salarios.finales)){
  
  # Cotizaciones de los trabajadores
  cotizaciones <- c(cotizaciones, (sum(salarios.finales[, i]) * 0.15))
  
  # Costo de las pensiones
  costo.pens <- sum(Reduce("+", sapply(matrices.pension, function(mat) sum(mat[, i]))))
  
  # Gasto administrativo del SEM
  sem <- costo.pens * (12/13) * 0.085
  
  # Total de egresos
  total.egresos <- c(total.egresos, costo.pens + sem)
  
  # Rendimientos
  rends <- c(rends, ifelse((reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real > 0, 
                           (reserva[i] + (cotizaciones[i] - total.egresos[i]) / 2) * interes.real, 0))
  
  # Total de ingresos
  total.ingresos <- cotizaciones[i] + rends[i]
  
  # Guardamos la reserva final (reserva inicial del siguiente año)
  reserva <- c(reserva, (reserva[i] + total.ingresos - total.egresos[i] + sem))
}

# Eliminamos la última reserva final
reserva <- reserva[-length(reserva)]

# Determinamos los años críticos
idx <- which(total.egresos > cotizaciones)[1]
annos[1] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends))[1]
annos[2] <- idx + 2024

idx <- which(total.egresos > (cotizaciones + rends + reserva))[1]
annos[3] <- idx + 2024

### Pasivo actuarial

# Se crea la matriz con las tasas de descuento para cada año para determinar el total de pensiones
n.filas <- max(sapply(matrices.pension, nrow))
matriz.descuento <- matrix(rep(s, times = n.filas), nrow = n.filas, byrow = TRUE)

# Iteramos sobre cada matriz
for(i in 1:length(matrices.pension)){
  
  # Traemos el monto de la pensión a valor presente
  matrices.pension[[i]] <- matrices.pension[[i]] * matriz.descuento[1:nrow(matrices.pension[[i]]), ]
  
}

# Se calcula el total de las pensiones
total.pensiones <- sum(sapply(matrices.pension, sum))

# Se calcula el monto del SEM
sem <- total.pensiones * (12/13) * 0.085

# Por último se calcula el pasivo actuarial
total.pasivo <- total.pensiones + sem

### Indicadores de solvencia

# Agregamos los indicadores a sus respectivas listas
razon.solvencia <- append(razon.solvencia, (total.activo / total.pasivo))
annos.crit <- append(annos.crit, list(annos))
balance <- append(balance, list(c(total.activo, total.pasivo)))
prima.media <- append(prima.media, ((total.pasivo - reserva.ini) / masa.salarial))

# Actualizamos los promedios para el ciclo while
prom.antes <- prom.despues
prom.despues <- mean(unlist(razon.solvencia))

### Beneficios devengados

# Beneficio devengado por vejez
ben.dev.vejez.h <-
  rowSums(matrices.pension[[1]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][filas.vejez.h] / cuotas.finales.h[filas.vejez.h])
ben.dev.vejez.m <-
  rowSums(matrices.pension[[2]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][filas.vejez.m] / cuotas.finales.m[filas.vejez.m])

# Beneficio devengado por invalidez
ben.dev.inv.h <-
  rowSums(matrices.pension[[3]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][filas.inv.h] / cuotas.finales.h[filas.inv.h])
ben.dev.inv.m <-
  rowSums(matrices.pension[[4]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][filas.inv.m] / cuotas.finales.m[filas.inv.m])

# Beneficio devengado por sucesión
ben.dev.suc.h <-
  rowSums(matrices.pension[[5]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 1)][filas.muerte.h] / cuotas.finales.h[filas.muerte.h])
ben.dev.suc.m <-
  rowSums(matrices.pension[[6]]) * (cotizantes.activos$cotizaciones[which(cotizantes.activos$sexo == 2)][filas.muerte.m] / cuotas.finales.m[filas.muerte.m])

# Se guardan los beneficios devengados en listas
beneficio.devengado.vejez <- append(beneficio.devengado.vejez, (sum(ben.dev.vejez.h) + sum(ben.dev.vejez.m)))
beneficio.devengado.invalidez <- append(beneficio.devengado.invalidez, (sum(ben.dev.inv.h) + sum(ben.dev.inv.m)))
beneficio.devengado.sucesion <- append(beneficio.devengado.sucesion, (sum(ben.dev.suc.h) + sum(ben.dev.suc.m)))
}
end.time <- Sys.time()

end.time - start.time
```

### Flujo escenario final

(Esto es para sacar las métricas cuando ya se hicieron todas las iteraciones)
(Hay que tener en cuenta cuando la masa salarial se hace 0)

```{r metricas_base}
reserva <- reserva.ini

tasa.ingresos <- c()

prima.reparto <- c()

razon.fondo.cont <- c()

for(i in 1:ncol(salarios.finales)){
  
  ms <- sum(salarios.finales[, i])
  
  cotizaciones <- ms * 0.15
  
  costo.pens <- sum(Reduce("+", lapply(matrices.pension, function(mat) sum(mat[, i]))))
  
  sem <- costo.pens * (12/13) * 0.085
  
  total.egresos <- costo.pens + sem
  
  rends <- ifelse((reserva + (cotizaciones - total.egresos) / 2) * interes.real > 0, 
                  (reserva + (cotizaciones - total.egresos) / 2) * interes.real, 0)
  
  total.ingresos <- cotizaciones + rends
  
  tasa.ingresos <- c(tasa.ingresos, total.ingresos / ms)
  
  prima.reparto <- c(prima.reparto, total.egresos / ms)
  
  razon.fondo.cont <- c(razon.fondo.cont, total.egresos / reserva)
  
  reserva <- reserva + total.ingresos - total.egresos + sem
  
}
```

# Resultados base

## Salarios base

Se grafican los salarios ajustados por inflación.

```{r grafico_cotizantes}
ggplot(cotizantes.anualizado.VP.largo, aes(x = año, y = salario.ajustado)) +
  geom_line(stat = "summary", fun = mean, color = "steelblue", linewidth = 1) +
  labs(title = "Comportamiento de salarios ajustados por inflación (1995-2024)",
       x = "Año",
       y = "Salario ajustado (Valor presente)") +
  theme_minimal()
```

Se grafica la curva salarial sin ningún método de suavizado.

```{r grafico_curva_sin_suavizar}
ggplot(curva.general, aes(x = proyeccion.edad, y = salario.promedio)) +
  geom_line(color = "darkgreen", linewidth = 1.2) +
  labs(title = "Curva salarial general promedio",
       x = "Edad proyectada",
       y = "Salario promedio") +
  theme_minimal()
```

Se procede con el cálculo de la curva, pero de manera suavizada.

```{r curva_suavizada}
ggplot(curva.general, aes(x = proyeccion.edad, y = salario.promedio)) +
  geom_line(color = "darkgreen", alpha = 0.4) +  # línea original, más clara
  geom_smooth(method = "loess", color = "blue", linewidth = 1.2, se = FALSE) +
  labs(title = "Curva salarial general suavizada",
       x = "Edad proyectada",
       y = "Salario promedio") +
  theme_minimal()
```

Seguidamente se realiza un ejemplo donde se recibe el ID y la función imprime su curva salarial para su análisis.

```{r grafico_funcion_proyectar_persona}
graficar.proyeccion.id("097434")
```

## Razón de solvencia

Ahora se procede con las razones de solvencia. Inicialmente, se tiene el promedio de las razones de solvencia para este caso:

```{r rs_base}
(prom.rs <- mean(unlist(razon.solvencia)))
```

Se pueden observar en un gráfico de densidad las distintas razones de solvencia.

```{r densidad_rs_base}
# Se crea un dataframe con los datos
data.rs <- data.frame(rs = unlist(razon.solvencia))

# Gráfico de las razones de solvencia
ggplot(data.rs, aes(x = rs)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.rs,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.rs,
    y = 0.5,
    label = "Media de las RS",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón de solvencia",
       y = "Densidad") +
  theme_minimal()
```

## Años críticos

En primer lugar, se obtendrá un promedio de los años críticos.

```{r annos_criticos_base}
# Se guarda como matriz
annos.crit.mat <- do.call(cbind, annos.crit)

# Se redondean los promedios
round(rowMeans(annos.crit.mat, na.rm = TRUE), 0)
```

Los anteriores están ordenados en primer, segundo y tercer año crítico respectivamente. Si los resultados son **NaN** significa que en ningún caso se llega a ese año crítico.

Para el caso en estudio, usualmente solo se llega al primer año crítico entre las iteraciones, por lo que se grafica ese caso.

```{r grafico_annos_criticos_base}
# Se guardan los primeros años críticos en un DataFrame
df.annos.crit <- data.frame(primer_momento = annos.crit.mat[1, ])

# Se grafican los primeros momentos correspondientes
ggplot(df.annos.crit, aes(x = primer_momento)) +
  geom_histogram(
    aes(y = after_stat(count / sum(count))),
    bins = 2,
    fill = "#A34022",
    color = "black"
  ) +
  labs(x = "Año",
       y = "Densidad")
theme_minimal()
```

## Prima media

Como se menciona en el reglaemnto, se procede con la prima media. Inicialmente se obtiene el promedio de estas:

```{r prima_media_base}
(prom.pm <- mean(unlist(prima.media)))
```

se observa que este es negativo debido a que la reserva inicial supera al pasivo actuarial.

Un análisis más detallado se observa en el siguiente gráfico:

```{r grafico_prima_media_base}
# Se crea un dataframe con los datos
data.pm <- data.frame(pm = unlist(prima.media))

# Gráfico de las primas medias niveladas
ggplot(data.pm, aes(x = pm)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = prom.pm,
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = prom.pm,
    y = 2,
    label = "Media de la prima media",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Prima media nivelada",
       y = "Densidad") +
  theme_minimal()
```

## Razón del fondo de contingencia

Se muestra la razón del fondo de contingencia de la última simulación, visualizada en un gráfico.

```{r grafico_rc_base}
# Se crea un dataframe con los datos
data.rc <- data.frame(rc = razon.fondo.cont)

# Gráfico de las razones del fondo de contingencia
ggplot(data.rc, aes(x = rc)) +
  geom_density(color = "#A34022", linewidth = 1.2) +
  geom_vline(
    xintercept = mean(razon.fondo.cont),
    color = "#F59A3A",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "text",
    x = mean(razon.fondo.cont),
    y = 2,
    label = "Media de la RC",
    color = "#F59A3A",
    angle = 90,
    vjust = -0.5,
    size = 3.5
  ) +
  labs(x = "Razón del fondo de contingencia",
       y = "Densidad") +
  theme_minimal()
```

una vez más, se aprecia que la reserva es muy grande en comparación con los egresos, lo cual produce resultados muy cercanos a 0 para esta métrica.

