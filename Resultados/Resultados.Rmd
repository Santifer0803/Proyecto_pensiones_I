---
title: "Resultados"
author: "Alejandro Brenes, Santiago Fernández, Eyeri Méndez y Erick Venegas"
date: "`r Sys.Date()`"
output: html_document
---

# Preparación inicial

## Librerías

Inicialmente, cargamos las librerías necesarias para el desarrollo del modelo.

```{r librerias, message = FALSE, warning = FALSE}
pacman::p_load(data.table,
               janitor,
               readxl,
               tidyverse,
               dplyr,
               lubridate,
               zoo,
               purrr,
               tidyr)
```

## Datos del régimen

Se leen las bases de cotizantes y pensionados.

```{r carga_cotpen, message = FALSE, warning = FALSE}
cotizantes <- read_excel("data/BD_Cotizantes.xlsx")
pensionados <- read_excel("data/BD_Pensionados.xlsx")
```

Se realizan algunas correcciones de formato en los pensionados y en los cotizantes.

```{r correcciones_cotpen}
# Se cambian los nombres de las columnas no numéricas de los cotizantes
cotizantes <- cotizantes %>% clean_names()

# Se corrigen los nombres de las columnas de la base de cotizantes
colnames(cotizantes)[4:363] <- format(seq(
  from = ymd("1995-01-01"),
  to = ymd("2024-12-01"),
  by = "1 month"
), "%m-%Y")

# Se corrigen los nombres de la base de pensionados
pensionados <- pensionados %>% clean_names() %>% select(-c("x9"))
```

## Probabilidades de muerte

Se cargan los datos de mortalidad dinámmicos de la SUPEN.

```{r carga_mort}
mortalidad <- read_excel("data/mortalidad.xls")
```

Las probabilidades aparecen como caracteres, por lo que se realiza el cambio correspondiente.

```{r correcciones_mort}
# Se cambia el formato necesario
mortalidad$qx <- as.numeric(mortalidad$qx)

# Se guarda como DataTable
mortalidad <- setDT(mortalidad)
```

## Probabilidades de invalidez

Se procede a cargar las probabilidades de invalidez.

```{r carga_inv}
invalidez <- read_excel("data/invalidez.xlsx")
```

Todas las columnas salen como caracteres, por lo que se cambian.

```{r correcciones_inv}
# Se ponen las edades como números enteros
invalidez$Edad <- as.integer(invalidez$Edad)

# Se corrigen las probabilidades
invalidez$Hombres <- as.numeric(invalidez$Hombres)
invalidez$Mujeres <- as.numeric(invalidez$Mujeres)

# Se corrigen los nombres a un formato más simple
invalidez <- invalidez %>% clean_names()

# Se guarda como DataTable
invalidez <- setDT(invalidez)
```

# Modelo básico

## Parte determinista

En esta sección se concentran las variables invariantes. Es decir, aquellas que no cambiarán durante las iteraciones del modelo.

```{r deterministica_base}
### Beneficios de los cotizantes sin contar estado ###

# Se inicia creando la matriz de edades de los cotizantes, iniciando en la edad del 2025
edades <-
  matrix((2025 - year(cotizantes$fec_nac)),
         nrow = nrow(cotizantes),
         ncol = 95,
         byrow = FALSE
  )

# Se pone el año en cada columna
colnames(edades) <- format(seq(
  from = ymd("2025-01-01"),
  to = ymd("2119-01-01"),
  by = "1 year"
), "%Y")

# Se cambia la edad en cada columna
for (i in 2:ncol(edades)) {
  edades[, i] <- edades[, (i - 1)] + 1
}

# Se corrije la edad máxima a 115
edades <- ifelse(edades > 115, 115, edades)

# Se separan las edades por sexo
edades.h <- edades[which(cotizantes$sexo == 1), ]
edades.m <- edades[which(cotizantes$sexo == 2), ]

# Se eliminan las edades conjuntas
rm(edades)

### Distintos estados a considerar ###

# Probabilidades de invalidez por sexo
inv.h <-
  matrix(
    invalidez[match(edades.h, edad), hombres],
    ncol = ncol(edades.h),
    nrow = nrow(edades.h),
    byrow = FALSE
  )
inv.m <-
  matrix(
    invalidez[match(edades.m, edad), mujeres],
    ncol = ncol(edades.m),
    nrow = nrow(edades.m),
    byrow = FALSE
  )

# Se cambia el nombre de las columnas de la matriz ded invalidez
colnames(inv.h) <- colnames(edades.h)
colnames(inv.m) <- colnames(edades.m)

# Para las probabilidades de muerte, se inicia creando las matrices vacías
mort.h <- matrix(0, nrow = nrow(edades.h), ncol = ncol(edades.h))
mort.m <- matrix(0, nrow = nrow(edades.m), ncol = ncol(edades.m))

# Se corrigen los nombres de sus columnas
colnames(mort.h) <- colnames(edades.h)
colnames(mort.m) <- colnames(edades.m)

# Se agregan las probabilidades por cada año (columna), para ambos sexos
for (i in 1:ncol(mort.h)) {
  mort.h[, i] <-
    mortalidad[sex == 1 &
                 year == as.double(colnames(mort.h)[i])][.(edad = edades.h[, i]), on = .(edad), qx]
  mort.m[, i] <-
    mortalidad[sex == 2 &
                 year == as.double(colnames(mort.m)[i])][.(edad = edades.m[, i]), on = .(edad), qx]
}

# Se crea una lista para guardar los estados de invalidez y muerte de los cotizantes
lista.estados.h <- list()
lista.estados.m <- list()
```


## Parte estocástica

En esta sección se encuentra todo objeto que sea, o dependa, de algún elemento estocástico. Son los factores que varían en cada una de las iteraciones del modelo en alguna forma.

```{r estocastica_base}
### Beneficios de los cotizantes sin contar estado ###



### Distintos estados a considerar ###

# Matriz de uniformes para comparar con las prob. de muerte e invalidez
estado.h <-
  matrix(runif((ncol(mort.h) * nrow(mort.h))), nrow = nrow(mort.h), ncol = ncol(mort.h))
estado.m <-
  matrix(runif((ncol(mort.m) * nrow(mort.m))), nrow = nrow(mort.m), ncol = ncol(mort.m))

# Comparación de matrices, en el primer espacio está la invalidez y en el segundo la muerte
lista.estados.h[[1]] <- inv.h >= estado.h
lista.estados.h[[2]] <-
  t(apply((mort.h >= estado.h) * ifelse(lista.estados.h[[1]] == 1, 0, 1), 1, function(fila) {
    cumsum(fila) > 0
  }))
lista.estados.m[[1]] <- inv.m >= estado.m
lista.estados.m[[2]] <-
  t(apply((mort.m >= estado.m) * ifelse(lista.estados.m[[1]] == 1, 0, 1), 1, function(fila) {
    cumsum(fila) > 0
  }))
```

# Parte Deterministica

Se crea la función que permite anualizar los salarios en otro data frame.

```{r funcion_anualizar}
meses.to.annos <- function(df, columnas_excluir, anno_inicio = 1995) {
  # Se extrae el nombre de las columnas mensuales
  columnas_mensuales <- setdiff(names(df), columnas_excluir)
  
  # Se ordena los nombres mensuales cronológicamente
  columnas_mensuales <- sort(columnas_mensuales)

  # Se calcula la cantidad de años completos
  n_meses <- length(columnas_mensuales)
  n_annos <- floor(n_meses / 12)
  
  nombres_annos <- as.character(seq(anno_inicio, by = 1, length.out = n_annos))
  
  # Se calcula los promedios anuales
  annos <- lapply(1:n_annos, function(i) {
    cols <- columnas_mensuales[((i - 1) * 12 + 1):(i * 12)]
    rowMeans(df[, cols], na.rm = TRUE)
  })
  
  # Se crea DF de promedios
  df_anual <- as.data.frame(annos)
  names(df_anual) <- nombres_annos
  
  # Se combina columnas fijas y promedios anuales
  df_final <- cbind(df[, columnas_excluir], df_anual)
  return(df_final)
}
```

```{r convertir_columnas}
columnas.excluir <- c("id", "fec_nac", "sexo") # Variable auxiliar

# Se crea DF con salarios anualizados.
cotizantes.anualizado <- meses.to.annos(cotizantes, columnas.excluir)
rm(columnas.excluir) # Se borra var. Auxiliar
rm(meses.to.annos)
```

Se crea un nuevo data frame donde está la información con los salarios anualizados.

Se cambia el formato de las columnas.

```{r formato_fecha}
# Se establece el tipo de variable fecha de la columna
cotizantes.anualizado$fec_nac <- as.Date(cotizantes.anualizado$fec_nac, 
                                         format = "%Y/%m/%d")

# Se agrega nueva variable edad al df
cotizantes.anualizado$edad <- 2024 - as.numeric(format(cotizantes.anualizado$fec_nac, "%Y"))

# Se establece el tipo de variable fecha de la columna
cotizantes$fec_nac <- as.Date(cotizantes$fec_nac, 
                                         format = "%Y/%m/%d")

# Se agrega nueva variable edad al df
cotizantes$edad <- 2024 - as.numeric(format(cotizantes$fec_nac, "%Y"))
```

Se carga la base de datos de inflación para su posterior uso.

```{r obtener_inflacion}
# Se cargan los datos
inflacion <- suppressMessages(read_excel("data/inflacion_mundial.xls"))

# Se filtran para tener solo los de Costa Rica
inflacion_cr <- inflacion %>%
  filter(`Data Source` %in% c("Costa Rica", "Country Name"))

inflacion_cr <- inflacion_cr[, -c(2, 3, 4)]
inflacion_cr[1, 1] <- "Año"

colnames(inflacion_cr) <- as.character(inflacion_cr[1, ])

inflacion_cr <- as.data.frame(t(inflacion_cr))
colnames(inflacion_cr) <- as.character(inflacion_cr[1, ])
inflacion_cr <- inflacion_cr[-1, ]

# Se agrega el valor de 2024
inflacion_2024 <- data.frame("Año" = 2024, "Costa Rica" = 0.84)
colnames(inflacion_2024) <- colnames(inflacion_cr)
inflacion_cr <- rbind(inflacion_cr, inflacion_2024)

# Se reasignan las filas con numeración normal (1, 2, 3, ...)
row.names(inflacion_cr) <- NULL

# Se pasan las columnas a tipo numérico
inflacion_cr <- inflacion_cr %>%
  mutate(across(c(1, 2), as.numeric))

rm(inflacion)
rm(inflacion_2024)
```

Se calcula una nueva columna para la matriz, la cual contiene la información del factor acumulativo por cada año, esto con el objetivo de que se multiplique el factor multiplicativo por el salario del respecto año para que éste se acumule hasta el año 2024.

```{r factor_acumulado}
# Se actualiza la tasa, para utilizar en cálculos en forma de porciento.
inflacion_cr$`Costa Rica` <- inflacion_cr$`Costa Rica`/100

inflacion_cr$factor_acumulado <- sapply(inflacion_cr$Año, function(a) {
  if (a == 2024) {
    return(1)
  } else {
    años_a_usar <- inflacion_cr$Año >= a & inflacion_cr$Año <= 2024
    return(prod(1 + inflacion_cr$`Costa Rica`[años_a_usar]))
  }
})
```

Se procede con el cálculo del Valor Presente de todos los salarios de la base, donde se toma como tasa de acumulación, la inflación observada en el respectivo año.

```{r valor_presente}
columnas.años <- as.character(1995:2024)

cotizantes.anualizado.VP <- cotizantes.anualizado

for (año in columnas.años) {
  año.num <- as.numeric(año)
  factor <- inflacion_cr$factor_acumulado[inflacion_cr$Año == año.num]
  
  if (length(factor) == 1 && !is.na(factor)) {
    cotizantes.anualizado.VP[[año]] <- as.numeric(cotizantes.anualizado[[año]]) / factor
  }
}

```

Para graficar, se debe pasar la base de datos a formato largo para su visualización.

```{r formato_largo}
# Convertir columnas de años (wide) a largo
cotizantes.anualizado.VP.largo <- cotizantes.anualizado.VP %>%
  pivot_longer(cols = all_of(columnas.años),
               names_to = "año",
               values_to = "salario.ajustado") %>%
  mutate(año = as.numeric(año))  

rm(factor)
rm(año.num)
rm(año)
rm(columnas.años)
```

Se grafican los salarios ajustados por inflación.

```{r grafico_cotizantes}
ggplot(cotizantes.anualizado.VP.largo, aes(x = año, y = salario.ajustado)) +
  geom_line(stat = "summary", fun = mean, color = "steelblue", size = 1) +
  labs(title = "Comportamiento de salarios ajustados por inflación (1995-2024)",
       x = "Año",
       y = "Salario ajustado (Valor presente)") +
  theme_minimal()
```

Se procede con la proyección de los salarios de manera brusca, es decir, se utilizan los datos sin suavizar.

```{r salarios_por_edad}
salarios.por.edad <- cotizantes.anualizado %>%
  group_by(edad) %>%
  summarise(promedio.salario.2024 = mean(`2024`, na.rm = TRUE)) %>%
  arrange(edad) %>%
  mutate(tasa.incremento = promedio.salario.2024 / lag(promedio.salario.2024))
```

Se realiza la proyección.

```{r proyeccion}
salarios.por.edad$tasa.incremento[1] = salarios.por.edad$tasa.incremento[2]
tasas.ext <- salarios.por.edad$tasa.incremento

names(tasas.ext) <- salarios.por.edad$edad

proyeccion.salarios <- cotizantes.anualizado.VP %>%
  select(id, edad, salario.2024 = `2024`) %>%
  rowwise() %>%
  mutate(proyeccion = list({
    edad.i <- edad
    salario.i <- salario.2024
    resultados <- tibble(
      edad = edad.i,
      salario = salario.i
    )
    # 95 años hacia adelante
    for (anio in 1:95) {
      edad.i <- edad.i + 1
      if (edad.i < 65) {
        tasa.i <- tasas.ext[as.character(edad.i - 1)]
        if (is.na(tasa.i)) break
        salario.i <- salario.i * tasa.i
      } else {
        # A partir de 65 años tasa = 1 (salario constante)
        salario.i <- salario.i
      }
      resultados <- add_row(resultados, edad = edad.i, salario = salario.i)
    }
    resultados
  })) %>%
  unnest(proyeccion, names_sep = ".")
```
 
Se limpia el ambiente de las variables que fueron auxiliares.

```{r}
rm(tasas.ext)
```
 
Se grafica la curva salarial sin ningún método de suavizado.

```{r grafico_curva_sin_suavizar}
curva.general <- proyeccion.salarios %>%
  group_by(proyeccion.edad) %>%
  summarise(salario.promedio = mean(proyeccion.salario, na.rm = TRUE))

ggplot(curva.general, aes(x = proyeccion.edad, y = salario.promedio)) +
  geom_line(color = "darkgreen", size = 1.2) +
  labs(title = "Curva salarial general promedio",
       x = "Edad proyectada",
       y = "Salario promedio") +
  theme_minimal()
```

Se procede con el cálculo de la curva, pero de manera suavizada.

```{r curva_suavizada}
ggplot(curva.general, aes(x = proyeccion.edad, y = salario.promedio)) +
  geom_line(color = "darkgreen", alpha = 0.4) +  # línea original, más clara
  geom_smooth(method = "loess", color = "blue", size = 1.2, se = FALSE) +
  labs(title = "Curva salarial general suavizada",
       x = "Edad proyectada",
       y = "Salario promedio") +
  theme_minimal()
```


Se proyecta en un gráfico a un individuo en particular, utilizando los datos crudos de las tasas de incremento, con la finalidad de que se observe el comportamiento de la proyección.

El siguiente código tiene la finalidad de suavizar las tasas de incremento, lo que provocará que la curva salarial tenga un comportamiento menos errático. Además, el cálculo de estos valores es de utilidad a la hora de proyectar los salarios de cada individuo.

```{r obtencion_datos_suavizados}
modelo.loess <- loess(salario.promedio ~ proyeccion.edad, data = curva.general)

curva.suavizada <- curva.general %>%
  mutate(salario.suavizado = predict(modelo.loess, newdata = data.frame(proyeccion.edad = proyeccion.edad)))

curva.suavizada <- curva.suavizada %>%
  arrange(proyeccion.edad) %>%  
  mutate(
    tasa.incremento = salario.suavizado / lag(salario.suavizado)
  )

curva.suavizada$tasa.incremento[1] <- curva.suavizada$tasa.incremento[2]
```


```{r funcion_proyectar_persona}
graficar.proyeccion.id <- function(persona.id) {
  datos.iniciales <- cotizantes.anualizado.VP.largo %>%
    filter(id == persona.id, año == 2024) %>%
    select(id, edad, salario.2024 = salario.ajustado) %>%
    distinct()

  if (nrow(datos.iniciales) == 0) {
    stop("ID no encontrado en la base.")
  }

  edad.inicial <- datos.iniciales$edad
  salario.actual <- datos.iniciales$salario.2024

  proyeccion <- tibble(
    edad = edad.inicial,
    salario = salario.actual
  )

  salario.i <- salario.actual
  edad.i <- edad.inicial

  for (i in 1:95) {
    edad.i <- edad.i + 1
    tasa.i <- curva.suavizada %>%
      filter(proyeccion.edad == edad.i) %>%
      pull(tasa.incremento)

    if (length(tasa.i) == 0 || is.na(tasa.i)) {
      tasa.i <- 1
    }

    salario.i <- salario.i * tasa.i

    proyeccion <- add_row(proyeccion, edad = edad.i, salario = salario.i)
  }

  ggplot(proyeccion, aes(x = edad, y = salario)) +
    geom_line(color = "purple", size = 1.2) +
    labs(title = paste("Curva salarial proyectada para ID:", persona.id),
         x = "Edad proyectada",
         y = "Salario proyectado") +
    theme_minimal()
}
```

Se generaliza la forma de consultar alguna observación de la base, donde solo se recibe el ID, y la función imprime su curva salarial para su análisis. 

```{r grafico_funcion_proyectar_persona}
graficar.proyeccion.id("097434")
```
se debe crear un nuevo dataframe en el cual se tenga en valor presente las cotizaciones realizadas.

```{r Valor_presente_cotizantes}
# Extraemos todos los nombres de las columnas que tengan formato "MM-YYYY"
columnas.mensuales <- grep("^\\d{2}-\\d{4}$", colnames(cotizantes), value = TRUE)

cotizantes.VP <- cotizantes

for (col in columnas.mensuales) {
  # Extraemos el año del nombre de la columna, asumiendo formato "MM-YYYY"
  año <- as.numeric(sub(".*-(\\d{4})$", "\\1", col))
  
  # Buscamos el factor acumulado para ese año
  factor <- inflacion_cr$factor_acumulado[inflacion_cr$Año == año]
  
  if (length(factor) == 1 && !is.na(factor)) {
    # Dividimos la columna mensual por el factor para traer a valor presente
    cotizantes.VP[[col]] <- cotizantes[[col]] / factor
  } else {}
}

rm(año)
rm(col)
rm(columnas.mensuales)
rm(factor)
```

Se calcula el total de cotizaciones por persona.

```{r total_cotizaciones}
cotizantes.VP <- cotizantes.VP %>%
  rowwise() %>%
  mutate(cotizaciones = sum(c_across(`01-1995`:`12-2024`) >= 10000, na.rm = TRUE)) %>%
  ungroup()
```

```{r numero_cotizaciones_2023}
meses.2023 <- paste0(sprintf("%02d", 1:12), "-2023")

cotizantes.VP <- cotizantes.VP %>%
  rowwise() %>%
  mutate(cotizaciones.2023 = sum(c_across(all_of(meses.2023)) >= 10000, na.rm = TRUE)) %>%
  ungroup()

cotizantes.VP <- cotizantes.VP %>%
  mutate(edad = floor(interval(start = fec_nac, end = Sys.Date()) / years(1)))
rm(meses_2023)
```


```{r cotizaciones_promedio_edad}
cotizaciones.promedio.edad <- cotizantes.VP %>%
  group_by(edad) %>%
  summarise(promedio.cotizaciones = round(mean(cotizaciones.2023, na.rm = TRUE))) %>%
  ungroup()
```

Se consigue el data frame con la información de las personas activas según el mes.

```{r data_inactivos}
columnas.excluir <- c("id", "fec_nac", "sexo", "edad", "cotizaciones", "cotizaciones.2023")

datos.variables <- cotizantes.VP[, !names(cotizantes.VP) %in% columnas.excluir]
datos.transformados <- as.data.frame(ifelse(datos.variables > 0, 1, 0))
datos.excluidos <- cotizantes.VP[, columnas.excluir, drop = FALSE]

cotizantes.VP.activos <- cbind(datos.excluidos, datos.transformados)
```



```{r frecuencia_inactivos}
data.anual <- cotizantes.VP.activos %>%
  pivot_longer(
    cols = -all_of(columnas.excluir),
    names_to = "mes_anio",
    values_to = "cotizacion"
  ) %>%
  mutate(anio = str_sub(mes_anio, start = 4)) 

resumen.anual <- data.anual %>%
  group_by(id, anio) %>%
  summarise(cotizaciones = sum(cotizacion, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = anio, values_from = cotizaciones)

columnas.info.extra <- cotizantes.VP.activos %>%
  select(all_of(columnas.excluir)) %>%
  distinct(id, .keep_all = TRUE)

cotizantes.activos <- columnas.info.extra %>%
  left_join(resumen.anual, by = "id")

rm(columnas.info.extra)
rm(resumen.anual)
rm(data.anual)
rm(cols_anios)
rm(columnas.excluir)
```



```{r probabilidad_postergacion_hombres}
df.probabilidad.postergacion.h <- ifelse(edades.h >= 65, 0.1, 0)

df.probabilidad.postergacion.h <- as.data.frame(df.probabilidad.postergacion.h)

colnames(df.probabilidad.postergacion.h) <- colnames(edades.h)
```


```{r probabilidad_postergacion_mujeres}
df.probabilidad.postergacion.m <- ifelse(edades.m >= 65, 0.1, 0)

df.probabilidad.postergacion.m <- as.data.frame(df.probabilidad.postergacion.m)

colnames(df.probabilidad.postergacion.m) <- colnames(edades.m)
```


## Parte Estocástica (Venegas): Luego borramos esto.

Vamos a crear las dos matrices aleatorias usando distribución uniforme.
Se crean dos matrices, para los respectivos sexos.

```{r generacion_matriz_aleatoria_hombre}
set.seed(0609)  

matriz.aleatoria.h1<- matrix(runif(2595 * 95), nrow = 2595, ncol = 95)
colnames(matriz.aleatoria.h1) <- colnames(edades.h)

matriz.aleatoria.h2 <- matrix(runif(2595 * 95), nrow = 2595, ncol = 95)
colnames(matriz.aleatoria.h2) <- colnames(edades.h)
```



```{r generacion_matriz_aleatoria_mujer}
set.seed(0609)  

matriz.aleatoria.m1<- matrix(runif(2601 * 95), nrow = 2601, ncol = 95)
colnames(matriz.aleatoria.m1) <- colnames(edades.m)

matriz.aleatoria.m2 <- matrix(runif(2601 * 95), nrow = 2601, ncol = 95)
colnames(matriz.aleatoria.m2) <- colnames(edades.m)
```

```{r matriz_actvios_por_año}
cols.anios <- as.character(1995:2024)

activos <- cotizantes.activos

activos[cols.anios] <- lapply(activos[cols.anios], function(x) ifelse(x == 0, 0, 1))
rm(cols.anios)
```


```{r probabilidad_activo_anuales}
cols.anios <- as.character(1995:2024)

probabilidades.anuales <- sapply(activos[cols.anios], function(columna) {
  mean(columna == 1)  
})

probabilidades.df <- data.frame(
  anio = as.integer(names(probabilidades.anuales)),
  probabilidad.activo = probabilidades.anuales
)
rm(cols.anios)
```


```{r obtencion_probabilidad_activo}
proba.activo <- probabilidades.df %>%
  filter(anio == 2023) %>%
  pull(probabilidad.activo)
proba.activo
```


```{r matriz_aleatoria_activos}
# Se crea la matriz de hombres
inactivo.h <- matrix(0.941301, nrow = 2595, ncol = 95)

# Se crea la matriz de mujeres
inactivo.m <- matrix(0.941301, nrow = 2601, ncol = 95)
```


```{r inactividad_simulada}
inactividad.simulada.h <- ifelse(matriz.aleatoria.h1 < inactivo.h, 1, 0)
inactividad.simulada.m <- ifelse(matriz.aleatoria.m1 < inactivo.m, 1, 0)
```


```{r inactividad-ajuste}
inactividad.simulada.h <- inactividad.simulada.h + 1
inactividad.simulada.m <- inactividad.simulada.m + 1
```


```{r postergacion_simulada_hombre}
postergacion.simulada.h <- ifelse(matriz.aleatoria.h2 < df.probabilidad.postergacion.h, 1, 0)


for (i in 1:nrow(postergacion.simulada.h)) {
  primera_no_postergacion <- which(postergacion.simulada.h[i, ] == 0)[1]
  if (!is.na(primera_no_postergacion)) {
    postergacion.simulada.h[i, (primera_no_postergacion + 1):ncol(postergacion.simulada.h)] <- 0
  }
}
```


```{r postergacion_simulada_mujer}
postergacion.simulada.m <- ifelse(matriz.aleatoria.m2 < df.probabilidad.postergacion.m, 1, 0)


for (i in 1:nrow(postergacion.simulada.m)) {
  primera_no_postergacion <- which(postergacion.simulada.m[i, ] == 0)[1]
  if (!is.na(primera_no_postergacion)) {
    postergacion.simulada.m[i, (primera_no_postergacion + 1):ncol(postergacion.simulada.m)] <- 0
  }
}
```


```{r actividad_final_simulada}
actividad.simulada.h <- postergacion.simulada.h * inactividad.simulada.h
actividad.simulada.m <- postergacion.simulada.m * inactividad.simulada.m
```


```{r años_postergados}
anios.postergados.h <- rowSums(postergacion.simulada.h)
anios.postergados.h <- as.data.frame(anios.postergados.h)

anios.postergados.m <- rowSums(postergacion.simulada.m)
anios.postergados.m <- as.data.frame(anios.postergados.m)
```


```{r}
mayores.65.h <- ifelse(edades.h > 65, 1, 0)
mayores.65.m <- ifelse(edades.m > 65, 1, 0)
```


```{r}
resultado.h <- mayores.65.h * actividad.simulada.h
resultado.m <- mayores.65.m * actividad.simulada.m
```


```{r}
binario.resultado.h <- ifelse(resultado.h > 0, 1, 0)
binario.resultado.m <- ifelse(resultado.m > 0, 1, 0)
```


```{r}
suma.binario.resultado.h <- rowSums(binario.resultado.h)
suma.binario.resultado.m <- rowSums(binario.resultado.m)
```

```{r}
rm(meses.2023)
rm(primera_no_postergacion)
rm(suma.binario.resultado.h)
rm(suma.binario.resultado.m)
```


